<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dendropy.datamodel.treemodel._node &#8212; DendroPy 5.0.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/rtd.css?v=cedc6a2f" />
    
    <script src="../../../../_static/documentation_options.js?v=5df4c8d1"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">DendroPy 5.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.datamodel.treemodel._node</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for dendropy.datamodel.treemodel._node</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">deprecate</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">error</span>
<span class="kn">from</span> <span class="nn">dendropy.datamodel</span> <span class="kn">import</span> <span class="n">basemodel</span>
<span class="kn">from</span> <span class="nn">dendropy.datamodel.treemodel</span> <span class="kn">import</span> <span class="n">_edge</span>

<div class="viewcode-block" id="Node">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node">[docs]</a>
<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="p">,</span> <span class="n">basemodel</span><span class="o">.</span><span class="n">Annotable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :term:|Node| on a :term:|Tree|.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Node.edge_factory">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.edge_factory">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">edge_factory</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns a |Edge| object.</span>

<span class="sd">        Derived classes can override this method to provide support for</span>
<span class="sd">        specialized or different types of edges on the tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            Passed directly to constructor of |Edge|.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Edge|</span>
<span class="sd">            A new |Edge| object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_edge</span><span class="o">.</span><span class="n">Edge</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keyword Arguments</span>
<span class="sd">        -----------------</span>
<span class="sd">        taxon : |Taxon|, optional</span>
<span class="sd">            The |Taxon| instance representing the operational taxonomic</span>
<span class="sd">            unit concept associated with this Node.</span>
<span class="sd">        label : string, optional</span>
<span class="sd">            A label for this node.</span>
<span class="sd">        edge_length : numeric, optional</span>
<span class="sd">            Length or weight of the edge subtending this node.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;taxon&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_factory</span><span class="p">(</span>
            <span class="n">head_node</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;edge_length&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported keyword arguments: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot directly copy Edge&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Node.taxon_namespace_scoped_copy">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.taxon_namespace_scoped_copy">[docs]</a>
    <span class="k">def</span> <span class="nf">taxon_namespace_scoped_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot directly copy Node&quot;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">basemodel</span><span class="o">.</span><span class="n">Annotable</span><span class="o">.</span><span class="n">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
        <span class="c1"># if memo is None:</span>
        <span class="c1">#     memo = {}</span>
        <span class="c1"># other = basemodel.Annotable.__deepcopy__(self, memo=memo)</span>
        <span class="c1"># memo[id(self._child_nodes)] = other._child_nodes</span>
        <span class="c1"># for ch in self._child_nodes:</span>
        <span class="c1">#     try:</span>
        <span class="c1">#         och = memo[id(ch)]</span>
        <span class="c1">#         if och not in other._child_nodes:</span>
        <span class="c1">#             other._child_nodes.append(och)</span>
        <span class="c1">#     except KeyError:</span>
        <span class="c1">#         och = copy.deepcopy(ch, memo)</span>
        <span class="c1">#         memo[id(chd)] = och</span>
        <span class="c1">#         if och not in other._child_nodes:</span>
        <span class="c1">#             other._child_nodes.append(och)</span>
        <span class="c1"># return other</span>
        <span class="c1"># return super(Node, self).__deepcopy__(memo=memo)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># IMPORTANT LESSON LEARNED: if you define __hash__, you *must* define __eq__</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> object at </span><span class="si">{}</span><span class="s2">: &#39;</span><span class="si">{}</span><span class="s2">&#39; (</span><span class="si">{}</span><span class="s2">)&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_iter</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Node.preorder_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.preorder_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">preorder_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-order iterator over nodes of subtree rooted at this node.</span>

<span class="sd">        Visits self and all descendant nodes, with each node visited before its</span>
<span class="sd">        children. Nodes can optionally be filtered by ``filter_fn``: only nodes</span>
<span class="sd">        for which ``filter_fn`` returns |True| when called with the node as an</span>
<span class="sd">        argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding nodes of the subtree rooted at this node in</span>
<span class="sd">            pre-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">node</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">))</span></div>


<div class="viewcode-block" id="Node.preorder_internal_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.preorder_internal_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">preorder_internal_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_seed_node</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-order iterator over internal nodes of subtree rooted at this node.</span>

<span class="sd">        Visits self and all internal descendant nodes, with each node visited</span>
<span class="sd">        before its children. In DendroPy, &quot;internal nodes&quot; are nodes that have</span>
<span class="sd">        at least one child node, and thus the root or seed node is typically included</span>
<span class="sd">        unless ``exclude_seed_node`` is |True|. Nodes can optionally be filtered</span>
<span class="sd">        by ``filter_fn``: only nodes for which ``filter_fn`` returns |True| when</span>
<span class="sd">        passed the node as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>
<span class="sd">        exclude_seed_node : boolean, optional</span>
<span class="sd">            If |False| (default), then the seed node or root is visited. If</span>
<span class="sd">            |True|, then the seed node is skipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding the internal nodes of the subtree rooted at</span>
<span class="sd">            this node in pre-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude_seed_node</span><span class="p">:</span>
            <span class="n">froot</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">froot</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">filter_fn</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">froot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="ow">and</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="ow">and</span> <span class="n">froot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">f</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.postorder_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.postorder_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">postorder_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-order iterator over nodes of subtree rooted at this node.</span>

<span class="sd">        Visits self and all descendant nodes, with each node visited after its</span>
<span class="sd">        children. Nodes can optionally be filtered by ``filter_fn``: only nodes</span>
<span class="sd">        for which ``filter_fn`` returns |True| when called with the node as an</span>
<span class="sd">        argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding the nodes of the subtree rooted at</span>
<span class="sd">            this node in post-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if self._child_nodes:</span>
        <span class="c1">#     for nd in self._child_nodes:</span>
        <span class="c1">#         for ch in nd.postorder_iter(filter_fn=filter_fn):</span>
        <span class="c1">#             yield ch</span>
        <span class="c1"># if filter_fn is None or filter_fn(self):</span>
        <span class="c1">#     yield self</span>
        <span class="c1"># return</span>

        <span class="c1"># stack = [(self, False)]</span>
        <span class="c1"># while stack:</span>
        <span class="c1">#     node, state = stack.pop(0)</span>
        <span class="c1">#     if state:</span>
        <span class="c1">#         if filter_fn is None or filter_fn(node):</span>
        <span class="c1">#             yield node</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         stack.insert(0, (node, True))</span>
        <span class="c1">#         child_nodes = [(n, False) for n in node._child_nodes]</span>
        <span class="c1">#         child_nodes.extend(stack)</span>
        <span class="c1">#         stack = child_nodes</span>

        <span class="c1">## Prefer `pop()` to `pop(0)`.</span>
        <span class="c1">## Thanks to Mark T. Holder</span>
        <span class="c1">## From peyotl commits: d1ffef2 + 19fdea1</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">state</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">node</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)])</span></div>


<div class="viewcode-block" id="Node.postorder_internal_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.postorder_internal_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">postorder_internal_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_seed_node</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-order iterator over internal nodes of subtree rooted at this node.</span>

<span class="sd">        Visits self and all internal descendant nodes, with each node visited</span>
<span class="sd">        after its children. In DendroPy, &quot;internal nodes&quot; are nodes that have</span>
<span class="sd">        at least one child node, and thus the root or seed node is typically</span>
<span class="sd">        included unless ``exclude_seed_node`` is |True|. Nodes can optionally be</span>
<span class="sd">        filtered by ``filter_fn``: only nodes for which ``filter_fn`` returns</span>
<span class="sd">        |True| when passed the node as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>
<span class="sd">        exclude_seed_node : boolean, optional</span>
<span class="sd">            If |False| (default), then the seed node or root is visited. If</span>
<span class="sd">            |True|, then the seed node is skipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding the internal nodes of the subtree rooted at</span>
<span class="sd">            this node in post-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude_seed_node</span><span class="p">:</span>
            <span class="n">froot</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">froot</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">filter_fn</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">froot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="ow">and</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="ow">and</span> <span class="n">froot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">f</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.levelorder_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.levelorder_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">levelorder_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Level-order iteration over nodes of subtree rooted at this node.</span>

<span class="sd">        Visits self and all descendant nodes, with each node and other nodes at</span>
<span class="sd">        the same level (distance from root) visited before their children.</span>
<span class="sd">        Nodes can optionally be filtered by ``filter_fn``: only nodes for which</span>
<span class="sd">        ``filter_fn`` returns |True| when called with the node as an argument are</span>
<span class="sd">        visited.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding nodes of the subtree rooted at this node in</span>
<span class="sd">            level-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="n">remaining</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">remaining</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">node</span>
            <span class="n">child_nodes</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
            <span class="n">remaining</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.level_order_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.level_order_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">level_order_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: Use :meth:`Node.levelorder_iter()` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;level_order_iter()&#39; will no longer be&quot;</span>
                <span class="s2">&quot; supported in future releases; use &#39;levelorder_iter()&#39; instead&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">levelorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.inorder_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.inorder_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">inorder_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-order iteration over nodes of subtree rooted at this node.</span>

<span class="sd">        Visits self and all descendant nodes, with each node visited in-between</span>
<span class="sd">        its children. Only valid for strictly-bifurcating trees. Nodes can</span>
<span class="sd">        optionally be filtered by ``filter_fn``: only nodes for which ``filter_fn``</span>
<span class="sd">        returns |True| when called with the node as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding nodes of the subtree rooted at this node in</span>
<span class="sd">            infix or in-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">inorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">nd</span>
            <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">inorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">nd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;In-order traversal only supported for binary trees&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.leaf_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.leaf_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">leaf_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all tips or leaves that ultimately descend from this node.</span>

<span class="sd">        Visits all leaf or tip nodes descended from this node. Nodes can</span>
<span class="sd">        optionally be filtered by ``filter_fn``: only nodes for which ``filter_fn``</span>
<span class="sd">        returns |True| when called with the node as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding leaf nodes of the subtree rooted at this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_fn</span><span class="p">:</span>
            <span class="n">ff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span> <span class="ow">and</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_iter</span><span class="p">(</span><span class="n">ff</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">node</span></div>


<div class="viewcode-block" id="Node.child_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.child_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">child_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all nodes that are the (immediate) children of this node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding nodes that have this node as a parent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">node</span></div>


<div class="viewcode-block" id="Node.child_edge_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.child_edge_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">child_edge_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all edges that are the (immediate) children of this edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Edge| object as an argument</span>
<span class="sd">            and returns |True| if the |Edge| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all edges visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Edge|]</span>
<span class="sd">            An iterator yielding edges that have this edge as a parent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">edge</span></div>


<div class="viewcode-block" id="Node.ancestor_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.ancestor_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">ancestor_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all ancestors of this node.</span>

<span class="sd">        Visits all nodes that are the ancestors of this node.  If ``inclusive``</span>
<span class="sd">        is |True|, ``self`` is returned as the first item of the sequence;</span>
<span class="sd">        otherwise ``self`` is skipped. Nodes can optionally be filtered by</span>
<span class="sd">        ``filter_fn``: only nodes for which ``filter_fn`` returns |True| when</span>
<span class="sd">        passed the node as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>
<span class="sd">        inclusive : boolean, optional</span>
<span class="sd">            If |True|, includes this node in the sequence. If |False|, this is</span>
<span class="sd">            skipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            Iterator over all predecessor/ancestor nodes of this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inclusive</span> <span class="ow">and</span> <span class="p">(</span><span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">node</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="n">node</span></div>


<div class="viewcode-block" id="Node.ageorder_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.ageorder_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">ageorder_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over nodes of subtree rooted at this node in order of the age</span>
<span class="sd">        of the node (i.e., the time since the present).</span>

<span class="sd">        Iterates over nodes in order of age (&#39;age&#39; is as given by the ``age``</span>
<span class="sd">        attribute, which is usually the sum of edge lengths from tips</span>
<span class="sd">        to node, i.e., time since present).</span>
<span class="sd">        If ``include_leaves`` is |True| (default), leaves are included in the</span>
<span class="sd">        iteration; if ``include_leaves`` is |False|, leaves will be skipped.</span>
<span class="sd">        If ``descending`` is |False| (default), younger nodes will be returned</span>
<span class="sd">        before older ones; if |True|, older nodes will be returned before</span>
<span class="sd">        younger ones.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (defau</span>
<span class="sd">        include_leaves : boolean, optional</span>
<span class="sd">            If |True| (default), then leaf nodes are included in the iteration.</span>
<span class="sd">            If |False|, then leaf nodes are skipped.lt), then all nodes visited will be yielded.</span>
<span class="sd">        descending : boolean, optional</span>
<span class="sd">            If |False| (default), then younger nodes are visited before older</span>
<span class="sd">            ones. If |True|, then older nodes are visited before younger ones.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            Iterator over age-ordered sequence of nodes in subtree rooted at</span>
<span class="sd">            this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if not descending:</span>
        <span class="c1">#     leaves = [nd for nd in self.leaf_iter()]</span>
        <span class="c1">#     queued_pairs = []</span>
        <span class="c1">#     in_queue = set()</span>
        <span class="c1">#     for leaf in leaves:</span>
        <span class="c1">#         age_nd_tuple = (leaf.age, leaf)</span>
        <span class="c1">#         queued_pairs.insert(bisect.bisect(queued_pairs, age_nd_tuple), age_nd_tuple)</span>
        <span class="c1">#         in_queue.add(leaf)</span>
        <span class="c1">#     while queued_pairs:</span>
        <span class="c1">#         next_el = queued_pairs.pop(0)</span>
        <span class="c1">#         age, nd = next_el</span>
        <span class="c1">#         in_queue.remove(nd)</span>
        <span class="c1">#         p = nd._parent_node</span>
        <span class="c1">#         if p and p not in in_queue:</span>
        <span class="c1">#             age_nd_tuple = (p.age, p)</span>
        <span class="c1">#             queued_pairs.insert(bisect.bisect(queued_pairs, age_nd_tuple), age_nd_tuple)</span>
        <span class="c1">#             in_queue.add(p)</span>
        <span class="c1">#         if include_leaves or nd.is_internal():</span>
        <span class="c1">#             yield nd</span>
        <span class="c1"># else:</span>
        <span class="c1">#     nds = [(nd.age, nd) for nd in self.preorder_iter()]</span>
        <span class="c1">#     nds.sort(reverse=True)</span>
        <span class="c1">#     for nd in nds:</span>
        <span class="c1">#         if include_leaves or nd[1].is_internal():</span>
        <span class="c1">#             yield nd[1]</span>
        <span class="n">nds</span> <span class="o">=</span> <span class="p">[</span><span class="n">nd</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_iter</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">descending</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">nds</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">age</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">nds</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">include_leaves</span> <span class="ow">or</span> <span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">yield</span> <span class="n">nd</span></div>


<div class="viewcode-block" id="Node.age_order_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.age_order_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">age_order_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated: use :meth:`Node.ageorder_iter()` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;age_order_iter()&#39; will no longer be&quot;</span>
                <span class="s2">&quot; supported in future releases; use &#39;ageorder_iter()&#39; instead&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ageorder_iter</span><span class="p">(</span>
            <span class="n">include_leaves</span><span class="o">=</span><span class="n">include_leaves</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="n">descending</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Node.apply">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.apply">[docs]</a>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies function ``before_fn`` and ``after_fn`` to all internal nodes and</span>
<span class="sd">        ``leaf_fn`` to all terminal nodes in subtree starting with ``self``, with</span>
<span class="sd">        nodes visited in pre-order.</span>

<span class="sd">        Given a tree with preorder sequence of nodes of</span>
<span class="sd">        [a,b,i,e,j,k,c,g,l,m,f,n,h,o,p,]::</span>

<span class="sd">                           a</span>
<span class="sd">                          / \</span>
<span class="sd">                         /   \</span>
<span class="sd">                        /     \</span>
<span class="sd">                       /       \</span>
<span class="sd">                      /         \</span>
<span class="sd">                     /           \</span>
<span class="sd">                    /             c</span>
<span class="sd">                   b             / \</span>
<span class="sd">                  / \           /   \</span>
<span class="sd">                 /   e         /     f</span>
<span class="sd">                /   / \       /     / \</span>
<span class="sd">               /   /   \     g     /   h</span>
<span class="sd">              /   /     \   / \   /   / \</span>
<span class="sd">             i   j       k l   m n   o   p</span>


<span class="sd">        the following order of function calls results:</span>

<span class="sd">            before_fn(a)</span>
<span class="sd">            before_fn(b)</span>
<span class="sd">            leaf_fn(i)</span>
<span class="sd">            before_fn(e)</span>
<span class="sd">            leaf_fn(j)</span>
<span class="sd">            leaf_fn(k)</span>
<span class="sd">            after_fn(e)</span>
<span class="sd">            after_fn(b)</span>
<span class="sd">            before_fn(c)</span>
<span class="sd">            before_fn(g)</span>
<span class="sd">            leaf_fn(l)</span>
<span class="sd">            leaf_fn(m)</span>
<span class="sd">            after_fn(g)</span>
<span class="sd">            before_fn(f)</span>
<span class="sd">            leaf_fn(n)</span>
<span class="sd">            before_fn(h)</span>
<span class="sd">            leaf_fn(o)</span>
<span class="sd">            leaf_fn(p)</span>
<span class="sd">            after_fn(h)</span>
<span class="sd">            after_fn(f)</span>
<span class="sd">            after_fn(c)</span>
<span class="sd">            after_fn(a)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        before_fn : function object or |None|</span>
<span class="sd">            A function object that takes a |Node| as its argument.</span>
<span class="sd">        after_fn : function object or |None|</span>
<span class="sd">            A function object that takes a |Node| as its argument.</span>
<span class="sd">        leaf_fn : function object or |None|</span>
<span class="sd">            A function object that takes a |Node| as its argument.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Adapted from work by Mark T. Holder (the ``peyotl`` module of the Open</span>
<span class="sd">        Tree of Life Project):</span>

<span class="sd">            https://github.com/OpenTreeOfLife/peyotl.git</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">leaf_fn</span><span class="p">:</span>
                    <span class="n">leaf_fn</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="c1"># (while node is the last child of parent ...)</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">node</span>
                <span class="p">):</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">after_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">after_fn</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">before_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">before_fn</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)])</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Node.set_child_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.set_child_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">set_child_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child_nodes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigns the set of child nodes for this node.</span>

<span class="sd">        Results in the ``parent_node`` attribute of each |Node| in ``nodes``</span>
<span class="sd">        as well as the ``tail_node`` attribute of corresponding |Edge|</span>
<span class="sd">        objects being assigned to ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        child_nodes : collections.Iterable[|Node|]</span>
<span class="sd">            The (iterable) collection of child nodes to be assigned this node</span>
<span class="sd">            as a parent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_child_nodes</span><span class="p">()</span>
        <span class="c1"># Go through add to ensure book-keeping</span>
        <span class="c1"># (e.g. avoiding multiple adds) takes</span>
        <span class="c1"># place.</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">child_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.set_children">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.set_children">[docs]</a>
    <span class="k">def</span> <span class="nf">set_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child_nodes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated: use :meth:`Node.set_child_nodes()` instead.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_child_nodes</span><span class="p">(</span><span class="n">child_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.add_child">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.add_child">[docs]</a>
    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a child node to this node if it is not already a child.</span>

<span class="sd">        Results in the ``parent_node`` attribute of ``node`` as well as the</span>
<span class="sd">        ``tail_node`` attribute of ``node.edge`` being assigned to ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : |Node|</span>
<span class="sd">            The node to be added as a child of this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node|</span>
<span class="sd">            The node that was added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Cannot add node as child of itself&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">node</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;Cannot add a node&#39;s parent as its child: remove the node from its parent&#39;s&quot;</span>
            <span class="s2">&quot; child set first&quot;</span>
        <span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span></div>


<div class="viewcode-block" id="Node.insert_child">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.insert_child">[docs]</a>
    <span class="k">def</span> <span class="nf">insert_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a child node to this node.</span>

<span class="sd">        If the node is already a child of this node, then it is moved</span>
<span class="sd">        to the specified position.</span>
<span class="sd">        Results in the ``parent_node`` attribute of ``node`` as well as the</span>
<span class="sd">        ``tail_node`` attribute of ``node.edge`` being assigned to ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : integer</span>
<span class="sd">            The index before which to insert the new node.</span>
<span class="sd">        node : |Node|</span>
<span class="sd">            The node to be added as a child of this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node|</span>
<span class="sd">            The node that was added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cur_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur_index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span></div>


<div class="viewcode-block" id="Node.new_child">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.new_child">[docs]</a>
    <span class="k">def</span> <span class="nf">new_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and add a new child to this node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            Keyword arguments will be passed directly to the |Node|</span>
<span class="sd">            constructor (:meth:`Node.__init()__`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node|</span>
<span class="sd">            The new child node that was created and added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.insert_new_child">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.insert_new_child">[docs]</a>
    <span class="k">def</span> <span class="nf">insert_new_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and add a new child to this node at a particular position.</span>

<span class="sd">        Results in the ``parent_node`` attribute of ``node`` as well as the</span>
<span class="sd">        ``tail_node`` attribute of ``node.edge`` being assigned to ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : integer</span>
<span class="sd">            The index before which to insert the new node.</span>
<span class="sd">        kwargs : keyword arguments, optional</span>
<span class="sd">            Keyword arguments will be passed directly to the |Node|</span>
<span class="sd">            constructor (:meth:`Node.__init()__`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node|</span>
<span class="sd">            The new child node that was created and added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert_child</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.remove_child">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.remove_child">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a node from the child set of this node.</span>

<span class="sd">        Results in the parent of the node being removed set to |None|.  If</span>
<span class="sd">        ``suppress_unifurcations`` is |True|, if this node ends up having only one</span>
<span class="sd">        child after removal of the specified node, then this node will be</span>
<span class="sd">        removed from the tree, with its single child added to the child node</span>
<span class="sd">        set of its parent and the edge length adjusted accordingly.</span>
<span class="sd">        ``suppress_unifurcations`` should only be |True| for unrooted trees.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : |Node|</span>
<span class="sd">            The node to be removed.</span>
<span class="sd">        suppress_unifurcations : boolean, optional</span>
<span class="sd">            If |False| (default), no action is taken. If |True|, then if the</span>
<span class="sd">            node removal results in a node with degree of two (i.e., a single</span>
<span class="sd">            parent and a single child), then it will be removed from</span>
<span class="sd">            the tree and its (sole) child will be added as a child of its</span>
<span class="sd">            parent (with edge lengths adjusted accordingly).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node|</span>
<span class="sd">            The node removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tried to remove an non-existing or null node&quot;</span><span class="p">)</span>
        <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">children</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">suppress_unifurcations</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">child</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">insert_child</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span>
                            <span class="bp">self</span><span class="p">,</span> <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_remove</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_internal</span><span class="p">():</span>
                            <span class="n">to_remove</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">other</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_internal</span><span class="p">():</span>
                            <span class="n">to_remove</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">other</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">to_remove</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">other</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="n">to_remove</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">to_remove</span><span class="p">,</span> <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">tr_children</span> <span class="o">=</span> <span class="n">to_remove</span><span class="o">.</span><span class="n">_child_nodes</span>
                        <span class="n">tr_children</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tr_children</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">insert_child</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                        <span class="n">to_remove</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tried to remove a node that is not listed as a child&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span></div>


<div class="viewcode-block" id="Node.clear_child_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.clear_child_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">clear_child_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all child nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>


<div class="viewcode-block" id="Node.reversible_remove_child">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.reversible_remove_child">[docs]</a>
    <span class="k">def</span> <span class="nf">reversible_remove_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is a (less-efficient) version of remove_child that also</span>
<span class="sd">        returns the data needed by reinsert_nodes to &quot;undo&quot; the removal.</span>

<span class="sd">        Returns a list of tuples.  The first element of each tuple is the</span>
<span class="sd">        node removed, the other elements are the information needed by</span>
<span class="sd">        ``reinsert_nodes`` in order to restore the tree to the same topology as</span>
<span class="sd">        it was before the call to ``remove_child.`` If ``suppress_unifurcations`` is False</span>
<span class="sd">        then the returned list will contain only one item.</span>

<span class="sd">        ``suppress_unifurcations`` should only be called on unrooted trees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tried to remove an non-existing or null node&quot;</span><span class="p">)</span>
        <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">children</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tried to remove a node that is not listed as a child&quot;</span><span class="p">)</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="p">[],</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">suppress_unifurcations</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">child</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">insert_child</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">edge</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">e</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="p">[</span><span class="n">child</span><span class="p">],</span> <span class="n">e</span><span class="p">)</span>
                    <span class="n">removed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_remove</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_internal</span><span class="p">():</span>
                        <span class="n">to_remove</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_internal</span><span class="p">():</span>
                        <span class="n">to_remove</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">to_remove</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">edge</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">e</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="n">to_remove</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">to_remove</span><span class="p">,</span> <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">tr_children</span> <span class="o">=</span> <span class="n">to_remove</span><span class="o">.</span><span class="n">_child_nodes</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tr_children</span><span class="p">):</span>
                        <span class="n">new_pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">n</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">insert_child</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">to_remove</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">tr_children</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                    <span class="n">removed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">removed</span></div>


<div class="viewcode-block" id="Node.reinsert_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.reinsert_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">reinsert_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nd_connection_list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function should be used to &quot;undo&quot; the effects of</span>
<span class="sd">        Node.reversible_remove_child NOTE: the behavior is only</span>
<span class="sd">        guaranteed if the tree has not been modified between the</span>
<span class="sd">        remove_child and reinsert_nodes calls! (or the tree has been</span>
<span class="sd">        restored such that the node/edge identities are identical to the</span>
<span class="sd">        state before the remove_child call.</span>

<span class="sd">        The order of info in each tuple is:</span>

<span class="sd">            0 - node removed</span>
<span class="sd">            1 - parent of node removed</span>
<span class="sd">            2 - pos in parent matrix</span>
<span class="sd">            3 - children of node removed that were &quot;stolen&quot;</span>
<span class="sd">            4 - edge that was lengthened by &quot;stealing&quot; length from node&#39;s edge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we unroll the stack of operations</span>
        <span class="k">for</span> <span class="n">blob</span> <span class="ow">in</span> <span class="n">nd_connection_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># _LOG.debug(blob)</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">blob</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">cp</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">_parent_node</span>
                <span class="k">if</span> <span class="n">cp</span><span class="p">:</span>
                    <span class="n">cp</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">n</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">insert_child</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">length</span> <span class="o">-=</span> <span class="n">n</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span></div>


    <span class="k">def</span> <span class="nf">collapse_neighborhood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ch</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">collapse</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">collapse</span><span class="p">()</span>
            <span class="n">p</span><span class="o">.</span><span class="n">collapse_neighborhood</span><span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapse_neighborhood</span><span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="Node.collapse_clade">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.collapse_clade">[docs]</a>
    <span class="k">def</span> <span class="nf">collapse_clade</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Collapses all internal edges that are descendants of self.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_iter</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_child_nodes</span><span class="p">(</span><span class="n">leaves</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.collapse_conflicting">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.collapse_conflicting">[docs]</a>
    <span class="k">def</span> <span class="nf">collapse_conflicting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bipartition</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collapses every edge in the subtree that conflicts with the given</span>
<span class="sd">        bipartition. This can include the edge subtending subtree_root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_collapse_head_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="ow">and</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">is_incompatible_with</span><span class="p">(</span>
                <span class="n">bipartition</span>
            <span class="p">):</span>
                <span class="n">to_collapse_head_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">to_collapse_head_nodes</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span>
            <span class="n">e</span><span class="o">.</span><span class="n">collapse</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_get_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the edge subtending this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span>

    <span class="k">def</span> <span class="nf">_set_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_edge</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the edge subtending this node, and sets head_node of</span>
<span class="sd">        ``edge`` to point to self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if edge is None:</span>
        <span class="c1">#     raise ValueError(&quot;A Node cannot have &#39;None&#39; for an edge&quot;)</span>
        <span class="k">if</span> <span class="n">new_edge</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1">## Minimal management</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span> <span class="o">=</span> <span class="n">new_edge</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">_head_node</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="n">edge</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_edge</span><span class="p">,</span> <span class="n">_set_edge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_edge_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the length of the edge subtending this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">length</span>

    <span class="k">def</span> <span class="nf">_set_edge_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the edge subtending this node, and sets head_node of</span>
<span class="sd">        ``edge`` to point to self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">edge_length</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_edge_length</span><span class="p">,</span> <span class="n">_set_edge_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_bipartition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the bipartition for the edge subtending this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">bipartition</span>

    <span class="k">def</span> <span class="nf">_set_bipartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the bipartition for the edge subtending this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">bipartition</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">bipartition</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_bipartition</span><span class="p">,</span> <span class="n">_set_bipartition</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_split_bitmask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_split_bitmask</span>

    <span class="k">def</span> <span class="nf">_set_split_bitmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_split_bitmask</span> <span class="o">=</span> <span class="n">h</span>

    <span class="n">split_bitmask</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_split_bitmask</span><span class="p">,</span> <span class="n">_set_split_bitmask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_leafset_bitmask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span>

    <span class="k">def</span> <span class="nf">_set_leafset_bitmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span> <span class="o">=</span> <span class="n">h</span>

    <span class="n">leafset_bitmask</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_leafset_bitmask</span><span class="p">,</span> <span class="n">_set_leafset_bitmask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_tree_leafset_bitmask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_tree_leafset_bitmask</span>

    <span class="k">def</span> <span class="nf">_set_tree_leafset_bitmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_tree_leafset_bitmask</span> <span class="o">=</span> <span class="n">h</span>

    <span class="n">tree_leafset_bitmask</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">_get_tree_leafset_bitmask</span><span class="p">,</span> <span class="n">_set_tree_leafset_bitmask</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">split_as_bitstring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_bitstring</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">leafset_as_bitstring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_as_bitstring</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_parent_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the parent node of this node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span>

    <span class="k">def</span> <span class="nf">_set_parent_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the parent node of this node.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">parent_node</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_parent_node</span><span class="p">,</span> <span class="n">_set_parent_node</span><span class="p">)</span>

<div class="viewcode-block" id="Node.is_leaf">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.is_leaf">[docs]</a>
    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns |True| if the node is a tip or a leaf node, i.e. has no child</span>
<span class="sd">        nodes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        boolean</span>
<span class="sd">            |True| if the node is a leaf, i.e., has no child nodes. |False|</span>
<span class="sd">            otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.is_internal">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.is_internal">[docs]</a>
    <span class="k">def</span> <span class="nf">is_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns |True| if the node is *not* a tip or a leaf node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        boolean</span>
<span class="sd">            |True| if the node is not a leaf. |False| otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.leaf_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.leaf_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">leaf_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of all leaf_nodes descended from this node (or just</span>
<span class="sd">        list with ``self`` as the only member if ``self`` is a leaf).</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Usage of  `leaf_iter()` is preferable for efficiency reasons unless</span>
<span class="sd">        actual list is required.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Node|]</span>
<span class="sd">           A ``list`` of |Node| objects descended from this node</span>
<span class="sd">           (inclusive of ``self``) that are the leaves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">node</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_iter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Node.num_child_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.num_child_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">num_child_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns number of child nodes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Number of children in ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.child_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.child_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">child_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a shallow-copy list of all child nodes of this node.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Unless an actual ``list`` is needed, iterating over the child nodes using</span>
<span class="sd">        :meth:`Node.child_node_iter()` is preferable to avoid the overhead of</span>
<span class="sd">        list construction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Node|]</span>
<span class="sd">           A ``list`` of |Node| objects that have ``self`` as a parent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.child_edges">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.child_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">child_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a shallow-copy list of all child edges of this node.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Unless an actual ``list`` is needed, iterating over the child edges using</span>
<span class="sd">        :meth:`Node.child_edge_iter()` is preferable to avoid the overhead of</span>
<span class="sd">        list construction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Edge|]</span>
<span class="sd">           A ``list`` of |Edge| objects that have ``self`` as a tail node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">edge</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.incident_edges">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.incident_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">incident_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return parent and child edges.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Edge|]</span>
<span class="sd">            A list of edges linking to this node, with outgoing edges (edges</span>
<span class="sd">            connecting to child nodes) followed by the edge connecting</span>
<span class="sd">            this node to its parent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">edge</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">]</span>
        <span class="n">e</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">e</span></div>


<div class="viewcode-block" id="Node.get_incident_edges">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.get_incident_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">get_incident_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Legacy synonym for :meth:`Node.incident_edges()`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">incident_edges</span><span class="p">()</span></div>


<div class="viewcode-block" id="Node.adjacent_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.adjacent_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">adjacent_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return parent and child nodes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Node|]</span>
<span class="sd">            A list with all child nodes and parent node of this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="p">:</span>
            <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span></div>


<div class="viewcode-block" id="Node.get_adjacent_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.get_adjacent_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">get_adjacent_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Legacy synonym for :meth:`Node.adjacent_edges()`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacent_nodes</span><span class="p">()</span></div>


<div class="viewcode-block" id="Node.sibling_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.sibling_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">sibling_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all other children of parent, excluding self.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Node|]</span>
<span class="sd">            A list of all nodes descended from the same parent as ``self``,</span>
<span class="sd">            excluding ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">sisters</span> <span class="o">=</span> <span class="p">[</span><span class="n">nd</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">nd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sisters</span></div>


<div class="viewcode-block" id="Node.sister_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.sister_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">sister_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Legacy synonym for :meth:`Node.sister_nodes()`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sibling_nodes</span><span class="p">()</span></div>


<div class="viewcode-block" id="Node.extract_subtree">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.extract_subtree">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_subtree</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">extraction_source_reference_attr_name</span><span class="o">=</span><span class="s2">&quot;extraction_source&quot;</span><span class="p">,</span>
        <span class="n">node_filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">is_apply_filter_to_leaf_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">is_apply_filter_to_internal_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">node_factory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a clone of the structure descending from this node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extraction_source_reference_attr_name : str</span>
<span class="sd">            Name of attribute to set on cloned nodes that references</span>
<span class="sd">            corresponding original node. If ``None``, then attribute (and</span>
<span class="sd">            reference) will not be created.</span>
<span class="sd">        node_filter_fn : None or function object</span>
<span class="sd">            If ``None``, then entire tree structure is cloned.</span>
<span class="sd">            If not ``None``, must be a function object that returns ``True``</span>
<span class="sd">            if a particular |Node| instance on the original tree should</span>
<span class="sd">            be included in the cloned tree, or ``False`` otherwise.</span>
<span class="sd">        is_apply_filter_to_leaf_nodes : bool</span>
<span class="sd">            If ``True`` then the above filter will be applied to leaf nodes. If</span>
<span class="sd">            ``False`` then it will not (and all leaf nodes will be</span>
<span class="sd">            automatically included, unless excluded by an ancestral node being</span>
<span class="sd">            filtered out).</span>
<span class="sd">        is_apply_filter_to_internal_nodes : bool</span>
<span class="sd">            If ``True`` then the above filter will be applied to internal nodes. If</span>
<span class="sd">            ``False`` then it will not (internal nodes without children will</span>
<span class="sd">            still be filtered out).</span>
<span class="sd">        node_factory : function</span>
<span class="sd">            If not ``None``, must be a function that takes no arguments and</span>
<span class="sd">            returns a new |Node| (or equivalent) instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nd : |Node|</span>
<span class="sd">            A node with descending subtree mirroring this one.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">is_excluded_nodes</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">start_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">start_node_to_match</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">node_factory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">nd1</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># verbosity to mollify linter</span>
        <span class="k">for</span> <span class="n">nd0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node_filter_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nd0</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_apply_filter_to_internal_nodes</span><span class="p">:</span>
                        <span class="n">is_apply_filter</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">is_apply_filter</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_apply_filter_to_leaf_nodes</span><span class="p">:</span>
                        <span class="n">is_apply_filter</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">is_apply_filter</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">is_apply_filter</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node_filter_fn</span><span class="p">(</span><span class="n">nd0</span><span class="p">):</span>
                    <span class="n">is_excluded_nodes</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
            <span class="n">original_node_has_children</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">children_to_add</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ch_nd0</span> <span class="ow">in</span> <span class="n">nd0</span><span class="o">.</span><span class="n">child_node_iter</span><span class="p">():</span>
                <span class="n">original_node_has_children</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">ch_nd1</span> <span class="o">=</span> <span class="n">memo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch_nd0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ch_nd1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">children_to_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch_nd1</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">children_to_add</span> <span class="ow">and</span> <span class="n">original_node_has_children</span><span class="p">:</span>
                <span class="c1"># filter removes all descendents of internal node,</span>
                <span class="c1"># so this internal node is not added</span>
                <span class="k">if</span> <span class="n">nd0</span><span class="o">.</span><span class="n">parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">SeedNodeDeletionException</span><span class="p">(</span>
                        <span class="s2">&quot;Attempting to remove seed node or node without parent&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">nd0</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">start_node_to_match</span> <span class="o">=</span> <span class="n">nd0</span><span class="o">.</span><span class="n">parent_node</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">children_to_add</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">suppress_unifurcations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nd0</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">children_to_add</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">children_to_add</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">nd0</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">children_to_add</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="n">nd0</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nd1</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">children_to_add</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                <span class="k">if</span> <span class="n">nd0</span><span class="o">.</span><span class="n">parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start_node</span> <span class="o">=</span> <span class="n">children_to_add</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">nd0</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">start_node_to_match</span> <span class="o">=</span> <span class="n">nd0</span><span class="o">.</span><span class="n">parent_node</span>
                <span class="n">memo</span><span class="p">[</span><span class="n">nd0</span><span class="p">]</span> <span class="o">=</span> <span class="n">children_to_add</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nd1</span> <span class="o">=</span> <span class="n">node_factory</span><span class="p">()</span>
                <span class="n">nd1</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">nd0</span><span class="o">.</span><span class="n">label</span>
                <span class="n">nd1</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="n">nd0</span><span class="o">.</span><span class="n">taxon</span>
                <span class="n">nd1</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">nd0</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                <span class="n">nd1</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">nd0</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">label</span>
                <span class="k">for</span> <span class="n">ch_nd1</span> <span class="ow">in</span> <span class="n">children_to_add</span><span class="p">:</span>
                    <span class="n">nd1</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">ch_nd1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nd0</span> <span class="ow">is</span> <span class="n">start_node_to_match</span><span class="p">:</span>
                    <span class="n">start_node</span> <span class="o">=</span> <span class="n">nd1</span>
                <span class="n">memo</span><span class="p">[</span><span class="n">nd0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nd1</span>
                <span class="k">if</span> <span class="n">extraction_source_reference_attr_name</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">nd1</span><span class="p">,</span> <span class="n">extraction_source_reference_attr_name</span><span class="p">,</span> <span class="n">nd0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">start_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">## TODO: find a replacement node</span>
            <span class="k">raise</span> <span class="ne">ValueError</span></div>


<div class="viewcode-block" id="Node.level">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.level">[docs]</a>
    <span class="k">def</span> <span class="nf">level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of nodes between ``self`` and the seed node of the tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integer</span>
<span class="sd">            The number of nodes between ``self`` and the seed node of the tree,</span>
<span class="sd">            or 0 if ``self`` has no parent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">level</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Node.distance_from_root">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.distance_from_root">[docs]</a>
    <span class="k">def</span> <span class="nf">distance_from_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weighted path length of ``self`` from root.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numeric</span>
<span class="sd">            Total weight of all edges connecting ``self`` with the root of the</span>
<span class="sd">            tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">distance_from_root</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">distance_from_root</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
                <span class="n">parent_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span>
                <span class="c1"># The root is identified when a node with no</span>
                <span class="c1"># parent is encountered. If we want to use some</span>
                <span class="c1"># other criteria (e.g., where a is_root property</span>
                <span class="c1"># is True), we modify it here.</span>
                <span class="k">while</span> <span class="n">parent_node</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">distance_from_root</span> <span class="o">=</span> <span class="n">distance_from_root</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span>
                            <span class="n">parent_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                        <span class="p">)</span>
                    <span class="n">parent_node</span> <span class="o">=</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">_parent_node</span>
                <span class="k">return</span> <span class="n">distance_from_root</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># what do we do here: parent node exists, but my</span>
            <span class="c1"># length does not?</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no parent node, and no edge length</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># WTF????</span>
            <span class="k">return</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="Node.distance_from_tip">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.distance_from_tip">[docs]</a>
    <span class="k">def</span> <span class="nf">distance_from_tip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maximum weighted length of path of ``self`` to tip.</span>

<span class="sd">        If tree is not ultrametric (i.e., descendent edges have different</span>
<span class="sd">        lengths), then count the maximum of edge lengths. Note that</span>
<span class="sd">        :meth:`Tree.calc_node_ages()` is a more efficient way of doing this</span>
<span class="sd">        over the whole tree if this value is need for many or all the nodes on</span>
<span class="sd">        the tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numeric</span>
<span class="sd">            Maximum weight of edges connecting ``self`` to tip.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance_from_tips</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">curr_edge_length</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">edge_length</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_edge_length</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="s2">&quot;_distance_from_tip&quot;</span><span class="p">):</span>
                    <span class="n">ch</span><span class="o">.</span><span class="n">_distance_from_tip</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">distance_from_tip</span><span class="p">()</span>
                <span class="n">distance_from_tips</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">_distance_from_tip</span> <span class="o">+</span> <span class="n">curr_edge_length</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distance_from_tip</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">distance_from_tips</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance_from_tip</span></div>


<div class="viewcode-block" id="Node.description">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Node.description">[docs]</a>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">itemize</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns description of object, up to level ``depth``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">output_strio</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">Node object at </span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">itemize</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="n">label</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">leader1</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">leader2</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span>
            <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">[Edge]&quot;</span> <span class="o">%</span> <span class="n">leader1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edge_desc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">description</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edge_desc</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
            <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">leader2</span><span class="p">,</span> <span class="n">edge_desc</span><span class="p">))</span>

            <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">[Taxon]&quot;</span> <span class="o">%</span> <span class="n">leader1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">taxon_desc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">description</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">taxon_desc</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
            <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">leader2</span><span class="p">,</span> <span class="n">taxon_desc</span><span class="p">))</span>

            <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">[Parent]&quot;</span> <span class="o">%</span> <span class="n">leader1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parent_node_desc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">description</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent_node_desc</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
            <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">leader2</span><span class="p">,</span> <span class="n">parent_node_desc</span><span class="p">))</span>
            <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">[Children]&quot;</span> <span class="o">%</span> <span class="n">leader1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">None&quot;</span> <span class="o">%</span> <span class="n">leader2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">):</span>
                    <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">] </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">leader2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnd</span><span class="o">.</span><span class="n">description</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">output_strio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>


    <span class="c1">## For debugging we build-in a full-fledged NEWICK composition independent</span>
    <span class="c1">## of the nexus/newick family of modules. Client code should prefer to</span>
    <span class="c1">## use Newick/Nexus readers/writers, or Tree.write(), TreeList.write(),</span>
    <span class="c1">## DataSet.write() etc.</span>

    <span class="k">def</span> <span class="nf">_as_newick_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This returns the Node as a NEWICK statement according to the given</span>
<span class="sd">        formatting rules. This should be used for debugging purposes only.</span>
<span class="sd">        For production purposes, use the the full-fledged &#39;as_string()&#39;</span>
<span class="sd">        method of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_newick</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_write_newick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This returns the Node as a NEWICK statement according to the given</span>
<span class="sd">        formatting rules. This should be used for debugging purposes only.  For</span>
<span class="sd">        production purposes, use the the full-fledged &#39;write_to_stream()&#39;</span>
<span class="sd">        method of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_lengths</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;suppress_edge_lengths&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">edge_lengths</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_lengths&quot;</span><span class="p">,</span> <span class="n">edge_lengths</span><span class="p">)</span>
        <span class="n">child_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">child_nodes</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span>
            <span class="n">f_child</span> <span class="o">=</span> <span class="n">child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">child_nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">f_child</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
                <span class="n">child</span><span class="o">.</span><span class="n">_write_newick</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_node_token</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">edge_lengths</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span>
            <span class="k">if</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">length</span>
                <span class="k">if</span> <span class="n">sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_length_formatter&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">fmt</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fmt</span><span class="p">(</span><span class="n">sel</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
                            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_node_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;returns a string that is an identifier for the node.  This is called</span>
<span class="sd">        by the newick-writing functions, so the kwargs that affect how node</span>
<span class="sd">        labels show up in a newick string are the same ones used here:</span>
<span class="sd">        ``suppress_internal_labels`` is a Boolean, and defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_leaf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_leaf</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;suppress_internal_labels&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;include_internal_labels&quot;</span><span class="p">,</span> <span class="kc">True</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># return &quot;_&quot; # taxon, but no label: anonymous</span>
                <span class="n">label</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># &quot;_&quot; is not anonoymous/unnamed, but a name of &lt;blank&gt;; so we return nothing instead</span>
                    <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;raw_labels&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">label</span>
        <span class="k">elif</span> <span class="s2">&quot; &quot;</span> <span class="ow">in</span> <span class="n">label</span> <span class="ow">and</span> <span class="s2">&quot;_&quot;</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;&#39;&quot;</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">label</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;&#39;&#39;&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot; &quot;</span> <span class="ow">in</span> <span class="n">label</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;preserve_spaces&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">label</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">_get_indented_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_indented_form</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_write_indented_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">indentation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;indentation&quot;</span><span class="p">,</span> <span class="s2">&quot;    &quot;</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ancestors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">siblings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span><span class="o">.</span><span class="n">_write_indented_form_line</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">lev</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">_preorder_list_manip</span><span class="p">(</span><span class="n">siblings</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">+=</span> <span class="n">lev</span>

    <span class="k">def</span> <span class="nf">_get_indented_form_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_indented_form_line</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_write_indented_form_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">indentation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;indentation&quot;</span><span class="p">,</span> <span class="s2">&quot;    &quot;</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_node</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bipartitions&quot;</span><span class="p">):</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_format_bipartition</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">indentation</span> <span class="o">*</span> <span class="n">level</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_format_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;node_formatter&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_preorder_list_manip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">siblings</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function for recursion free preorder traversal, that does</span>
<span class="sd">        not rely on attributes of the node other than child_nodes() (thus it</span>
<span class="sd">        is useful for debuggging).</span>

<span class="sd">        Returns the next node (or None) and the number of levels toward the</span>
<span class="sd">        root the function &quot;moved&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">levels_moved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">levels_moved</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ancestors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">siblings</span><span class="p">))</span>
            <span class="k">del</span> <span class="n">siblings</span><span class="p">[:]</span>
            <span class="n">siblings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">levels_moved</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">siblings</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ancestors</span><span class="p">:</span>
                <span class="n">levels_moved</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">del</span> <span class="n">siblings</span><span class="p">[:]</span>
                <span class="n">siblings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ancestors</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">levels_moved</span>
        <span class="k">return</span> <span class="n">siblings</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">levels_moved</span>

    <span class="k">def</span> <span class="nf">_convert_node_to_root_polytomy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If ``self`` has two children and at least one of them is an internal node,</span>
<span class="sd">        then it will be converted to an out-degree three node (with the edge length</span>
<span class="sd">        added as needed).</span>

<span class="sd">        Returns a tuple of child nodes that were detached (or() if the tree was not</span>
<span class="sd">        modified). This can be useful for removing the deleted node from the split_edge_map</span>
<span class="sd">        dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nd_children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nd_children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">left_child</span> <span class="o">=</span> <span class="n">nd_children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">left_child</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nd_children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">right_child</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">dest_edge_head</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right_child</span> <span class="o">=</span> <span class="n">nd_children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dest_edge_head</span> <span class="o">=</span> <span class="n">right_child</span>
        <span class="n">curr_add</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">right_child</span> <span class="ow">and</span> <span class="n">right_child</span><span class="o">.</span><span class="n">is_internal</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">left_child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="n">right_child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">right_child</span><span class="p">)</span>
            <span class="n">grand_kids</span> <span class="o">=</span> <span class="n">right_child</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">gc</span> <span class="ow">in</span> <span class="n">grand_kids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>
            <span class="n">curr_add</span> <span class="o">=</span> <span class="n">right_child</span>
        <span class="k">elif</span> <span class="n">left_child</span><span class="o">.</span><span class="n">is_internal</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dest_edge_head</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="n">left_child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">left_child</span><span class="p">)</span>
            <span class="n">grand_kids</span> <span class="o">=</span> <span class="n">left_child</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">gc</span> <span class="ow">in</span> <span class="n">grand_kids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>
            <span class="n">curr_add</span> <span class="o">=</span> <span class="n">left_child</span>
        <span class="k">if</span> <span class="n">curr_add</span><span class="p">:</span>
            <span class="n">ndl</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_add</span><span class="p">]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_node_to_root_polytomy</span><span class="p">()</span>
            <span class="n">ndl</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ndl</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">()</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div style="text-align: center; padding-top: 20px; padding-bottom: 5px; width: 100%;">
    <a href="../../../../index.html"><img src="../../../../_static/dendropy_logo.png" /></a>
</div><div style="clear:both; width: 100%; height:1px;"></div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div>
    <!-- Documentation -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Documentation</h3>
        <ul>
            <li><a href="../../../../primer/downloading.html">Downloading and Installing DendroPy</a></li>
            <li><a href="../../../../primer/index.html">The DendroPy Primer</a></li>
            <li><a href="../../../../library/index.html">Library API Reference</a></li>
            <li>
                <a href="../../../../schemas/index.html">Schemas</a>
                <ul>
                    <li><a href="../../../../schemas/fasta.html">FASTA</a></li>
                    <li><a href="../../../../schemas/newick.html">Newick</a></li>
                    <li><a href="../../../../schemas/nexml.html">NeXML</a></li>
                    <li><a href="../../../../schemas/nexus.html">Nexus</a></li>
                    <li><a href="../../../../schemas/phylip.html">PHYLIP</a></li>
                </ul>
            </li>
            <li>
                <a href="../../../../programs/index.html">Programs</a>
                <ul>
                    <li><a href="../../../../programs/sumtrees.html">SumTrees</a></li>
                </ul>
            </li>
            <li><a href="../../../../glossary.html">Glossary and Terminological Reference</a></li>
            <li><a href="../../../../developer.html">Developer Guide</a></li>
            <li><a href="../../../../planning.html">Ongoing Development</a></li>
            <li><a href="../../../../changes.html">Change History</a></li>
        </ul>
    </div>

    <!-- Downloads -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Obtaining</h3>
        <ul>
            <li><a target="_blank" href="http://pypi.python.org/pypi/DendroPy">Install from the Python Package Index</a></li>
            <li><a target="_blank" href="http://pypi.python.org/packages/source/D/DendroPy/DendroPy-5.0.2.tar.gz">Download the Source Code Archive</a></li>
            <li><a target="_blank" href="http://github.com/jeetsukumaran/DendroPy">Clone the Source Code Repository</a></li>
        </ul>
    </div>

    <!-- Discussions -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Discussion</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot; DendroPy Users&quot; </a>group to follow and participate in discussion, troubleshooting, help, information, suggestions, etc. on the usage and development of the DendroPy phylogenetic computing library.</p>
            <form action="http://groups.google.com/group/dendropy-users/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot;dendropy-users&quot;</a> group, or click <a href="http://groups.google.com/group/dendropy-users?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Announcements -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Announcements</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; DendroPy Announcements&quot; </a>group to receive announcements of new releases, updates, changes and other news of interest to DendroPy users and developers.</p>
            <form action="http://groups.google.com/group/dendropy-announce/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; dendropy-announce&quot; </a>group, or click <a href="http://groups.google.com/group/dendropy-announce?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Development -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative; padding-bottom: 15px; margin-bottom:5px;">
        <h3><span style="text-align: left"><a href="https://github.com/jeetsukumaran/DendroPy/">Development</a></span><a href="https://github.com/jeetsukumaran/DendroPy/"><span style="position: absolute; right: 0; top: 10px "><img src="../../../../_static/Octocat.png" height="30px" alt="GitHub" /></span></a></h3>
        <div style="margin-top: 15px;">
            <!-- <a href="https://github.com/jeetsukumaran/DendroPy/issues">Issues</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/subscription">Watch</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/fork">Fork</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/stargazers">Star</a> &bull; <a href="https://github.com/jeetsukumaran/">Follow</a> -->
            <ul>
                <li>                <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/issues"><code>Issues</code></a></span> <span style="font-style: italic; font-size:80%;"> - Report bugs or request features</span></li>
                <li>     <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/subscription"><code>&nbsp;Watch</code></a></span> <span style="font-style: italic; font-size:80%;"> - Follow development activity</span></li>
                <li>        <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/fork"><code>&nbsp;&nbsp;Fork</code></a></span> <span style="font-style: italic; font-size:80%;"> - Contribute and collaborate</span></li>
                <li>  <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/stargazers"><code>&nbsp;&nbsp;Star</code></a></span> <span style="font-style: italic; font-size:80%;"> - Throw some glitter, add some glamour</span></li>
        </div>
    </div>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">DendroPy 5.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.datamodel.treemodel._node</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2009-2025, Jeet Sukumaran and Mark T. Holder.
    </div>
  </body>
</html>