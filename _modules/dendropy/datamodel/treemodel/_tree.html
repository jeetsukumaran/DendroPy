<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dendropy.datamodel.treemodel._tree &#8212; DendroPy 5.0.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/rtd.css?v=cedc6a2f" />
    
    <script src="../../../../_static/documentation_options.js?v=5df4c8d1"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">DendroPy 5.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.datamodel.treemodel._tree</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for dendropy.datamodel.treemodel._tree</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">terminal</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">error</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">bitprocessing</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">deprecate</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">GLOBAL_RNG</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">messaging</span>
<span class="kn">from</span> <span class="nn">dendropy.datamodel</span> <span class="kn">import</span> <span class="n">basemodel</span>
<span class="kn">from</span> <span class="nn">dendropy.datamodel</span> <span class="kn">import</span> <span class="n">taxonmodel</span>
<span class="kn">from</span> <span class="nn">dendropy.datamodel.treemodel</span> <span class="kn">import</span> <span class="n">_bipartition</span>
<span class="kn">from</span> <span class="nn">dendropy.datamodel.treemodel</span> <span class="kn">import</span> <span class="n">_node</span>
<span class="kn">from</span> <span class="nn">dendropy</span> <span class="kn">import</span> <span class="n">dataio</span>

<span class="n">_LOG</span> <span class="o">=</span> <span class="n">messaging</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="Tree">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree">[docs]</a>
<span class="k">class</span> <span class="nc">Tree</span><span class="p">(</span>
    <span class="n">taxonmodel</span><span class="o">.</span><span class="n">TaxonNamespaceAssociated</span><span class="p">,</span>
    <span class="n">basemodel</span><span class="o">.</span><span class="n">Annotable</span><span class="p">,</span>
    <span class="n">basemodel</span><span class="o">.</span><span class="n">Deserializable</span><span class="p">,</span>
    <span class="n">basemodel</span><span class="o">.</span><span class="n">NonMultiReadable</span><span class="p">,</span>
    <span class="n">basemodel</span><span class="o">.</span><span class="n">Serializable</span><span class="p">,</span>
    <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An arborescence, i.e. a fully-connected directed acyclic graph with all</span>
<span class="sd">    edges directing away from the root and toward the tips. The &quot;root&quot; of the</span>
<span class="sd">    tree is represented by the :attr:`Tree.seed_node` attribute.  In unrooted</span>
<span class="sd">    trees, this node is an algorithmic artifact. In rooted trees this node is</span>
<span class="sd">    semantically equivalent to the root.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_parse_and_create_from_stream</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">collection_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tree_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a new |Tree| object and populates it with data from</span>
<span class="sd">        file-like object ``stream``.</span>

<span class="sd">        If the source defines multiple tree collections (e.g. multiple NEXUS</span>
<span class="sd">        &quot;Trees&quot; blocks), then the ``collection_offset`` argument can be</span>
<span class="sd">        used to specify the 0-based index of the tree collection, and</span>
<span class="sd">        ``tree_offset`` argument can be used to specify the 0-based index of</span>
<span class="sd">        the tree within the collection, as the source. If ``collection_offset``</span>
<span class="sd">        is not specified or |None|, then the first collection (offset=0) is</span>
<span class="sd">        assumed. If ``tree_offset`` is not specified, then the first tree</span>
<span class="sd">        (offset=0) is returned.</span>

<span class="sd">        Keyword arguments `**kwargs` are passed directly to</span>
<span class="sd">        :meth:|TreeList|.read()`, which wraps the actual parsing.</span>

<span class="sd">        If no tree is found in the source according to the specified criteria,</span>
<span class="sd">        then |None| is returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        *All* operational taxonomic unit concepts in the data source will be included</span>
<span class="sd">        in the |TaxonNamespace| object associated with the new</span>
<span class="sd">        |TreeList| object and its contained |Tree| objects, even those</span>
<span class="sd">        not associated with tree being retrieved.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        stream : file or file-like object</span>
<span class="sd">            Source of data.</span>

<span class="sd">        schema : string</span>
<span class="sd">            Identifier of format of data in ``stream``</span>

<span class="sd">        collection_offset : integer</span>
<span class="sd">            0-based index of tree block or collection in source to be parsed.</span>

<span class="sd">        tree_offset : integer</span>
<span class="sd">            0-based index of tree in source to be parsed.  This is the 0-based</span>
<span class="sd">            index of the tree within the collection specified by</span>
<span class="sd">            ``collection_offset`` to be retrieved.</span>

<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            Arguments to customize parsing and instantiation this |Tree|</span>
<span class="sd">            from the data source, including schema- or format-specific</span>
<span class="sd">            handling. The following optional keyword arguments are recognized</span>
<span class="sd">            and handled by this constructor:</span>

<span class="sd">                ``label``</span>
<span class="sd">                    The label or description of the new |Tree| object.</span>
<span class="sd">                ``taxon_namespace``</span>
<span class="sd">                   Specifies the |TaxonNamespace| object to be attached</span>
<span class="sd">                   to the new |TreeList| object. Note that *all*</span>
<span class="sd">                   operational taxonomic unit concepts in the data source will</span>
<span class="sd">                   be accessioned into the specified |TaxonNamespace|</span>
<span class="sd">                   instance. This includes the operation taxonomic unit</span>
<span class="sd">                   definitions associated with all tree collections and</span>
<span class="sd">                   character matrices in the data source.</span>

<span class="sd">            Other keyword arguments may be available, depending on the</span>
<span class="sd">            implementation of the reader specialized to handle ``schema``</span>
<span class="sd">            formats. See documentation for details on keyword arguments</span>
<span class="sd">            supported by readers of various schemas.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Tree| or |None|</span>
<span class="sd">            The |Tree| object corresponding to the tree in the data</span>
<span class="sd">            source, or |None| if no valid tree description was found.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">dendropy.datamodel.treecollectionmodel</span> <span class="kn">import</span> <span class="n">TreeList</span>

        <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">taxonmodel</span><span class="o">.</span><span class="n">process_kwargs_dict_for_taxon_namespace</span><span class="p">(</span>
            <span class="n">kwargs</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">taxonmodel</span><span class="o">.</span><span class="n">TaxonNamespace</span><span class="p">(</span>
                <span class="n">is_case_sensitive</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;case_sensitive_taxon_labels&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">tns_factory</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">taxon_namespace</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">taxon_namespace</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
            <span class="k">return</span> <span class="n">taxon_namespace</span>

        <span class="n">tree_list_factory</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">label</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="p">:</span> <span class="n">TreeList</span><span class="p">(</span>
            <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">,</span> <span class="n">tree_type</span><span class="o">=</span><span class="bp">cls</span>
        <span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">dataio</span><span class="o">.</span><span class="n">get_reader</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># if collection_offset is None and tree_offset is not None:</span>
        <span class="c1">#     raise TypeError(&quot;Cannot specify ``tree_offset`` without specifying ``collection_offset``&quot;)</span>
        <span class="k">if</span> <span class="n">collection_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">collection_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">tree_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tree_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tree_lists</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_tree_lists</span><span class="p">(</span>
            <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span>
            <span class="n">taxon_namespace_factory</span><span class="o">=</span><span class="n">tns_factory</span><span class="p">,</span>
            <span class="n">tree_list_factory</span><span class="o">=</span><span class="n">tree_list_factory</span><span class="p">,</span>
            <span class="n">global_annotations_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tree_lists</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No trees in data source&quot;</span><span class="p">)</span>
        <span class="n">tree_list</span> <span class="o">=</span> <span class="n">tree_lists</span><span class="p">[</span><span class="n">collection_offset</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tree_list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No trees available at requested location in data source&quot;</span><span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">tree_list</span><span class="p">[</span><span class="n">tree_offset</span><span class="p">]</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="k">return</span> <span class="n">tree</span>

<div class="viewcode-block" id="Tree.get">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.get">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate and return a *new* |Tree| object from a data source.</span>

<span class="sd">        **Mandatory Source-Specification Keyword Argument (Exactly One of the Following Required):**</span>

<span class="sd">            - **file** (*file*) -- File or file-like object of data opened for reading.</span>
<span class="sd">            - **path** (*str*) -- Path to file of data.</span>
<span class="sd">            - **url** (*str*) -- URL of data.</span>
<span class="sd">            - **data** (*str*) -- Data given directly.</span>

<span class="sd">        **Mandatory Schema-Specification Keyword Argument:**</span>

<span class="sd">            - **schema** (*str*) -- Identifier of format of data given by the</span>
<span class="sd">              &quot;``file``&quot;, &quot;``path``&quot;, &quot;``data``&quot;, or &quot;``url``&quot; argument</span>
<span class="sd">              specified above: &quot;:doc:`newick &lt;/schemas/newick&gt;`&quot;, &quot;:doc:`nexus</span>
<span class="sd">              &lt;/schemas/nexus&gt;`&quot;, or &quot;:doc:`nexml &lt;/schemas/nexml&gt;`&quot;. See</span>
<span class="sd">              &quot;|Schemas|&quot; for more details.</span>

<span class="sd">        **Optional General Keyword Arguments:**</span>

<span class="sd">            - **label** (*str*) -- Name or identifier to be assigned to the new</span>
<span class="sd">              object; if not given, will be assigned the one specified in the</span>
<span class="sd">              data source, or |None| otherwise.</span>
<span class="sd">            - **taxon_namespace** (|TaxonNamespace|) -- The |TaxonNamespace|</span>
<span class="sd">              instance to use to :doc:`manage the taxon names &lt;/primer/taxa&gt;`.</span>
<span class="sd">              If not specified, a new one will be created.</span>
<span class="sd">            - **collection_offset** (*int*) -- 0-based index of tree block or</span>
<span class="sd">              collection in source to be parsed. If not specified then the</span>
<span class="sd">              first collection (offset = 0) is assumed.</span>
<span class="sd">            - **tree_offset** (*int*) -- 0-based index of tree within the</span>
<span class="sd">              collection specified by ``collection_offset`` to be parsed. If</span>
<span class="sd">              not specified, then the first tree (offset = 0) is assumed.</span>
<span class="sd">            - **ignore_unrecognized_keyword_arguments** (*bool*) -- If |True|,</span>
<span class="sd">              then unsupported or unrecognized keyword arguments will not</span>
<span class="sd">              result in an error. Default is |False|: unsupported keyword</span>
<span class="sd">              arguments will result in an error.</span>

<span class="sd">        **Optional Schema-Specific Keyword Arguments:**</span>

<span class="sd">            These provide control over how the data is interpreted and</span>
<span class="sd">            processed, and supported argument names and values depend on</span>
<span class="sd">            the schema as specified by the value passed as the &quot;``schema``&quot;</span>
<span class="sd">            argument. See &quot;|Schemas|&quot; for more details.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        ::</span>

<span class="sd">            # From a URL</span>
<span class="sd">            t1 = dendropy.Tree.get(</span>
<span class="sd">                    url=&quot;http://api.opentreeoflife.org/v2/study/pg_1144/tree/tree2324.nex&quot;,</span>
<span class="sd">                    schema=&quot;nexus&quot;)</span>

<span class="sd">            # From a file-like object</span>
<span class="sd">            t2 = Tree.get(file=open(&#39;treefile.tre&#39;, &#39;r&#39;),</span>
<span class="sd">                            schema=&quot;newick&quot;,</span>
<span class="sd">                            tree_offset=0)</span>

<span class="sd">            # From a path</span>
<span class="sd">            t3 = Tree.get(path=&#39;sometrees.nexus&#39;,</span>
<span class="sd">                    schema=&quot;nexus&quot;,</span>
<span class="sd">                    collection_offset=2,</span>
<span class="sd">                    tree_offset=1)</span>

<span class="sd">            # From a string</span>
<span class="sd">            s = &quot;((A,B),(C,D));((A,C),(B,D));&quot;</span>
<span class="sd">            # tree will be &#39;((A,B),(C,D))&#39;</span>
<span class="sd">            t4 = Tree.get(data=s,</span>
<span class="sd">                    schema=&quot;newick&quot;)</span>
<span class="sd">            # tree will be &#39;((A,C),(B,D))&#39;</span>
<span class="sd">            t5 = Tree.get(data=s,</span>
<span class="sd">                    schema=&quot;newick&quot;,</span>
<span class="sd">                    tree_offset=1)</span>
<span class="sd">            # passing keywords to underlying tree parser</span>
<span class="sd">            t7 = dendropy.Tree.get(</span>
<span class="sd">                    data=&quot;((A,B),(C,D));&quot;,</span>
<span class="sd">                    schema=&quot;newick&quot;,</span>
<span class="sd">                    taxon_namespace=t3.taxon_namespace,</span>
<span class="sd">                    suppress_internal_node_taxa=False,</span>
<span class="sd">                    preserve_underscores=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_from</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.yield_from_files">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.yield_from_files">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">yield_from_files</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates over trees from files, returning them one-by-one instead of</span>
<span class="sd">        instantiating all of them in memory at once.</span>

<span class="sd">        For operations where it is sufficient to process each tree individually</span>
<span class="sd">        (e.g., performing a calculation or set of calculations on a tree and</span>
<span class="sd">        storing the result, after the which the entire tree itself is</span>
<span class="sd">        not needed), this approach is *far* more performant that reading in the</span>
<span class="sd">        trees using a |TreeList|. This is because a full tree structure</span>
<span class="sd">        requires significant memory overhead, and as memory gets used up and</span>
<span class="sd">        the OS starts page faulting, performance starts taking some serious</span>
<span class="sd">        hits.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files : iterable of file paths or file-like objects.</span>
<span class="sd">            Iterable of sources, which can either be strings specifying file</span>
<span class="sd">            paths or file-like objects open for reading. If a source element is</span>
<span class="sd">            a string (``isinstance(i,str) == True``), then it is assumed to be</span>
<span class="sd">            a path to a file. Otherwise, the source is assumed to be a file-like</span>
<span class="sd">            object.</span>
<span class="sd">        schema : string</span>
<span class="sd">            The name of the data format (e.g., &quot;newick&quot; or &quot;nexus&quot;).</span>
<span class="sd">        taxon_namespace : |TaxonNamespace| instance</span>
<span class="sd">            The operational taxonomic unit concept namespace to use to manage</span>
<span class="sd">            taxon definitions.</span>
<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            These will be passed directly to the schema-parser implementation.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        t : |Tree|</span>
<span class="sd">            Trees as read from the file.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">            taxon_namespace = dendropy.TaxonNamespace()</span>
<span class="sd">            f1 = open(&quot;path/to/trees1.nex&quot;, &quot;r&quot;)</span>
<span class="sd">            f2 = open(&quot;path/to/trees2.nex&quot;, &quot;r&quot;)</span>
<span class="sd">            tree_yielder = dendropy.Tree.yield_from_files(</span>
<span class="sd">                    files=[f1, f2, &quot;path/to/trees3.nex&quot;, &quot;path/to/trees4.nex&quot;],</span>
<span class="sd">                    schema=&quot;nexus&quot;,</span>
<span class="sd">                    taxon_namespace=taxon_namespace,</span>
<span class="sd">                    store_tree_weights=True,</span>
<span class="sd">                    preserve_underscores=True,</span>
<span class="sd">                    rooting=&quot;default-unrooted&quot;,</span>
<span class="sd">                    ignore_unrecognized_keyword_arguments=True,</span>
<span class="sd">                    )</span>
<span class="sd">            lengths = []</span>
<span class="sd">            root_ages = []</span>
<span class="sd">            for tree in tree_yielder:</span>
<span class="sd">                length = 0.0</span>
<span class="sd">                for edge in tree:</span>
<span class="sd">                    length += edge.length</span>
<span class="sd">                lengths.append(length)</span>
<span class="sd">                tree.calc_node_ages()</span>
<span class="sd">                root_ages.append(tree.seed_node.age)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">taxonmodel</span><span class="o">.</span><span class="n">process_kwargs_dict_for_taxon_namespace</span><span class="p">(</span>
                <span class="n">kwargs</span><span class="p">,</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">taxonmodel</span><span class="o">.</span><span class="n">TaxonNamespace</span><span class="p">(</span>
                    <span class="n">is_case_sensitive</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;case_sensitive_taxon_labels&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="s2">&quot;taxon_set&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="s2">&quot;tree_offset&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;tree_offset&#39; is not supported: trees should be skipped/discarded on&quot;</span>
                <span class="s2">&quot; the client code side&quot;</span>
            <span class="p">)</span>
        <span class="n">tree_yielder</span> <span class="o">=</span> <span class="n">dataio</span><span class="o">.</span><span class="n">get_tree_yielder</span><span class="p">(</span>
            <span class="n">files</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">,</span> <span class="n">tree_type</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">tree_yielder</span></div>


<div class="viewcode-block" id="Tree.from_bipartition_encoding">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.from_bipartition_encoding">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_bipartition_encoding</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">bipartition_encoding</span><span class="p">,</span>
        <span class="n">taxon_namespace</span><span class="p">,</span>
        <span class="n">is_rooted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_lengths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstructs a tree from a bipartition encoding.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bipartition_encoding : iterable[|Bipartition|]</span>
<span class="sd">            An iterable of |Bipartition| instances representing a tree.</span>
<span class="sd">            Bipartitions will be added to the tree in the order given by</span>
<span class="sd">            iterating over this. Bipartitions that are incompatible with the</span>
<span class="sd">            tree will be skipped. So if not all bipartitions are compatible</span>
<span class="sd">            with each other, then the sequence of bipartitions given in</span>
<span class="sd">            ``bipartition_encoding`` should be in order of their support values</span>
<span class="sd">            or some other preference criteria.</span>
<span class="sd">        taxon_namespace : |TaxonNamespace| instance</span>
<span class="sd">            The operational taxonomic unit concept namespace to use to manage</span>
<span class="sd">            taxon definitions.</span>
<span class="sd">        is_rooted : bool</span>
<span class="sd">            Specifies whether or not the tree is rooted.</span>
<span class="sd">        edge_lengths : iterable or |None|</span>
<span class="sd">            An iterable of edge lengths. This should be in the same order</span>
<span class="sd">            as the bipartitions in the bipartition encoding.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Tree|</span>
<span class="sd">            The tree reconstructed from the given bipartition encoding.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">split_bitmasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">split_bitmask</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bipartition_encoding</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">edge_lengths</span><span class="p">:</span>
            <span class="n">split_edge_lengths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">split_bitmasks</span><span class="p">,</span> <span class="n">edge_lengths</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">split_edge_lengths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># elif edge_lengths is not False:</span>
        <span class="c1">#     split_edge_lengths = dict(zip(split_bitmasks,</span>
        <span class="c1">#         [b.edge.length for b in bipartition_encoding]))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_split_bitmasks</span><span class="p">(</span>
            <span class="n">split_bitmasks</span><span class="o">=</span><span class="n">split_bitmasks</span><span class="p">,</span>
            <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">,</span>
            <span class="n">split_edge_lengths</span><span class="o">=</span><span class="n">split_edge_lengths</span><span class="p">,</span>
            <span class="n">is_rooted</span><span class="o">=</span><span class="n">is_rooted</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.from_split_bitmasks">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.from_split_bitmasks">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_split_bitmasks</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">split_bitmasks</span><span class="p">,</span>
        <span class="n">taxon_namespace</span><span class="p">,</span>
        <span class="n">is_rooted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">split_edge_lengths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstructs a tree from a collection of splits represented as bitmasks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_bitmasks : iterable[int]</span>
<span class="sd">            An iterable of split bitmasks representing a tree.</span>
<span class="sd">            Splits will be added to the tree in the order given by</span>
<span class="sd">            iterating over this. Splits that are incompatible with the</span>
<span class="sd">            tree will be skipped. So if not all splits are compatible</span>
<span class="sd">            with each other, then the sequence of splits given in</span>
<span class="sd">            ``bipartition_encoding`` should be in order of their support values</span>
<span class="sd">            or some other preference criteria.</span>
<span class="sd">        taxon_namespace : |TaxonNamespace| instance</span>
<span class="sd">            The operational taxonomic unit concept namespace to use to manage</span>
<span class="sd">            taxon definitions.</span>
<span class="sd">        is_rooted : bool</span>
<span class="sd">            Specifies whether or not the tree is rooted.</span>
<span class="sd">        edge_lengths : dict or |False| or |None|</span>
<span class="sd">            If |False| or |None|, then no edge lengths will be added.</span>
<span class="sd">            Otherwise, this should be a dictionary mapping splits to edge</span>
<span class="sd">            lengths.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Tree|</span>
<span class="sd">            The tree reconstructed from the given bipartition encoding.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">leaf_to_root_search</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">reconstructed_tree</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="c1"># reconstructed_tree.is_rooted = True</span>
        <span class="n">reconstructed_tree</span><span class="o">.</span><span class="n">is_rooted</span> <span class="o">=</span> <span class="n">is_rooted</span>
        <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="n">reconstructed_tree</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">new_child</span><span class="p">(</span><span class="n">taxon</span><span class="o">=</span><span class="n">taxon</span><span class="p">)</span>
        <span class="n">all_taxa_bitmask</span> <span class="o">=</span> <span class="n">taxon_namespace</span><span class="o">.</span><span class="n">all_taxa_bitmask</span><span class="p">()</span>
        <span class="n">reconstructed_tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="n">reconstructed_tree</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">leaves</span> <span class="o">=</span> <span class="n">reconstructed_tree</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">leaf_to_root_search</span><span class="p">:</span>
            <span class="n">to_leaf_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">:</span>
                <span class="n">to_leaf_dict</span><span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_bitmask</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">reconstructed_tree</span><span class="o">.</span><span class="n">seed_node</span>
        <span class="n">root_edge</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">edge</span>

        <span class="n">split_bitmasks_to_add</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">split_bitmasks</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">s</span> <span class="o">&amp;</span> <span class="n">all_taxa_bitmask</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">all_taxa_bitmask</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">m</span>
            <span class="p">):</span>  <span class="c1"># if not root (i.e., all &quot;1&#39;s&quot;) and not singleton (i.e., one &quot;1&quot;)</span>
                <span class="k">if</span> <span class="n">is_rooted</span><span class="p">:</span>
                    <span class="n">split_bitmasks_to_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">:</span>
                        <span class="n">split_bitmasks_to_add</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="o">~</span><span class="n">m</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">all_taxa_bitmask</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># &quot;denormalize&quot; split_bitmasks</span>
                        <span class="n">split_bitmasks_to_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1"># Now when we add split_bitmasks in order, we will do a greedy, extended majority-rule consensus tree</span>
        <span class="c1"># for freq, split_to_add, split_in_dict in to_try_to_add:</span>
        <span class="n">_get_mask</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">bipartition</span><span class="p">,</span> <span class="s2">&quot;_leafset_bitmask&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">split_to_add</span> <span class="ow">in</span> <span class="n">split_bitmasks_to_add</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">split_to_add</span> <span class="o">&amp;</span> <span class="n">root_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_bitmask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">split_to_add</span><span class="p">:</span>
                <span class="c1"># incompatible</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">leaf_to_root_search</span><span class="p">:</span>
                <span class="n">lb</span> <span class="o">=</span> <span class="n">bitprocessing</span><span class="o">.</span><span class="n">least_significant_set_bit</span><span class="p">(</span><span class="n">split_to_add</span><span class="p">)</span>
                <span class="n">one_leaf</span> <span class="o">=</span> <span class="n">to_leaf_dict</span><span class="p">[</span><span class="n">lb</span><span class="p">]</span>
                <span class="n">parent_node</span> <span class="o">=</span> <span class="n">one_leaf</span>
                <span class="k">while</span> <span class="p">(</span>
                    <span class="n">split_to_add</span> <span class="o">&amp;</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_bitmask</span>
                <span class="p">)</span> <span class="o">!=</span> <span class="n">split_to_add</span><span class="p">:</span>
                    <span class="n">parent_node</span> <span class="o">=</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">parent_node</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent_node</span> <span class="o">=</span> <span class="n">reconstructed_tree</span><span class="o">.</span><span class="n">mrca</span><span class="p">(</span><span class="n">split_bitmask</span><span class="o">=</span><span class="n">split_to_add</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">parent_node</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_bitmask</span> <span class="o">==</span> <span class="n">split_to_add</span>
            <span class="p">):</span>
                <span class="k">continue</span>  <span class="c1"># split is not in tree, or already in tree.</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">node_factory</span><span class="p">()</span>
            <span class="c1"># self.map_split_support_to_node(node=new_node, split_support=freq)</span>
            <span class="n">new_node_children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">.</span><span class="n">edge</span>
            <span class="n">new_mask</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">():</span>
                <span class="c1"># might need to modify the following if rooted split_bitmasks</span>
                <span class="c1"># are used</span>
                <span class="n">cecm</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_bitmask</span>
                <span class="k">if</span> <span class="n">cecm</span> <span class="o">&amp;</span> <span class="n">split_to_add</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">cecm</span> <span class="o">!=</span> <span class="n">split_to_add</span>
                    <span class="n">new_mask</span> <span class="o">|=</span> <span class="n">cecm</span>
                    <span class="n">new_node_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">new_edge</span><span class="o">.</span><span class="n">bipartition</span> <span class="o">=</span> <span class="n">_bipartition</span><span class="o">.</span><span class="n">Bipartition</span><span class="p">(</span>
                        <span class="n">leafset_bitmask</span><span class="o">=</span><span class="n">new_mask</span><span class="p">,</span>
                        <span class="n">tree_leafset_bitmask</span><span class="o">=</span><span class="n">all_taxa_bitmask</span><span class="p">,</span>
                        <span class="n">is_mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">compile_bipartition</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">reconstructed_tree</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="p">)</span>
            <span class="c1"># Check to see if we have accumulated all of the bits that we</span>
            <span class="c1">#   needed, but none that we don&#39;t need.</span>
            <span class="k">if</span> <span class="n">new_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_bitmask</span> <span class="o">==</span> <span class="n">split_to_add</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">split_edge_lengths</span><span class="p">:</span>
                    <span class="n">new_edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">split_edge_lengths</span><span class="p">[</span><span class="n">split_to_add</span><span class="p">]</span>
                    <span class="c1"># old_split = new_old_split_map[split_to_add]</span>
                    <span class="c1"># new_edge.length = split_edge_lengths[old_split]</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">new_node_children</span><span class="p">:</span>
                    <span class="n">parent_node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">new_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="n">parent_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
                <span class="c1"># reconstructed_tree.split_edge_map[split_to_add] = new_edge</span>
        <span class="k">return</span> <span class="n">reconstructed_tree</span></div>


<div class="viewcode-block" id="Tree.node_factory">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.node_factory">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">node_factory</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns a |Node| object.</span>

<span class="sd">        Derived classes can override this method to provide support for</span>
<span class="sd">        specialized or different types of nodes on the tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            Passed directly to constructor of |Node|.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node|</span>
<span class="sd">            A new |Node| object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_node</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The constructor can optionally construct a |Tree| object by</span>
<span class="sd">        cloning another |Tree| object passed as the first positional</span>
<span class="sd">        argument, or out of a data source if ``stream`` and ``schema`` keyword</span>
<span class="sd">        arguments are passed with a file-like object and a schema-specification</span>
<span class="sd">        string object values respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        \*args : positional argument, optional</span>
<span class="sd">            If given, should be exactly one |Tree| object. The new</span>
<span class="sd">            |Tree| will then be a structural clone of this argument.</span>

<span class="sd">        \*\*kwargs : keyword arguments, optional</span>
<span class="sd">            The following optional keyword arguments are recognized</span>
<span class="sd">            and handled by this constructor:</span>

<span class="sd">                ``label``</span>
<span class="sd">                    The label or description of the new |Tree| object.</span>
<span class="sd">                ``taxon_namespace``</span>
<span class="sd">                    Specifies the |TaxonNamespace| object to be</span>
<span class="sd">                    that the new |Tree| object will reference.</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Tree objects can be instantiated in the following ways::</span>

<span class="sd">            # /usr/bin/env python</span>

<span class="sd">            try:</span>
<span class="sd">                from StringIO import StringIO</span>
<span class="sd">            except ImportError:</span>
<span class="sd">                from io import StringIO</span>
<span class="sd">            from dendropy import Tree, TaxonNamespace</span>

<span class="sd">            # empty tree</span>
<span class="sd">            t1 = Tree()</span>

<span class="sd">            # Tree objects can be instantiated from an external data source</span>
<span class="sd">            # using the &#39;get()&#39; factory class method</span>

<span class="sd">            # From a file-like object</span>
<span class="sd">            t2 = Tree.get(file=open(&#39;treefile.tre&#39;, &#39;r&#39;),</span>
<span class="sd">                            schema=&quot;newick&quot;,</span>
<span class="sd">                            tree_offset=0)</span>

<span class="sd">            # From a path</span>
<span class="sd">            t3 = Tree.get(path=&#39;sometrees.nexus&#39;,</span>
<span class="sd">                    schema=&quot;nexus&quot;,</span>
<span class="sd">                    collection_offset=2,</span>
<span class="sd">                    tree_offset=1)</span>

<span class="sd">            # From a string</span>
<span class="sd">            s = &quot;((A,B),(C,D));((A,C),(B,D));&quot;</span>
<span class="sd">            # tree will be &#39;((A,B),(C,D))&#39;</span>
<span class="sd">            t4 = Tree.get(data=s,</span>
<span class="sd">                    schema=&quot;newick&quot;)</span>
<span class="sd">            # tree will be &#39;((A,C),(B,D))&#39;</span>
<span class="sd">            t5 = Tree.get(data=s,</span>
<span class="sd">                    schema=&quot;newick&quot;,</span>
<span class="sd">                    tree_offset=1)</span>
<span class="sd">            # passing keywords to underlying tree parser</span>
<span class="sd">            t7 = dendropy.Tree.get(</span>
<span class="sd">                    data=&quot;((A,B),(C,D));&quot;,</span>
<span class="sd">                    schema=&quot;newick&quot;,</span>
<span class="sd">                    taxon_namespace=t3.taxon_namespace,</span>
<span class="sd">                    suppress_internal_node_taxa=False,</span>
<span class="sd">                    preserve_underscores=True)</span>

<span class="sd">            # Tree objects can be written out using the &#39;write()&#39; method.</span>
<span class="sd">            t1.write(file=open(&#39;treefile.tre&#39;, &#39;r&#39;),</span>
<span class="sd">                    schema=&quot;newick&quot;)</span>
<span class="sd">            t1.write(path=&#39;treefile.nex&#39;,</span>
<span class="sd">                    schema=&quot;nexus&quot;)</span>

<span class="sd">            # Or returned as a string using the &#39;as_string()&#39; method.</span>
<span class="sd">            s = t1.as_string(&quot;nexml&quot;)</span>

<span class="sd">            # tree structure deep-copied from another tree</span>
<span class="sd">            t8 = dendropy.Tree(t7)</span>
<span class="sd">            assert t8 is not t7                             # Trees are distinct</span>
<span class="sd">            assert t8.symmetric_difference(t7) == 0         # and structure is identical</span>
<span class="sd">            assert t8.taxon_namespace is t7.taxon_namespace             # BUT taxa are not cloned.</span>
<span class="sd">            nds3 = [nd for nd in t7.postorder_node_iter()]  # Nodes in the two trees</span>
<span class="sd">            nds4 = [nd for nd in t8.postorder_node_iter()]  # are distinct objects,</span>
<span class="sd">            for i, n in enumerate(nds3):                    # and can be manipulated</span>
<span class="sd">                assert nds3[i] is not nds4[i]               # independentally.</span>
<span class="sd">            egs3 = [eg for eg in t7.postorder_edge_iter()]  # Edges in the two trees</span>
<span class="sd">            egs4 = [eg for eg in t8.postorder_edge_iter()]  # are also distinct objects,</span>
<span class="sd">            for i, e in enumerate(egs3):                    # and can also be manipulated</span>
<span class="sd">                assert egs3[i] is not egs4[i]               # independentally.</span>
<span class="sd">            lves7 = t7.leaf_nodes()                         # Leaf nodes in the two trees</span>
<span class="sd">            lves8 = t8.leaf_nodes()                         # are also distinct objects,</span>
<span class="sd">            for i, lf in enumerate(lves3):                  # but order is the same,</span>
<span class="sd">                assert lves7[i] is not lves8[i]             # and associated Taxon objects</span>
<span class="sd">                assert lves7[i].taxon is lves8[i].taxon     # are the same.</span>

<span class="sd">            # To create deep copy of a tree with a different taxon namespace,</span>
<span class="sd">            # Use &#39;copy.deepcopy()&#39;</span>
<span class="sd">            t9 = copy.deepcopy(t7)</span>

<span class="sd">            # Or explicitly pass in a new TaxonNamespace instance</span>
<span class="sd">            taxa = TaxonNamespace()</span>
<span class="sd">            t9 = dendropy.Tree(t7, taxon_namespace=taxa)</span>
<span class="sd">            assert t9 is not t7                             # As above, the trees are distinct</span>
<span class="sd">            assert t9.symmetric_difference(t7) == 0         # and the structures are identical,</span>
<span class="sd">            assert t9.taxon_namespace is not t7.taxon_namespace         # but this time, the taxa *are* different</span>
<span class="sd">            assert t9.taxon_namespace is taxa                     # as the given TaxonNamespace is used instead.</span>
<span class="sd">            lves3 = t7.leaf_nodes()                         # Leaf nodes (and, for that matter other nodes</span>
<span class="sd">            lves5 = t9.leaf_nodes()                         # as well as edges) are also distinct objects</span>
<span class="sd">            for i, lf in enumerate(lves3):                  # and the order is the same, as above,</span>
<span class="sd">                assert lves7[i] is not lves9[i]             # but this time the associated Taxon</span>
<span class="sd">                assert lves7[i].taxon is not lves9[i].taxon # objects are distinct though the taxon</span>
<span class="sd">                assert lves7[i].taxon.label == lves9[i].taxon.label # labels are the same.</span>

<span class="sd">            # to &#39;switch out&#39; the TaxonNamespace of a tree, replace the reference and</span>
<span class="sd">            # reindex the taxa:</span>
<span class="sd">            t11 = Tree.get(data=&#39;((A,B),(C,D));&#39;, &#39;newick&#39;)</span>
<span class="sd">            taxa = TaxonNamespace()</span>
<span class="sd">            t11.taxon_namespace = taxa</span>
<span class="sd">            t11.reindex_subcomponent_taxa()</span>

<span class="sd">            # You can also explicitly pass in a seed node:</span>
<span class="sd">            seed = Node(label=&quot;root&quot;)</span>
<span class="sd">            t12 = Tree(seed_node=seed)</span>
<span class="sd">            assert t12.seed_node is seed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># only allow 1 positional argument</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">TooManyArgumentsError</span><span class="p">(</span>
                <span class="n">func_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">max_args</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;seed_node&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot specify &#39;seed_node&#39; if passing in a Tree object to clone&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;stream&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="s2">&quot;schema&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Constructing from an external stream is no longer supported: use&quot;</span>
                    <span class="s2">&quot; the factory method &#39;Tree.get(file=...)&#39;&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_node</span><span class="o">.</span><span class="n">Node</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Constructing a tree around a Node passed as a position argument is&quot;</span>
                    <span class="s2">&quot; no longer supported; a keyword argument is now required for this&quot;</span>
                    <span class="s2">&quot; approach: use Tree(seed_node=node)&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_clone_from</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">InvalidArgumentValueError</span><span class="p">(</span>
                    <span class="n">func_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">taxonmodel</span><span class="o">.</span><span class="n">TaxonNamespaceAssociated</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxonmodel</span><span class="o">.</span><span class="n">process_kwargs_dict_for_taxon_namespace</span><span class="p">(</span>
                    <span class="n">kwargs</span><span class="p">,</span> <span class="kc">None</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;is_rooted&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">length_type</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_seed_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_split_bitmask_edge_map</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bipartition_edge_map</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">seed_node</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;seed_node&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">seed_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_factory</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span> <span class="o">=</span> <span class="n">seed_node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_taxon_namespace</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unrecognized or unsupported arguments: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="c1">## Bipartitions</span>

    <span class="k">def</span> <span class="nf">_get_split_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;Tree.split_edges&#39; will no longer be&quot;</span>
                <span class="s2">&quot; supported in future releases; use &#39;Tree.bipartition_encoding&#39; for a&quot;</span>
                <span class="s2">&quot; list of bipartitions on the tree, or dereference the edge through the&quot;</span>
                <span class="s2">&quot; &#39;Tree.bipartition_edge_map&#39; attribute.&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span>

    <span class="k">def</span> <span class="nf">_set_split_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;Tree.split_edges&#39; will no longer be&quot;</span>
                <span class="s2">&quot; supported in future releases; use &#39;Tree.bipartition_encoding&#39; for a&quot;</span>
                <span class="s2">&quot; list of bipartitions on the tree, or dereference the edge through the&quot;</span>
                <span class="s2">&quot; &#39;Tree.bipartition_edge_map&#39; attribute.&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="o">=</span> <span class="n">m</span>

    <span class="n">split_edges</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_split_edges</span><span class="p">,</span> <span class="n">_set_split_edges</span><span class="p">)</span>

    <span class="c1">## Identity</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span>

    <span class="c1">## Copying/cloning</span>

    <span class="k">def</span> <span class="nf">_clone_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">kwargs_dict</span><span class="p">):</span>
        <span class="c1"># super(Tree, self).__init__()</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># memo[id(tree)] = self</span>
        <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">taxonmodel</span><span class="o">.</span><span class="n">process_kwargs_dict_for_taxon_namespace</span><span class="p">(</span>
            <span class="n">kwargs_dict</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="p">)</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)]</span> <span class="o">=</span> <span class="n">taxon_namespace</span>
        <span class="k">if</span> <span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t1</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="n">taxon_namespace</span><span class="o">.</span><span class="n">require_taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">t1</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
                <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">t2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t1</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
                <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">t1</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
        <span class="c1"># for k in tree.__dict__:</span>
        <span class="c1">#     if k == &quot;_annotations&quot;:</span>
        <span class="c1">#         continue</span>
        <span class="c1">#     if k in self.__dict__:</span>
        <span class="c1">#         # do not copy if already populated, perhaps by a derived class</span>
        <span class="c1">#         continue</span>
        <span class="c1">#     self.__dict__[k] = copy.deepcopy(tree.__dict__[k], memo)</span>
        <span class="c1">#     memo[id(tree.__dict__[k])] = self.__dict__[k]</span>
        <span class="c1"># self.deep_copy_annotations_from(tree)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace_scoped_copy</span><span class="p">()</span>

<div class="viewcode-block" id="Tree.taxon_namespace_scoped_copy">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.taxon_namespace_scoped_copy">[docs]</a>
    <span class="k">def</span> <span class="nf">taxon_namespace_scoped_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># this populates ``memo`` with references to the</span>
        <span class="c1"># the TaxonNamespace and Taxon objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">populate_memo_for_taxon_namespace_scoped_copy</span><span class="p">(</span><span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__deepcopy__</span><span class="p">(</span><span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># ensure clone map</span>
        <span class="k">return</span> <span class="n">basemodel</span><span class="o">.</span><span class="n">Annotable</span><span class="o">.</span><span class="n">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
        <span class="c1"># if memo is None:</span>
        <span class="c1">#     memo = {}</span>
        <span class="c1"># # get or create clone of self</span>
        <span class="c1"># try:</span>
        <span class="c1">#     other = memo[id(self)]</span>
        <span class="c1"># except KeyError:</span>
        <span class="c1">#     # create object without initialization</span>
        <span class="c1">#     other = self.__class__.__new__(self.__class__)</span>
        <span class="c1">#     # store</span>
        <span class="c1">#     memo[id(self)] = other</span>
        <span class="c1"># # copy other attributes first, skipping annotations</span>
        <span class="c1"># for k in self.__dict__:</span>
        <span class="c1">#     if k == &quot;_annotations&quot;:</span>
        <span class="c1">#         continue</span>
        <span class="c1">#     if k in other.__dict__:</span>
        <span class="c1">#         # do not copy if already populated, perhaps by a derived class</span>
        <span class="c1">#         continue</span>
        <span class="c1">#     other.__dict__[k] = copy.deepcopy(self.__dict__[k], memo)</span>
        <span class="c1">#     memo[id(self.__dict__[k])] = other.__dict__[k]</span>
        <span class="c1">#     # assert id(self.__dict__[k]) in memo</span>
        <span class="c1"># # create annotations</span>
        <span class="c1"># other.deep_copy_annotations_from(self, memo)</span>
        <span class="c1"># # return</span>
        <span class="c1"># return other</span>

<div class="viewcode-block" id="Tree.extract_tree">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.extract_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_tree</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">extraction_source_reference_attr_name</span><span class="o">=</span><span class="s2">&quot;extraction_source&quot;</span><span class="p">,</span>
        <span class="n">node_filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">is_apply_filter_to_leaf_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">is_apply_filter_to_internal_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">tree_factory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_factory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree that only includes the basic structure</span>
<span class="sd">        (nodes, edges), and minimal attributes (edge lengths, node labels, and</span>
<span class="sd">        taxon associations). Annotations, comments, and other attributes are</span>
<span class="sd">        not copied.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extraction_source_reference_attr_name : str</span>
<span class="sd">            Name of attribute to set on cloned nodes that references</span>
<span class="sd">            corresponding original node. If ``None``, then attribute (and</span>
<span class="sd">            reference) will not be created.</span>
<span class="sd">        node_filter_fn : None or function object</span>
<span class="sd">            If ``None``, then entire tree structure is cloned.</span>
<span class="sd">            If not ``None``, must be a function object that returns ``True``</span>
<span class="sd">            if a particular |Node| instance on the original tree should</span>
<span class="sd">            be included in the cloned tree, or ``False`` otherwise.</span>
<span class="sd">        suppress_unifurcations : bool</span>
<span class="sd">            If |True|, nodes of outdegree 1 will be deleted. Only will</span>
<span class="sd">            be done if some nodes are excluded from the cloned tree.</span>
<span class="sd">        is_apply_filter_to_leaf_nodes : bool</span>
<span class="sd">            If ``True`` then the above filter will be applied to leaf nodes. If</span>
<span class="sd">            ``False`` then it will not (and all leaf nodes will be</span>
<span class="sd">            automatically included, unless excluded by an ancestral node being</span>
<span class="sd">            filtered out).</span>
<span class="sd">        is_apply_filter_to_internal_nodes : bool</span>
<span class="sd">            If ``True`` then the above filter will be applied to internal nodes. If</span>
<span class="sd">            ``False`` then it will not (internal nodes without children will</span>
<span class="sd">            still be filtered out).</span>
<span class="sd">        tree_factory : function</span>
<span class="sd">            If not ``None``, must be a function that optionally takes a</span>
<span class="sd">            |TaxonNamespace| as an argument and returns a new |Tree| (or</span>
<span class="sd">            equivalent) instance.</span>
<span class="sd">        node_factory : function</span>
<span class="sd">            If not ``None``, must be a function that takes no arguments and</span>
<span class="sd">            returns a new |Node| (or equivalent) instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        A simple clone::</span>

<span class="sd">            tree0 = dendropy.Tree.get(</span>
<span class="sd">                        path=&quot;mammals.tre&quot;,</span>
<span class="sd">                        schema=&quot;newick&quot;)</span>
<span class="sd">            tree1 = tree0.extract_tree()</span>

<span class="sd">        A clone that only extracts a subtree with taxa in the genus</span>
<span class="sd">        &quot;Rhacophorus&quot;::</span>

<span class="sd">            tree0 = dendropy.Tree.get(</span>
<span class="sd">                        path=&quot;old_world_frogs.tre&quot;,</span>
<span class="sd">                        schema=&quot;newick&quot;)</span>
<span class="sd">            # Include taxa only if label starts with &quot;Rhacophorus&quot;</span>
<span class="sd">            node_filter_fn = lambda nd: nd.is_internal() or \</span>
<span class="sd">                        nd.taxon.label.startswith(&quot;Rhacophorus&quot;)</span>
<span class="sd">            tree1 = tree0.extract_tree(node_filter_fn=node_filter_fn)</span>

<span class="sd">            # Above is equivalent to, but more efficient than:</span>
<span class="sd">            #   inclusion_set = [nd.taxon for nd in tree0.leaf_node_iter()</span>
<span class="sd">            #           if nd.taxon.label.startswith(&quot;Rhacophorus)]</span>
<span class="sd">            #   tree1 = dendropy.Tree(tree0)</span>
<span class="sd">            #   tree1.retain_taxa(inclusion_set)</span>

<span class="sd">        A clone that only extracts a subtree with nodes with taxa associated</span>
<span class="sd">        with the habitat &quot;mountain&quot; or &quot;forest&quot;::</span>

<span class="sd">            tree0 = dendropy.Tree.get(</span>
<span class="sd">                        path=&quot;birds.tre&quot;,</span>
<span class="sd">                        schema=&quot;newick&quot;)</span>
<span class="sd">            include_habitats = set([&quot;mountain&quot;, &quot;forest&quot;])</span>
<span class="sd">            node_filter_fn = lambda nd: nd.taxon is None or \</span>
<span class="sd">                        nd.taxon.annotations[&quot;habitat&quot;] in include_habitats</span>
<span class="sd">            tree1 = tree0.extract_tree(node_filter_fn=node_filter_fn)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : |Tree|</span>
<span class="sd">            A new tree based on this one, with nodes filtered out if specified.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tree_factory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">tree_factory</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_factory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">node_factory</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">node_factory</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_is_rooted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span>
        <span class="n">other</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
        <span class="n">other</span><span class="o">.</span><span class="n">length_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length_type</span>
        <span class="n">other</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>
        <span class="n">other</span><span class="o">.</span><span class="n">seed_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">extract_subtree</span><span class="p">(</span>
            <span class="n">extraction_source_reference_attr_name</span><span class="o">=</span><span class="n">extraction_source_reference_attr_name</span><span class="p">,</span>
            <span class="n">node_filter_fn</span><span class="o">=</span><span class="n">node_filter_fn</span><span class="p">,</span>
            <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_leaf_nodes</span><span class="o">=</span><span class="n">is_apply_filter_to_leaf_nodes</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_internal_nodes</span><span class="o">=</span><span class="n">is_apply_filter_to_internal_nodes</span><span class="p">,</span>
            <span class="n">node_factory</span><span class="o">=</span><span class="n">node_factory</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span></div>


<div class="viewcode-block" id="Tree.extract_tree_with_taxa">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.extract_tree_with_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_tree_with_taxa</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">taxa</span><span class="p">,</span>
        <span class="n">extraction_source_reference_attr_name</span><span class="o">=</span><span class="s2">&quot;extraction_source&quot;</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree that only includes leaf nodes if they</span>
<span class="sd">        are associated with the taxon objects listed in ``taxa``. Note that</span>
<span class="sd">        this copy will be a &quot;thin&quot; copy, including just the basic structure</span>
<span class="sd">        (nodes, edges) and minimal attributes (edge lengths, node labels, and</span>
<span class="sd">        taxon associations). Annotations, comments, and other attributes are</span>
<span class="sd">        not copied.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxa : iterable of |Taxon| instances</span>
<span class="sd">            List or some other iterable of |Taxon| objects to include.</span>
<span class="sd">        suppress_unifurcations : bool</span>
<span class="sd">            If |True|, nodes of outdegree 1 will be deleted. Only will</span>
<span class="sd">            be done if some nodes are excluded from the cloned tree.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        A clone that only extracts a subtree with taxa in the genus</span>
<span class="sd">        &quot;Rhacophorus&quot;::</span>

<span class="sd">            tree0 = dendropy.Tree.get(</span>
<span class="sd">                        path=&quot;old_world_frogs.tre&quot;,</span>
<span class="sd">                        schema=&quot;newick&quot;)</span>
<span class="sd">            # Include taxa only if label starts with &quot;Rhacophorus&quot;</span>
<span class="sd">            taxa_to_retain = set([taxon for taxon in tree0.taxon_namespace</span>
<span class="sd">                    if taxon.label.startswith(&quot;Rhacophorus&quot;)])</span>
<span class="sd">            tree1 = tree0.extract_tree_with_taxa(taxa=taxa_to_retain)</span>

<span class="sd">            # Above is equivalent to, but more efficient than:</span>
<span class="sd">            #   inclusion_set = [nd.taxon for nd in tree0.leaf_node_iter()</span>
<span class="sd">            #           if nd.taxon.label.startswith(&quot;Rhacophorus)]</span>
<span class="sd">            #   tree1 = dendropy.Tree(tree0)</span>
<span class="sd">            #   tree1.retain_taxa(inclusion_set)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : |Tree|</span>
<span class="sd">            A new tree based on this one, with nodes filtered out if specified.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_filter_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">nd</span><span class="p">:</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_tree</span><span class="p">(</span>
            <span class="n">node_filter_fn</span><span class="o">=</span><span class="n">node_filter_fn</span><span class="p">,</span>
            <span class="n">extraction_source_reference_attr_name</span><span class="o">=</span><span class="n">extraction_source_reference_attr_name</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_leaf_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_internal_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.extract_tree_with_taxa_labels">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.extract_tree_with_taxa_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_tree_with_taxa_labels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">,</span>
        <span class="n">extraction_source_reference_attr_name</span><span class="o">=</span><span class="s2">&quot;extraction_source&quot;</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree that only includes leaf nodes if they are</span>
<span class="sd">        associated with taxon objects with labels matching those listed in</span>
<span class="sd">        ``labels``. Note that this copy will be a &quot;thin&quot; copy, including just</span>
<span class="sd">        the basic structure (nodes, edges) and minimal attributes (edge</span>
<span class="sd">        lengths, node labels, and taxon associations). Annotations,</span>
<span class="sd">        comments, and other attributes are not copied.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : iterable of str instances</span>
<span class="sd">            List or some other iterable of strings to match.</span>
<span class="sd">        suppress_unifurcations : bool</span>
<span class="sd">            If |True|, nodes of outdegree 1 will be deleted. Only will</span>
<span class="sd">            be done if some nodes are excluded from the cloned tree.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        A clone that only extracts a subtree with taxa in the genus</span>
<span class="sd">        &quot;Rhacophorus&quot;::</span>

<span class="sd">            tree0 = dendropy.Tree.get(</span>
<span class="sd">                        path=&quot;old_world_frogs.tre&quot;,</span>
<span class="sd">                        schema=&quot;newick&quot;)</span>
<span class="sd">            # Include taxa only if label starts with &quot;Rhacophorus&quot;</span>
<span class="sd">            labels = set([taxon.label for taxon in tree0.taxon_namespace</span>
<span class="sd">                    if taxon.label.startswith(&quot;Rhacophorus&quot;)])</span>
<span class="sd">            tree1 = tree0.extract_tree_with_taxa_labels(labels=labels)</span>

<span class="sd">            # Above is equivalent to, but more efficient than:</span>
<span class="sd">            #   inclusion_set = [nd.taxon for nd in tree0.leaf_node_iter()</span>
<span class="sd">            #           if nd.taxon.label.startswith(&quot;Rhacophorus)]</span>
<span class="sd">            #   tree1 = dendropy.Tree(tree0)</span>
<span class="sd">            #   tree1.retain_taxa(inclusion_set)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : |Tree|</span>
<span class="sd">            A new tree based on this one, with nodes filtered out if specified.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_filter_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">nd</span><span class="p">:</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_tree</span><span class="p">(</span>
            <span class="n">node_filter_fn</span><span class="o">=</span><span class="n">node_filter_fn</span><span class="p">,</span>
            <span class="n">extraction_source_reference_attr_name</span><span class="o">=</span><span class="n">extraction_source_reference_attr_name</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_leaf_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_internal_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.extract_tree_without_taxa">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.extract_tree_without_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_tree_without_taxa</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">taxa</span><span class="p">,</span>
        <span class="n">extraction_source_reference_attr_name</span><span class="o">=</span><span class="s2">&quot;extraction_source&quot;</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree that only includes leaf nodes if they</span>
<span class="sd">        are NOT associated with the taxon objects listed in ``taxa``. Note that</span>
<span class="sd">        this copy will be a &quot;thin&quot; copy, including just the basic structure</span>
<span class="sd">        (nodes, edges) and minimal attributes (edge lengths, node labels, and</span>
<span class="sd">        taxon associations). Annotations, comments, and other attributes are</span>
<span class="sd">        not copied.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxa : iterable of |Taxon| instances</span>
<span class="sd">            List or some other iterable of |Taxon| objects to exclude.</span>
<span class="sd">        suppress_unifurcations : bool</span>
<span class="sd">            If |True|, nodes of outdegree 1 will be deleted. Only will</span>
<span class="sd">            be done if some nodes are excluded from the cloned tree.</span>
<span class="sd">        is_apply_filter_to_leaf_nodes : bool</span>
<span class="sd">            If ``True`` then the above filter will be applied to leaf nodes. If</span>
<span class="sd">            ``False`` then it will not (and all leaf nodes will be</span>
<span class="sd">            automatically included, unless excluded by an ancestral node being</span>
<span class="sd">            filtered out).</span>
<span class="sd">        is_apply_filter_to_internal_nodes : bool</span>
<span class="sd">            If ``True`` then the above filter will be applied to internal nodes. If</span>
<span class="sd">            ``False`` then it will not (internal nodes without children will</span>
<span class="sd">            still be filtered out).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        A clone that only extracts a subtree with taxa NOT in the genus</span>
<span class="sd">        &quot;Rhacophorus&quot;::</span>

<span class="sd">            tree0 = dendropy.Tree.get(</span>
<span class="sd">                        path=&quot;old_world_frogs.tre&quot;,</span>
<span class="sd">                        schema=&quot;newick&quot;)</span>
<span class="sd">            # Exclude taxa if their name starts with &quot;Rhacophorus&quot;</span>
<span class="sd">            taxa_to_exclude = set([taxon for taxon in tree0.taxon_namespace</span>
<span class="sd">                    if taxon.label.startswith(&quot;Rhacophorus&quot;)])</span>
<span class="sd">            tree1 = tree0.extract_tree_with_taxa(taxa=taxa_to_retain)</span>

<span class="sd">            # Above is equivalent to, but more efficient than:</span>
<span class="sd">            #   inclusion_set = [nd.taxon for nd in tree0.leaf_node_iter()</span>
<span class="sd">            #           if nd.taxon.label.startswith(&quot;Rhacophorus)]</span>
<span class="sd">            #   tree1 = dendropy.Tree(tree0)</span>
<span class="sd">            #   tree1.retain_taxa(inclusion_set)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : |Tree|</span>
<span class="sd">            A new tree based on this one, with nodes filtered out if specified.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_filter_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">nd</span><span class="p">:</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_tree</span><span class="p">(</span>
            <span class="n">node_filter_fn</span><span class="o">=</span><span class="n">node_filter_fn</span><span class="p">,</span>
            <span class="n">extraction_source_reference_attr_name</span><span class="o">=</span><span class="n">extraction_source_reference_attr_name</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_leaf_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_internal_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.extract_tree_without_taxa_labels">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.extract_tree_without_taxa_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_tree_without_taxa_labels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">,</span>
        <span class="n">extraction_source_reference_attr_name</span><span class="o">=</span><span class="s2">&quot;extraction_source&quot;</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree that only includes leaf nodes if they</span>
<span class="sd">        are NOT associated with the taxon objects listed in ``taxa``. Note that</span>
<span class="sd">        this copy will be a &quot;thin&quot; copy, including just the basic structure</span>
<span class="sd">        (nodes, edges) and minimal attributes (edge lengths, node labels, and</span>
<span class="sd">        taxon associations). Annotations, comments, and other attributes are</span>
<span class="sd">        not copied.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : iterable of str instances</span>
<span class="sd">            List or some other iterable of strings to match.</span>
<span class="sd">        suppress_unifurcations : bool</span>
<span class="sd">            If |True|, nodes of outdegree 1 will be deleted. Only will</span>
<span class="sd">            be done if some nodes are excluded from the cloned tree.</span>
<span class="sd">        is_apply_filter_to_leaf_nodes : bool</span>
<span class="sd">            If ``True`` then the above filter will be applied to leaf nodes. If</span>
<span class="sd">            ``False`` then it will not (and all leaf nodes will be</span>
<span class="sd">            automatically included, unless excluded by an ancestral node being</span>
<span class="sd">            filtered out).</span>
<span class="sd">        is_apply_filter_to_internal_nodes : bool</span>
<span class="sd">            If ``True`` then the above filter will be applied to internal nodes. If</span>
<span class="sd">            ``False`` then it will not (internal nodes without children will</span>
<span class="sd">            still be filtered out).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        A clone that only extracts a subtree with taxa NOT in the genus</span>
<span class="sd">        &quot;Rhacophorus&quot;::</span>

<span class="sd">            tree0 = dendropy.Tree.get(</span>
<span class="sd">                        path=&quot;old_world_frogs.tre&quot;,</span>
<span class="sd">                        schema=&quot;newick&quot;)</span>
<span class="sd">            # Exclude taxa if label starts with &quot;Rhacophorus&quot;</span>
<span class="sd">            labels = set([taxon.label for taxon in tree0.taxon_namespace</span>
<span class="sd">                    if taxon.label.startswith(&quot;Rhacophorus&quot;)])</span>
<span class="sd">            tree1 = tree0.extract_tree_without_taxa_labels(labels=labels)</span>

<span class="sd">            # Above is equivalent to, but more efficient than:</span>
<span class="sd">            #   inclusion_set = [nd.taxon for nd in tree0.leaf_node_iter()</span>
<span class="sd">            #           if nd.taxon.label.startswith(&quot;Rhacophorus)]</span>
<span class="sd">            #   tree1 = dendropy.Tree(tree0)</span>
<span class="sd">            #   tree1.prune_taxa(inclusion_set)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : |Tree|</span>
<span class="sd">            A new tree based on this one, with nodes filtered out if specified.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_filter_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">nd</span><span class="p">:</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span>
            <span class="n">labels</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_tree</span><span class="p">(</span>
            <span class="n">node_filter_fn</span><span class="o">=</span><span class="n">node_filter_fn</span><span class="p">,</span>
            <span class="n">extraction_source_reference_attr_name</span><span class="o">=</span><span class="n">extraction_source_reference_attr_name</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_leaf_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_internal_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_format_and_write_to_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes out ``self`` in ``schema`` format to a destination given by</span>
<span class="sd">        file-like object ``stream``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : file or file-like object</span>
<span class="sd">            Destination for data.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Must be a recognized and tree file schema, such as &quot;nexus&quot;,</span>
<span class="sd">            &quot;newick&quot;, etc, for which a specialized tree list writer is</span>
<span class="sd">            available. If this is not implemented for the schema specified, then</span>
<span class="sd">            a UnsupportedSchemaError is raised.</span>

<span class="sd">        \*\*kwargs : keyword arguments, optional</span>
<span class="sd">            Keyword arguments will be passed directly to the writer for the</span>
<span class="sd">            specified schema. See documentation for details on keyword</span>
<span class="sd">            arguments supported by writers of various schemas.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">dendropy.datamodel.treecollectionmodel</span> <span class="kn">import</span> <span class="n">TreeList</span>

        <span class="n">tree_list</span> <span class="o">=</span> <span class="n">TreeList</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="n">tree_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon_import_strategy</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
        <span class="c1"># Go through TreeList.write() to reduce testing targets (i.e., testing</span>
        <span class="c1"># Tree.write() tests TreeList.write())</span>
        <span class="n">tree_list</span><span class="o">.</span><span class="n">write_to_stream</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># writer.write_tree_list(tree_list, stream)</span>

<div class="viewcode-block" id="Tree.nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of nodes on tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be included in</span>
<span class="sd">            the list, or |False| if not. If ``filter_fn`` is |None| (default),</span>
<span class="sd">            then all nodes visited will be included.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Node|]</span>
<span class="sd">            List of |Node| objects in the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">nodes</span></div>


<div class="viewcode-block" id="Tree.leaf_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.leaf_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">leaf_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of leaf nodes on the tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Node|]</span>
<span class="sd">            List of leaf |Node| objects in ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_node_iter</span><span class="p">()]</span></div>


<div class="viewcode-block" id="Tree.internal_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.internal_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">internal_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_seed_node</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of internal nodes in the tree.</span>

<span class="sd">        Root or seed node is included unless ``exclude_seed_node`` is |True|.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exclude_seed_node : boolean, optional</span>
<span class="sd">            If |False| (default), then the seed node or root is included. If</span>
<span class="sd">            |True|, then the seed node is omitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Node|]</span>
<span class="sd">            List of internal |Node| objects in ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">nd</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_internal_node_iter</span><span class="p">(</span>
                <span class="n">exclude_seed_node</span><span class="o">=</span><span class="n">exclude_seed_node</span>
            <span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Tree.edges">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.edges">[docs]</a>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of edges on tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Edge| object as an argument</span>
<span class="sd">            and returns |True| if the |Edge| object is to be included,</span>
<span class="sd">            or |False| if not. If ``filter_fn`` is |None| (default), then all</span>
<span class="sd">            edges will be included.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Edge|]</span>
<span class="sd">            List of |Edge| objects in ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_edge_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">edges</span></div>


<div class="viewcode-block" id="Tree.leaf_edges">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.leaf_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">leaf_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of leaf edges on the tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Edge|]</span>
<span class="sd">            List of leaf |Edge| objects in ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">edge</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_node_iter</span><span class="p">()]</span></div>


<div class="viewcode-block" id="Tree.internal_edges">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.internal_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">internal_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_seed_edge</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of internal edges on tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exclude_seed_node : boolean, optional</span>
<span class="sd">            If |False| (default), then the edge subtending the seed node or</span>
<span class="sd">            root is included. If |True|, then the seed node is omitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`list` [|Edge|]</span>
<span class="sd">            List of internal |Edge| objects in ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">edge</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_internal_node_iter</span><span class="p">(</span>
                <span class="n">exclude_seed_node</span><span class="o">=</span><span class="n">exclude_seed_edge</span>
            <span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Tree.find_node">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.find_node">[docs]</a>
    <span class="k">def</span> <span class="nf">find_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the first node for which ``filter_fn(node) == True``.</span>

<span class="sd">        For example, if::</span>

<span class="sd">            filter_fn = lambda n: hasattr(n, &#39;genes&#39;) and n.genes is not None</span>

<span class="sd">        then::</span>

<span class="sd">            node = t.find_node(filter_fn=filter_fn)</span>

<span class="sd">        will return the first node which has the attribute &#39;genes&#39; and this</span>
<span class="sd">        value is not None.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object</span>
<span class="sd">            Takes a single |Node| object as an argument and returns</span>
<span class="sd">            |True| if the node should be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node| or |None|</span>
<span class="sd">            Returns first |Node| object for which the filter function</span>
<span class="sd">            ``filter_fn`` returns |True|, or |None| if no such node exists on</span>
<span class="sd">            this tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">node</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Tree.find_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.find_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">find_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all nodes for which ``filter_fn(node) == True``.</span>

<span class="sd">        For example, if::</span>

<span class="sd">            filter_fn = lambda n: hasattr(n, &#39;genes&#39;) and n.genes is not None</span>

<span class="sd">        then::</span>

<span class="sd">            nodes = t.find_node(filter_fn=filter_fn)</span>

<span class="sd">        will return all nodes which have the attribute &#39;genes&#39; and this</span>
<span class="sd">        value is not None.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object</span>
<span class="sd">            Takes a single |Node| object as an argument and returns</span>
<span class="sd">            |True| if the node should be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes : list of |Node| instances</span>
<span class="sd">            Returns list of |Node| objects for which the filter function</span>
<span class="sd">            ``filter_fn`` returns |True|.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="p">)]</span></div>


<div class="viewcode-block" id="Tree.find_node_with_label">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.find_node_with_label">[docs]</a>
    <span class="k">def</span> <span class="nf">find_node_with_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns first node with ``label`` attribute matching ``label`` argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : string</span>
<span class="sd">            Value for ``label`` attribute of |Node| object in this tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node| or |None|</span>
<span class="sd">            Returns first |Node| object with ``label`` attribute having value</span>
<span class="sd">            given in ``label``, or |None| if no such node is found.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">label</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Tree.find_node_for_taxon">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.find_node_for_taxon">[docs]</a>
    <span class="k">def</span> <span class="nf">find_node_for_taxon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns node associated with |Taxon| object ``taxon``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxon : |Taxon| object</span>
<span class="sd">            |Taxon| object that should be associated with the node to be</span>
<span class="sd">            returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node| or |None|</span>
<span class="sd">            Returns first |Node| object with ``taxon`` attribute referencing same</span>
<span class="sd">            object as ``taxon`` argument, or |None| if no such node exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="n">taxon</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">node</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Tree.find_node_with_taxon">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.find_node_with_taxon">[docs]</a>
    <span class="k">def</span> <span class="nf">find_node_with_taxon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon_filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns node associated with |Taxon| object for which ``taxon_filter_fn``</span>
<span class="sd">        returns |True|.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxon_filter_fn : function object</span>
<span class="sd">            Takes a single |Taxon| object as an argument and returns</span>
<span class="sd">            |True| if the node associated with that |Taxon| should be</span>
<span class="sd">            returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node| or |None|</span>
<span class="sd">            Returns first |Node| object with ``taxon`` attribute passing filter</span>
<span class="sd">            function ``taxon_filter_fn``, or |None| if no such node is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;taxon&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">taxon_filter_fn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">taxon</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">node</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Tree.find_node_with_taxon_label">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.find_node_with_taxon_label">[docs]</a>
    <span class="k">def</span> <span class="nf">find_node_with_taxon_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns node associated with |Taxon| object with the specified label.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : string</span>
<span class="sd">            Label of |Taxon| object associated with the node to be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node| or |None|</span>
<span class="sd">            Returns first |Node| object with ``taxon`` attribute having label</span>
<span class="sd">            ``label``, or|None| if no such node is found.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_node_with_taxon</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span></div>

        <span class="c1"># taxon = self.taxon_namespace.get_taxon(label=label)</span>
        <span class="c1"># if taxon is None:</span>
        <span class="c1">#     return None</span>
        <span class="c1"># return self.find_node_with_taxon(lambda x: x is taxon)</span>

<div class="viewcode-block" id="Tree.mrca">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.mrca">[docs]</a>
    <span class="k">def</span> <span class="nf">mrca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns most-recent common ancestor node of a set of taxa on the tree.</span>

<span class="sd">        Returns the shallowest node in the tree (the node nearest the tips)</span>
<span class="sd">        that has all of the taxa that:</span>

<span class="sd">            * are specified by the leafset bitmask given by the keyword argument</span>
<span class="sd">              ``leafset_bitmask``</span>
<span class="sd">            * are in the list of Taxon objects given by the keyword argument</span>
<span class="sd">              ``taxa``</span>
<span class="sd">            * have the labels specified by the list of strings given by the</span>
<span class="sd">              keyword argument ``taxon_labels``</span>

<span class="sd">        Returns |None| if no appropriate node is found. Assumes that</span>
<span class="sd">        bipartitions have been encoded on the tree. It is possible that the</span>
<span class="sd">        leafset bitmask is not compatible with the subtree that is returned!</span>
<span class="sd">        (compatibility tests are not fully performed).  This function is used</span>
<span class="sd">        to find the &quot;insertion point&quot; for a new bipartition via a root to tip</span>
<span class="sd">        search.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            Exactly one of the following must be specified:</span>

<span class="sd">                ``leafset_bitmask`` : integer</span>
<span class="sd">                    Node object subtended by the first edge compatible with this</span>
<span class="sd">                    leafset bitmask will be returned.</span>
<span class="sd">                ``taxa`` : collections.Iterable [|Taxon|]</span>
<span class="sd">                    Shallowest node object with descendent nodes associated with</span>
<span class="sd">                    all the |Taxon| objects specified will be returned.</span>
<span class="sd">                ``taxon_labels`` : collections.Iterable [string]</span>
<span class="sd">                    Shallowest node object with descendent nodes associated</span>
<span class="sd">                    with the minimal set of Taxon objects that</span>
<span class="sd">                    collectively have all the labels specified in</span>
<span class="sd">                    ``taxon_labels`` will be returned.</span>

<span class="sd">            In addition, the following optional keywords are supported:</span>

<span class="sd">                ``start_node`` : |Node|, optional</span>
<span class="sd">                    If given, specifies the node at which to start searching.</span>
<span class="sd">                    If not, defaults to the root or ``seed_node``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        |Node| or |None|</span>
<span class="sd">            The most-recent common ancestor of the nodes specified, or |None|</span>
<span class="sd">            if no such node exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_rooted</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Calculating MRCA on an unrooted tree implicitly implicitly &quot;</span>
                <span class="s2">&quot;treats seed node as root. &quot;</span>
                <span class="s2">&quot;Set tree.is_rooted = True to silence this warning.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">start_node</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;start_node&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="p">)</span>
        <span class="n">leafset_bitmask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;leafset_bitmask&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">leafset_bitmask</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;leafset_bitmask&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">taxa</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;taxa&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">taxa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;taxon_labels&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">taxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">get_taxa</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;taxon_labels&quot;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;taxon_labels&quot;</span><span class="p">]):</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Not all labels matched to taxa&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Must specify one of: &#39;leafset_bitmask&#39;, &#39;taxa&#39; or&quot;</span>
                        <span class="s2">&quot; &#39;taxon_labels&#39;&quot;</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">taxa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No taxa matching criteria found&quot;</span><span class="p">)</span>
            <span class="n">leafset_bitmask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">taxa_bitmask</span><span class="p">(</span><span class="n">taxa</span><span class="o">=</span><span class="n">taxa</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">leafset_bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">leafset_bitmask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Null leafset bitmask (0)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_bitmask</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;is_bipartitions_updated&quot;</span><span class="p">,</span> <span class="kc">True</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">(</span><span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">start_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_bitmask</span> <span class="o">&amp;</span> <span class="n">leafset_bitmask</span>
        <span class="p">)</span> <span class="o">!=</span> <span class="n">leafset_bitmask</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">curr_node</span> <span class="o">=</span> <span class="n">start_node</span>
        <span class="n">last_match</span> <span class="o">=</span> <span class="n">start_node</span>
        <span class="n">nd_source</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">start_node</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">())</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">cm</span> <span class="o">=</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_bitmask</span>
                <span class="n">cms</span> <span class="o">=</span> <span class="n">cm</span> <span class="o">&amp;</span> <span class="n">leafset_bitmask</span>
                <span class="k">if</span> <span class="n">cms</span><span class="p">:</span>
                    <span class="c1"># for at least one taxon cm has 1 and bipartition has 1</span>
                    <span class="k">if</span> <span class="n">cms</span> <span class="o">==</span> <span class="n">leafset_bitmask</span><span class="p">:</span>
                        <span class="c1"># curr_node has all of the 1&#39;s that bipartition has</span>
                        <span class="k">if</span> <span class="n">cm</span> <span class="o">==</span> <span class="n">leafset_bitmask</span><span class="p">:</span>
                            <span class="c1"># step down internal unifurcations until first</span>
                            <span class="c1"># multifurcation</span>
                            <span class="k">while</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">num_child_nodes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">curr_node</span><span class="p">,</span> <span class="o">=</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
                            <span class="k">return</span> <span class="n">curr_node</span>
                        <span class="n">last_match</span> <span class="o">=</span> <span class="n">curr_node</span>
                        <span class="n">nd_source</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">curr_node</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># we have reached a child that has some, but not all of the</span>
                        <span class="c1">#   required taxa as descendants, so we return the last_match</span>
                        <span class="k">return</span> <span class="n">last_match</span>
                <span class="n">curr_node</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">nd_source</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="c1"># we shouldn&#39;t reach this if all of the descendants are properly</span>
            <span class="c1">#   decorated with leafset_bitmask attributes, but there may be some hacky</span>
            <span class="c1">#   context in which we want to allow the function to be called with</span>
            <span class="c1">#   leaves that have not been encoded with leafset_bitmasks.</span>
            <span class="k">return</span> <span class="n">last_match</span></div>


<div class="viewcode-block" id="Tree.__iter__">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.__iter__">[docs]</a>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over nodes on tree in pre-order.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; for nd in tree:</span>
<span class="sd">        ...    print(nd.label)</span>
<span class="sd">        ...</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding the internal nodes of the subtree rooted at</span>
<span class="sd">            this node in post-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tree.preorder_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.preorder_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">preorder_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-order iterator over nodes in tree.</span>

<span class="sd">        Visits nodes in ``self``, with each node visited before its children.</span>
<span class="sd">        Nodes can optionally be filtered by ``filter_fn``: only nodes for which</span>
<span class="sd">        ``filter_fn`` returns |True| when called with the node as an argument are</span>
<span class="sd">        yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding nodes in ``self`` in pre-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">preorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.preorder_internal_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.preorder_internal_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">preorder_internal_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_seed_node</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-order iterator over internal nodes in tree.</span>

<span class="sd">        Visits internal nodes in ``self``, with each node visited before its</span>
<span class="sd">        children. In DendroPy, &quot;internal nodes&quot; are nodes that have at least</span>
<span class="sd">        one child node, and thus the root or seed node is typically included</span>
<span class="sd">        unless ``exclude_seed_node`` is |True|. Nodes can optionally be filtered</span>
<span class="sd">        by ``filter_fn``: only nodes for which ``filter_fn`` returns |True| when</span>
<span class="sd">        passed the node as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>
<span class="sd">        exclude_seed_node : boolean, optional</span>
<span class="sd">            If |False| (default), then the seed node or root is visited. If</span>
<span class="sd">            |True|, then the seed node is skipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding the internal nodes of ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">preorder_internal_node_iter</span><span class="p">(</span>
            <span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">,</span> <span class="n">exclude_seed_node</span><span class="o">=</span><span class="n">exclude_seed_node</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.postorder_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.postorder_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">postorder_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-order iterator over nodes of tree.</span>

<span class="sd">        Visits self and all descendant nodes, with each node visited after its</span>
<span class="sd">        children. Nodes can optionally be filtered by ``filter_fn``: only nodes</span>
<span class="sd">        for which ``filter_fn`` returns |True| when called with the node as an</span>
<span class="sd">        argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding the nodes in ``self`` in post-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">postorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.postorder_internal_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.postorder_internal_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">postorder_internal_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_seed_node</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-order iterator over internal nodes tree.</span>

<span class="sd">        Visits internal nodes in ``self``, with each node visited after its</span>
<span class="sd">        children. In DendroPy, &quot;internal nodes&quot; are nodes that have at least</span>
<span class="sd">        one child node, and thus the root or seed node is typically included</span>
<span class="sd">        unless ``exclude_seed_node`` is |True|. Nodes can optionally be filtered</span>
<span class="sd">        by ``filter_fn``: only nodes for which ``filter_fn`` returns |True| when</span>
<span class="sd">        passed the node as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>
<span class="sd">        exclude_seed_node : boolean, optional</span>
<span class="sd">            If |False| (default), then the seed node or root is visited. If</span>
<span class="sd">            |True|, then the seed node is skipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding the internal nodes of ``self`` in post-order</span>
<span class="sd">            sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">postorder_internal_node_iter</span><span class="p">(</span>
            <span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">,</span> <span class="n">exclude_seed_node</span><span class="o">=</span><span class="n">exclude_seed_node</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.levelorder_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.levelorder_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">levelorder_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Level-order iteration over nodes of tree.</span>

<span class="sd">        Visits nodes in ``self``, with each node and other nodes at the same</span>
<span class="sd">        level (distance from root) visited before their children.  Nodes can</span>
<span class="sd">        optionally be filtered by ``filter_fn``: only nodes for which ``filter_fn``</span>
<span class="sd">        returns |True| when called with the node as an argument are visited.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding nodes of ``self`` in level-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">levelorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.level_order_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.level_order_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">level_order_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated: use :meth:`Tree.levelorder_node_iter()` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;level_order_node_iter()&#39; will no longer&quot;</span>
                <span class="s2">&quot; be supported in future releases; use &#39;levelorder_node_iter()&#39; instead&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">levelorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.inorder_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.inorder_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">inorder_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-order iteration over nodes of tree.</span>

<span class="sd">        Visits nodes in ``self``, with each node visited in-between its children.</span>
<span class="sd">        Only valid for strictly-bifurcating trees. Nodes can optionally be</span>
<span class="sd">        filtered by ``filter_fn``: only nodes for which ``filter_fn`` returns</span>
<span class="sd">        |True| when called with the node as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding nodes of ``self`` in infix or in-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">inorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.leaf_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.leaf_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">leaf_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all tips or leaves of tree.</span>

<span class="sd">        Visits all leaf or tip in ``self``. Nodes can optionally be filtered by</span>
<span class="sd">        ``filter_fn``: only nodes for which ``filter_fn`` returns |True| when</span>
<span class="sd">        called with the node as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding leaf nodes in ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">leaf_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.leaf_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.leaf_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">leaf_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated: use :meth:`Tree.leaf_node_iter()` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;leaf_iter()&#39; will no longer be supported&quot;</span>
                <span class="s2">&quot; in future releases; use &#39;leaf_node_iter()&#39; instead&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">leaf_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.ageorder_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.ageorder_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">ageorder_node_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over nodes of tree in order of the age of the node (i.e., the</span>
<span class="sd">                time since the present).</span>

<span class="sd">        Iterates over nodes in order of age (&#39;age&#39; is as given by the ``age``</span>
<span class="sd">        attribute, which is usually the sum of edge lengths from tips</span>
<span class="sd">        to node, i.e., time since present).</span>
<span class="sd">        If ``include_leaves`` is |True| (default), leaves are included in the</span>
<span class="sd">        iteration; if ``include_leaves`` is |False|, leaves will be skipped.</span>
<span class="sd">        If ``descending`` is |False| (default), younger nodes will be returned</span>
<span class="sd">        before older ones; if |True|, older nodes will be returned before</span>
<span class="sd">        younger ones.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_leaves : boolean, optional</span>
<span class="sd">            If |True| (default), then leaf nodes are included in the iteration.</span>
<span class="sd">            If |False|, then leaf nodes are skipped.</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>
<span class="sd">        descending : boolean, optional</span>
<span class="sd">            If |False| (default), then younger nodes are visited before older</span>
<span class="sd">            ones. If |True|, then older nodes are visited before younger ones.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            Iterator over age-ordered sequence of nodes of ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">age</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_node_ages</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">ageorder_iter</span><span class="p">(</span>
            <span class="n">include_leaves</span><span class="o">=</span><span class="n">include_leaves</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="n">descending</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.age_order_node_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.age_order_node_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">age_order_node_iter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">include_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated: use :meth:`Tree.ageorder_node_iter()` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;age_order_node_iter()&#39; will no longer be&quot;</span>
                <span class="s2">&quot; supported in future releases; use &#39;ageorder_node_iter()&#39; instead&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ageorder_node_iter</span><span class="p">(</span>
            <span class="n">include_leaves</span><span class="o">=</span><span class="n">include_leaves</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="n">descending</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.apply">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.apply">[docs]</a>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies function ``before_fn`` and ``after_fn`` to all internal nodes and</span>
<span class="sd">        ``leaf_fn`` to all terminal nodes in subtree starting with ``self``, with</span>
<span class="sd">        nodes visited in pre-order.</span>

<span class="sd">        Given a tree with preorder sequence of nodes of</span>
<span class="sd">        [a,b,i,e,j,k,c,g,l,m,f,n,h,o,p,]::</span>

<span class="sd">                           a</span>
<span class="sd">                          / \</span>
<span class="sd">                         /   \</span>
<span class="sd">                        /     \</span>
<span class="sd">                       /       \</span>
<span class="sd">                      /         \</span>
<span class="sd">                     /           \</span>
<span class="sd">                    /             c</span>
<span class="sd">                   b             / \</span>
<span class="sd">                  / \           /   \</span>
<span class="sd">                 /   e         /     f</span>
<span class="sd">                /   / \       /     / \</span>
<span class="sd">               /   /   \     g     /   h</span>
<span class="sd">              /   /     \   / \   /   / \</span>
<span class="sd">             i   j       k l   m n   o   p</span>


<span class="sd">        the following order of function calls results:</span>

<span class="sd">            before_fn(a)</span>
<span class="sd">            before_fn(b)</span>
<span class="sd">            leaf_fn(i)</span>
<span class="sd">            before_fn(e)</span>
<span class="sd">            leaf_fn(j)</span>
<span class="sd">            leaf_fn(k)</span>
<span class="sd">            after_fn(e)</span>
<span class="sd">            after_fn(b)</span>
<span class="sd">            before_fn(c)</span>
<span class="sd">            before_fn(g)</span>
<span class="sd">            leaf_fn(l)</span>
<span class="sd">            leaf_fn(m)</span>
<span class="sd">            after_fn(g)</span>
<span class="sd">            before_fn(f)</span>
<span class="sd">            leaf_fn(n)</span>
<span class="sd">            before_fn(h)</span>
<span class="sd">            leaf_fn(o)</span>
<span class="sd">            leaf_fn(p)</span>
<span class="sd">            after_fn(h)</span>
<span class="sd">            after_fn(f)</span>
<span class="sd">            after_fn(c)</span>
<span class="sd">            after_fn(a)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        before_fn : function object or |None|</span>
<span class="sd">            A function object that takes a |Node| as its argument.</span>
<span class="sd">        after_fn : function object or |None|</span>
<span class="sd">            A function object that takes a |Node| as its argument.</span>
<span class="sd">        leaf_fn : function object or |None|</span>
<span class="sd">            A function object that takes a |Node| as its argument.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Adapted from work by Mark T. Holder (the ``peyotl`` module of the Open</span>
<span class="sd">        Tree of Life Project):</span>

<span class="sd">            https://github.com/OpenTreeOfLife/peyotl.git</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">before_fn</span><span class="p">,</span> <span class="n">after_fn</span><span class="p">,</span> <span class="n">leaf_fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.preorder_edge_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.preorder_edge_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">preorder_edge_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-order iterator over nodes in tree.</span>

<span class="sd">        Visits nodes in ``self``, with each node visited before its children.</span>
<span class="sd">        Nodes can optionally be filtered by ``filter_fn``: only nodes for which</span>
<span class="sd">        ``filter_fn`` returns |True| when called with the node as an argument are</span>
<span class="sd">        yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Node| object as an argument</span>
<span class="sd">            and returns |True| if the |Node| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all nodes visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Node|]</span>
<span class="sd">            An iterator yielding nodes in ``self`` in pre-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: from-scratch implementation here instead of wrapping</span>
        <span class="c1"># `preorder_node_iter()`for efficiency</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">_edge</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">edge</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">_edge</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">_head_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">))</span></div>


<div class="viewcode-block" id="Tree.preorder_internal_edge_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.preorder_internal_edge_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">preorder_internal_edge_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_seed_edge</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-order iterator over internal edges in tree.</span>

<span class="sd">        Visits internal edges in ``self``, with each edge visited before its</span>
<span class="sd">        children. In DendroPy, &quot;internal edges&quot; are edges that have at least</span>
<span class="sd">        one child edge, and thus the root or seed edge is typically included</span>
<span class="sd">        unless ``exclude_seed_edge`` is |True|. Edges can optionally be filtered</span>
<span class="sd">        by ``filter_fn``: only edges for which ``filter_fn`` returns |True| when</span>
<span class="sd">        passed the edge as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Edge| object as an argument</span>
<span class="sd">            and returns |True| if the |Edge| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all edges visited will be yielded.</span>
<span class="sd">        exclude_seed_edge : boolean, optional</span>
<span class="sd">            If |False| (default), then the edge subtending the seed node or</span>
<span class="sd">            root is visited. If |True|, then this edge is skipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Edge|]</span>
<span class="sd">            An iterator yielding the internal edges of ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: from-scratch implementation here instead of wrapping</span>
        <span class="c1"># `preorder_internal_node_iter()`for efficiency</span>
        <span class="k">if</span> <span class="n">exclude_seed_edge</span><span class="p">:</span>
            <span class="n">froot</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">_head_node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">froot</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">filter_fn</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">froot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">_head_node</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="ow">and</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="ow">or</span> <span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="ow">and</span> <span class="n">froot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">_head_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_edge_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">f</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.postorder_edge_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.postorder_edge_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">postorder_edge_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-order iterator over edges of tree.</span>

<span class="sd">        Visits edges in ``self``, with each edge visited after its children.</span>
<span class="sd">        Edges can optionally be filtered by ``filter_fn``: only edges for which</span>
<span class="sd">        ``filter_fn`` returns |True| when called with the edge as an argument</span>
<span class="sd">        are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Edge| object as an argument</span>
<span class="sd">            and returns |True| if the |Edge| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all edges visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Edge|]</span>
<span class="sd">            An iterator yielding the edges in ``self`` in post-order sequence.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: custom implementation here instead of wrapping</span>
        <span class="c1"># `postorder_node_iter()`for efficiency</span>

        <span class="c1"># stack = [(self.seed_node._edge, False)]</span>
        <span class="c1"># while stack:</span>
        <span class="c1">#     edge, state = stack.pop(0)</span>
        <span class="c1">#     if state:</span>
        <span class="c1">#         if filter_fn is None or filter_fn(edge):</span>
        <span class="c1">#             yield edge</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         stack.insert(0, (edge, True))</span>
        <span class="c1">#         child_edges = [(n._edge, False) for n in edge._head_node._child_nodes]</span>
        <span class="c1">#         child_edges.extend(stack)</span>
        <span class="c1">#         stack = child_edges</span>

        <span class="c1">## Prefer `pop()` to `pop(0)`.</span>
        <span class="c1">## Thanks to Mark T. Holder</span>
        <span class="c1">## From peyotl commits: d1ffef2 + 19fdea1</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">_edge</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">edge</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">state</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">edge</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">edge</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">n</span><span class="o">.</span><span class="n">_edge</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">_head_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)]</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.postorder_internal_edge_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.postorder_internal_edge_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">postorder_internal_edge_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_seed_edge</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-order iterator over internal edges tree.</span>

<span class="sd">        Visits internal edges in ``self``, with each edge visited after its</span>
<span class="sd">        children. In DendroPy, &quot;internal edges&quot; are edges that have at least</span>
<span class="sd">        one child edge, and thus the root or seed edge is typically included</span>
<span class="sd">        unless ``exclude_seed_edge`` is |True|. Edges can optionally be filtered</span>
<span class="sd">        by ``filter_fn``: only edges for which ``filter_fn`` returns |True| when</span>
<span class="sd">        passed the edge as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Edge| object as an argument</span>
<span class="sd">            and returns |True| if the |Edge| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all edges visited will be yielded.</span>
<span class="sd">        exclude_seed_edge : boolean, optional</span>
<span class="sd">            If |False| (default), then the seed edge or root is visited. If</span>
<span class="sd">            |True|, then the seed edge is skipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Edge|]</span>
<span class="sd">            An iterator yielding the internal edges of ``self`` in post-order</span>
<span class="sd">            sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: from-scratch implementation here instead of wrapping</span>
        <span class="c1"># `preorder_internal_node_iter()`for efficiency</span>
        <span class="k">if</span> <span class="n">exclude_seed_edge</span><span class="p">:</span>
            <span class="n">froot</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">_head_node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">froot</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">filter_fn</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">froot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">_head_node</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="ow">and</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="ow">or</span> <span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="ow">and</span> <span class="n">froot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">_head_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_edge_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">f</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.levelorder_edge_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.levelorder_edge_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">levelorder_edge_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Level-order iteration over edges of tree.</span>

<span class="sd">        Visits edges in ``self``, with each edge and other edges at the same</span>
<span class="sd">        level (distance from root) visited before their children.  Edges can</span>
<span class="sd">        optionally be filtered by ``filter_fn``: only edges for which ``filter_fn``</span>
<span class="sd">        returns |True| when called with the edge as an argument are visited.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Edge| object as an argument</span>
<span class="sd">            and returns |True| if the |Edge| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all edges visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Edge|]</span>
<span class="sd">            An iterator yielding edges of ``self`` in level-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">levelorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">f</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span></div>


<div class="viewcode-block" id="Tree.level_order_edge_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.level_order_edge_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">level_order_edge_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated: use :meth:`Tree.levelorder_edge_iter()` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;level_order_edge_iter()&#39; will no longer&quot;</span>
                <span class="s2">&quot; be supported in future releases; use &#39;levelorder_edge_iter()&#39; instead&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">levelorder_edge_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">filter_fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.inorder_edge_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.inorder_edge_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">inorder_edge_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-order iteration over edges of tree.</span>

<span class="sd">        Visits edges in ``self``, with each edge visited in-between its children.</span>
<span class="sd">        Only valid for strictly-bifurcating trees. Edges can optionally be</span>
<span class="sd">        filtered by ``filter_fn``: only edges for which ``filter_fn`` returns</span>
<span class="sd">        |True| when called with the edge as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Edge| object as an argument</span>
<span class="sd">            and returns |True| if the |Edge| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all edges visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Edge|]</span>
<span class="sd">            An iterator yielding edges of ``self`` in infix or in-order sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">inorder_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">f</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span></div>


<div class="viewcode-block" id="Tree.leaf_edge_iter">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.leaf_edge_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">leaf_edge_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all tips or leaves of tree.</span>

<span class="sd">        Visits all leaf or tip in ``self``. Edges can optionally be filtered by</span>
<span class="sd">        ``filter_fn``: only edges for which ``filter_fn`` returns |True| when</span>
<span class="sd">        called with the edge as an argument are yielded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_fn : function object, optional</span>
<span class="sd">            A function object that takes a |Edge| object as an argument</span>
<span class="sd">            and returns |True| if the |Edge| object is to be yielded by</span>
<span class="sd">            the iterator, or |False| if not. If ``filter_fn`` is |None|</span>
<span class="sd">            (default), then all edges visited will be yielded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`collections.Iterator` [|Edge|]</span>
<span class="sd">            An iterator yielding leaf edges in ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">leaf_iter</span><span class="p">(</span><span class="n">filter_fn</span><span class="o">=</span><span class="n">f</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span></div>


<div class="viewcode-block" id="Tree.reconstruct_taxon_namespace">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.reconstruct_taxon_namespace">[docs]</a>
    <span class="k">def</span> <span class="nf">reconstruct_taxon_namespace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">unify_taxa_by_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">taxon_mapping_memo</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">taxon_mapping_memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">taxon_mapping_memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">unify_taxa_by_label</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
            <span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">taxon_mapping_memo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">taxon</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># taxon to use not given and</span>
                    <span class="c1"># we have not yet created a counterpart</span>
                    <span class="k">if</span> <span class="n">unify_taxa_by_label</span><span class="p">:</span>
                        <span class="c1"># this will force usage of any taxon with</span>
                        <span class="c1"># a label that matches the current taxon</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">require_taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># this will unconditionally create a new taxon</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">new_taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
                    <span class="n">taxon_mapping_memo</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">taxon</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># taxon to use is given by mapping</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">add_taxon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">node</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="n">t</span></div>


<div class="viewcode-block" id="Tree.update_taxon_namespace">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.update_taxon_namespace">[docs]</a>
    <span class="k">def</span> <span class="nf">update_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All |Taxon| objects in ``self`` that are not in</span>
<span class="sd">        ``self.taxon_namespace`` will be added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">add_taxon</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">taxon</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span></div>


<div class="viewcode-block" id="Tree.poll_taxa">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.poll_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">poll_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxa</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a set populated with all of |Taxon| instances associated</span>
<span class="sd">        with ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxa : set()</span>
<span class="sd">            Set to populate. If not specified, a new one will be created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set[|Taxon|]</span>
<span class="sd">            Set of taxa associated with ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">taxa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">taxa</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">taxa</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">taxon</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">taxa</span></div>


<div class="viewcode-block" id="Tree.infer_taxa">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.infer_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">infer_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates (and returns) a new TaxonNamespace object for ``self`` populated</span>
<span class="sd">        with taxa from this tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;infer_taxa()&#39; will no longer be&quot;</span>
                <span class="s2">&quot; supported in future releases; use &#39;update_taxon_namespace()&#39; instead&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">taxonmodel</span><span class="o">.</span><span class="n">TaxonNamespace</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">taxon_namespace</span><span class="o">.</span><span class="n">add_taxon</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">taxon</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">taxon_namespace</span>
        <span class="k">return</span> <span class="n">taxon_namespace</span></div>


<div class="viewcode-block" id="Tree.reindex_subcomponent_taxa">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.reindex_subcomponent_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">reindex_subcomponent_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remaps node taxon objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;reindex_subcomponent_taxa()&#39; will no&quot;</span>
                <span class="s2">&quot; longer be supported in future releases; use&quot;</span>
                <span class="s2">&quot; &#39;reconstruct_taxon_namespace()&#39; instead&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">taxon</span>
            <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">require_taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">label</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.unassign_taxa">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.unassign_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">unassign_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_leaves</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude_internal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Strips taxon assignments from tree. If ``exclude_leaves`` is True,</span>
<span class="sd">        then taxa on leaves will be retained. If ``exclude_internal`` is True,</span>
<span class="sd">        then taxa on internal nodes will be retained. The ``taxon_namespace`` is not</span>
<span class="sd">        affected by this operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">exclude_leaves</span><span class="p">:</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">exclude_internal</span><span class="p">:</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Tree.randomly_assign_taxa">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.randomly_assign_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">randomly_assign_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">create_required_taxa</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly assigns taxa to leaf nodes. If the number of taxa defined in</span>
<span class="sd">        the taxon set of the tree is more than the number of tips, then a random</span>
<span class="sd">        subset of taxa in ``taxon_namespace`` will be assigned to the tips of tree.</span>
<span class="sd">        If the number of tips is more than the number of taxa in the ``taxon_namespace``,</span>
<span class="sd">        and ``add_extra_taxa`` is not True [default], then new Taxon</span>
<span class="sd">        objects will be created and added to the ``taxon_namespace``; if ``create_required_taxa``</span>
<span class="sd">        is False, then an exception is raised.</span>

<span class="sd">        In addition, a Random() object or equivalent can be passed using ``rng``;</span>
<span class="sd">        otherwise GLOBAL_RNG is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">()):</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">require_taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;T</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">taxa</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">()):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="n">taxa</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">create_required_taxa</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;TaxonNamespace has </span><span class="si">%d</span><span class="s2"> taxa, but tree has </span><span class="si">%d</span><span class="s2"> tips&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">()))</span>
                        <span class="p">)</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;T</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">has_taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">):</span>
                        <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;T</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
                        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">require_taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_is_rootedness_undefined</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="n">is_rootedness_undefined</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_rootedness_undefined</span><span class="p">)</span>
    <span class="c1"># legacy:</span>
    <span class="n">rooting_state_is_undefined</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_rootedness_undefined</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_is_rooted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span>

    <span class="k">def</span> <span class="nf">_set_is_rooted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span> <span class="o">=</span> <span class="n">val</span>

    <span class="n">is_rooted</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_rooted</span><span class="p">,</span> <span class="n">_set_is_rooted</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_is_unrooted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_is_unrooted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">val</span>

    <span class="n">is_unrooted</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_unrooted</span><span class="p">,</span> <span class="n">_set_is_unrooted</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.collapse_basal_bifurcation">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.collapse_basal_bifurcation">[docs]</a>
    <span class="k">def</span> <span class="nf">collapse_basal_bifurcation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_as_unrooted_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="s2">&quot;Converts a degree-2 node at the root to a degree-3 node.&quot;</span>
        <span class="n">seed_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">seed_node</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">child_nodes</span> <span class="o">=</span> <span class="n">seed_node</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">to_keep</span><span class="p">,</span> <span class="n">to_del</span> <span class="o">=</span> <span class="n">child_nodes</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">to_del</span><span class="p">,</span> <span class="n">to_keep</span> <span class="o">=</span> <span class="n">child_nodes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">to_del_edge</span> <span class="o">=</span> <span class="n">to_del</span><span class="o">.</span><span class="n">edge</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">to_keep</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="n">to_del_edge</span><span class="o">.</span><span class="n">length</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># print to_keep.edge.length, to_del_edge.length, [id(c) for c in to_del_edge.head_node.child_nodes()]</span>
        <span class="n">to_del_edge</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="n">adjust_collapsed_head_children_edge_lengths</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set_as_unrooted_tree</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_rooted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span></div>


    <span class="k">def</span> <span class="nf">_get_seed_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seed_node</span>

    <span class="k">def</span> <span class="nf">_set_seed_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seed_node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seed_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;New seed_node has parent_node. The new seed_node and all &quot;</span>
                    <span class="s2">&quot;descendants will be spliced out of their current context &quot;</span>
                    <span class="s2">&quot;into this Tree. If this is not the desired behavior, pass &quot;</span>
                    <span class="s2">&quot;node.extract_subtree() instead of node. Otherwise, to &quot;</span>
                    <span class="s2">&quot;suppress this warning set node.parent_node = None before &quot;</span>
                    <span class="s2">&quot;passing as new seed_node.&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_seed_node</span><span class="o">.</span><span class="n">parent_node</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">seed_node</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_seed_node</span><span class="p">,</span> <span class="n">_set_seed_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deroot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapse_basal_bifurcation</span><span class="p">(</span><span class="n">set_as_unrooted_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.reseed_at">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.reseed_at">[docs]</a>
    <span class="k">def</span> <span class="nf">reseed_at</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_seed_node</span><span class="p">,</span>
        <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">collapse_unrooted_basal_bifurcation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reseeds the tree at a different (existing) node.</span>

<span class="sd">        Takes an internal node, ``new_seed_node`` that must already be in the</span>
<span class="sd">        tree and rotates the tree such that ``new_seed_node`` is the ``seed_node``</span>
<span class="sd">        of the tree. This is a &#39;soft&#39; rerooting -- i.e., changes the tree</span>
<span class="sd">        representation so tree traversal behaves as if the tree is rooted at</span>
<span class="sd">        &#39;new_seed_node&#39;, but it does not actually change the tree&#39;s rooting</span>
<span class="sd">        state.  If ``update_bipartitions`` is True, then the edges&#39;</span>
<span class="sd">        ``bipartition_bitmask`` and the tree&#39;s ``bipartition_edge_map`` attributes</span>
<span class="sd">        will be updated. If the *old* root of the tree had an outdegree of 2,</span>
<span class="sd">        then after this operation, it will have an outdegree of one. In this</span>
<span class="sd">        case, unless ``suppress_unifurcations`` is False, then it will be removed</span>
<span class="sd">        from the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># def _dump_node(nd, name):</span>
        <span class="c1">#     print(&quot;- {}: {}&quot;.format(name, nd.label))</span>
        <span class="c1">#     if nd._parent_node:</span>
        <span class="c1">#         print(&quot;    Node Parent: {}&quot;.format(nd._parent_node.label))</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         print(&quot;    Node Parent: None&quot;)</span>
        <span class="c1">#     if nd._edge.tail_node:</span>
        <span class="c1">#         print(&quot;    Edge Parent: {}&quot;.format(nd._edge.tail_node.label))</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         print(&quot;    Edge Parent: None&quot;)</span>
        <span class="c1">#     debug_children = []</span>
        <span class="c1">#     for ch in nd._child_nodes:</span>
        <span class="c1">#         parts = []</span>
        <span class="c1">#         if ch._parent_node:</span>
        <span class="c1">#             parts.append(ch._parent_node.label)</span>
        <span class="c1">#         else:</span>
        <span class="c1">#             parts.append(&quot;None&quot;)</span>
        <span class="c1">#         if ch.edge.tail_node:</span>
        <span class="c1">#             parts.append(ch.edge.tail_node.label)</span>
        <span class="c1">#         else:</span>
        <span class="c1">#             parts.append(&quot;None&quot;)</span>
        <span class="c1">#         debug_children.append(&quot;{} ({})&quot;.format(ch.label, &quot;/&quot;.join(parts)))</span>
        <span class="c1">#     debug_children = &quot;, &quot;.join(debug_children)</span>
        <span class="c1">#     print(&quot;    Children (Node Parent, Edge Tail Node Parent): {}&quot;.format(debug_children))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span> <span class="ow">is</span> <span class="n">new_seed_node</span><span class="p">:</span>
            <span class="c1"># do not just return: allow for updating of bipartitions,</span>
            <span class="c1"># collapsing of unifurcations, collapsing of unrooted basal</span>
            <span class="c1"># bifurcations</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">old_seed_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span>
            <span class="n">old_parent_node</span> <span class="o">=</span> <span class="n">new_seed_node</span><span class="o">.</span><span class="n">_parent_node</span>
            <span class="k">if</span> <span class="n">old_parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">new_seed_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
                <span class="n">new_seed_node_is_leaf</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_seed_node_is_leaf</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">edges_to_invert</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">current_node</span> <span class="o">=</span> <span class="n">new_seed_node</span>
            <span class="k">while</span> <span class="n">current_node</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">current_node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">edges_to_invert</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_node</span><span class="o">.</span><span class="n">edge</span><span class="p">)</span>
                <span class="n">current_node</span> <span class="o">=</span> <span class="n">current_node</span><span class="o">.</span><span class="n">_parent_node</span>
            <span class="k">while</span> <span class="n">edges_to_invert</span><span class="p">:</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">edges_to_invert</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">update_bipartitions</span><span class="o">=</span><span class="n">update_bipartitions</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">new_seed_node_is_leaf</span> <span class="ow">and</span> <span class="n">suppress_unifurcations</span><span class="p">:</span>
                <span class="c1">## Cannot just suppress_unifurcations, because wrong node will be deleted</span>
                <span class="c1">## need to remove child (i.e. new seed node&#39;s old parent, which is now its child, needs to be deleted)</span>
                <span class="c1"># self.suppress_unifurcations(update_bipartitions=update_bipartitions)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_seed_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">nsn_ch</span> <span class="o">=</span> <span class="n">new_seed_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">new_seed_node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">nsn_ch</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">nsn_ch</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
                        <span class="n">new_seed_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_seed_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># uncouple before splicing</span>
                <span class="n">new_seed_node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span> <span class="o">=</span> <span class="n">new_seed_node</span>

        <span class="k">if</span> <span class="n">update_bipartitions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">(</span>
                <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
                <span class="n">collapse_unrooted_basal_bifurcation</span><span class="o">=</span><span class="n">collapse_unrooted_basal_bifurcation</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">collapse_unrooted_basal_bifurcation</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collapse_basal_bifurcation</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">suppress_unifurcations</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">suppress_unifurcations</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span></div>


<div class="viewcode-block" id="Tree.to_outgroup_position">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.to_outgroup_position">[docs]</a>
    <span class="k">def</span> <span class="nf">to_outgroup_position</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">outgroup_node</span><span class="p">,</span> <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reroots the tree at the parent of ``outgroup_node`` and makes ``outgroup_node`` the first child</span>
<span class="sd">        of the new root.  This is just a convenience function to make it easy</span>
<span class="sd">        to place a clade as the first child under the root.</span>
<span class="sd">        Assumes that ``outgroup_node`` and ``outgroup_node._parent_node`` and are in the tree/</span>
<span class="sd">        If ``update_bipartitions`` is True, then the edges&#39; ``bipartition`` and the tree&#39;s</span>
<span class="sd">        ``bipartition_encoding`` attributes will be updated.</span>
<span class="sd">        If the *old* root of the tree had an outdegree of 2, then after this</span>
<span class="sd">        operation, it will have an outdegree of one. In this case, unless</span>
<span class="sd">        ``suppress_unifurcations`` is False, then it will be</span>
<span class="sd">        removed from the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">outgroup_node</span><span class="o">.</span><span class="n">_parent_node</span>
        <span class="k">assert</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reseed_at</span><span class="p">(</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">update_bipartitions</span><span class="o">=</span><span class="n">update_bipartitions</span><span class="p">,</span>
            <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">outgroup_node</span><span class="p">)</span>
        <span class="n">_ognlen</span> <span class="o">=</span> <span class="n">outgroup_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
        <span class="n">p</span><span class="o">.</span><span class="n">insert_child</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">outgroup_node</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">outgroup_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">_ognlen</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span></div>


<div class="viewcode-block" id="Tree.reroot_at_node">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.reroot_at_node">[docs]</a>
    <span class="k">def</span> <span class="nf">reroot_at_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_root_node</span><span class="p">,</span>
        <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">collapse_unrooted_basal_bifurcation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes an internal node, ``new_seed_node`` that must already be in the tree and</span>
<span class="sd">        roots the tree at that node.</span>
<span class="sd">        This is a &#39;hard&#39; rerooting -- i.e., changes the tree</span>
<span class="sd">        representation so tree traversal behaves as if the tree is rooted at</span>
<span class="sd">        &#39;new_seed_node&#39;, *and* changes the tree&#39;s rooting state.</span>
<span class="sd">        If ``update_bipartitions`` is True, then the edges&#39; ``bipartition`` and the tree&#39;s</span>
<span class="sd">        ``bipartition_encoding`` attributes will be updated.</span>
<span class="sd">        If the *old* root of the tree had an outdegree of 2, then after this</span>
<span class="sd">        operation, it will have an outdegree of one. In this case, unless</span>
<span class="sd">        ``suppress_unifurcations`` is False, then it will be</span>
<span class="sd">        removed from the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reseed_at</span><span class="p">(</span>
            <span class="n">new_seed_node</span><span class="o">=</span><span class="n">new_root_node</span><span class="p">,</span>
            <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
            <span class="n">collapse_unrooted_basal_bifurcation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_rooted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">update_bipartitions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_bipartitions</span><span class="p">(</span>
                <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
                <span class="n">collapse_unrooted_basal_bifurcation</span><span class="o">=</span><span class="n">collapse_unrooted_basal_bifurcation</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span></div>


<div class="viewcode-block" id="Tree.reroot_at_edge">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.reroot_at_edge">[docs]</a>
    <span class="k">def</span> <span class="nf">reroot_at_edge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">edge</span><span class="p">,</span>
        <span class="n">length1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">length2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes an internal edge, ``edge``, adds a new node to it, and then roots</span>
<span class="sd">        the tree on the new node.</span>
<span class="sd">        ``length1`` will be assigned to the new (sub-)edge leading</span>
<span class="sd">        to the original parent of the original edge.</span>
<span class="sd">        ``length2`` will be assigned to the new (sub-)edge leading to the original</span>
<span class="sd">        child of the original edge.</span>
<span class="sd">        If ``update_bipartitions`` is True, then the edges&#39; ``bipartition`` and the tree&#39;s</span>
<span class="sd">        ``bipartition_encoding`` attributes will be updated.</span>
<span class="sd">        If the *old* root of the tree had an outdegree of 2, then after this</span>
<span class="sd">        operation, it will have an outdegree of one. In this case, unless</span>
<span class="sd">        ``suppress_unifurcations`` is False, then it will be</span>
<span class="sd">        removed from the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_tail</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span>
        <span class="n">old_head</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">head_node</span>
        <span class="n">new_seed_node</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">.</span><span class="n">new_child</span><span class="p">(</span><span class="n">edge_length</span><span class="o">=</span><span class="n">length1</span><span class="p">)</span>
        <span class="n">old_tail</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">old_head</span><span class="p">)</span>
        <span class="c1"># new_seed_node.add_child(old_head, edge_length=length2)</span>
        <span class="n">new_seed_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">old_head</span><span class="p">)</span>
        <span class="n">old_head</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reroot_at_node</span><span class="p">(</span>
            <span class="n">new_seed_node</span><span class="p">,</span>
            <span class="n">update_bipartitions</span><span class="o">=</span><span class="n">update_bipartitions</span><span class="p">,</span>
            <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span></div>


<div class="viewcode-block" id="Tree.reroot_at_midpoint">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.reroot_at_midpoint">[docs]</a>
    <span class="k">def</span> <span class="nf">reroot_at_midpoint</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">collapse_unrooted_basal_bifurcation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reroots the tree at the the mid-point of the longest distance between</span>
<span class="sd">        two taxa in a tree.</span>
<span class="sd">        Sets the rooted flag on the tree to True.</span>
<span class="sd">        If ``update_bipartitions`` is True, then the edges&#39; ``bipartition`` and the tree&#39;s</span>
<span class="sd">        ``bipartition_encoding`` attributes will be updated.</span>
<span class="sd">        If the *old* root of the tree had an outdegree of 2, then after this</span>
<span class="sd">        operation, it will have an outdegree of one. In this case, unless</span>
<span class="sd">        ``suppress_unifurcations`` is False, then it will be</span>
<span class="sd">        removed from the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate.phylogeneticdistance</span> <span class="kn">import</span> <span class="n">PhylogeneticDistanceMatrix</span>

        <span class="n">pdm</span> <span class="o">=</span> <span class="n">PhylogeneticDistanceMatrix</span><span class="o">.</span><span class="n">from_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1">## ugly, ugly, ugly code to find two nodes that span the midpoint</span>
        <span class="n">maxtax1</span><span class="p">,</span> <span class="n">maxtax2</span> <span class="o">=</span> <span class="n">pdm</span><span class="o">.</span><span class="n">max_pairwise_distance_taxa</span><span class="p">()</span>
        <span class="n">spanning_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_node_iter</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">tax</span> <span class="ow">in</span> <span class="p">(</span><span class="n">maxtax1</span><span class="p">,</span> <span class="n">maxtax2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="n">tax</span><span class="p">:</span>
                    <span class="n">spanning_nodes</span><span class="p">[</span><span class="n">found</span><span class="p">]</span> <span class="o">=</span> <span class="n">nd</span>
                    <span class="n">found</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">found</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">spanning_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">distance_from_root</span><span class="p">()</span>
            <span class="o">&lt;</span> <span class="n">spanning_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">distance_from_root</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">spanning_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">spanning_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">spanning_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">spanning_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">plen</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pdm</span><span class="o">.</span><span class="n">patristic_distance</span><span class="p">(</span><span class="n">maxtax1</span><span class="p">,</span> <span class="n">maxtax2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">mrca_node</span> <span class="o">=</span> <span class="n">pdm</span><span class="o">.</span><span class="n">mrca</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">taxon</span><span class="p">,</span> <span class="n">n2</span><span class="o">.</span><span class="n">taxon</span><span class="p">)</span>
        <span class="c1"># assert mrca_node is self.mrca(taxa=[n1.taxon, n2.taxon])</span>
        <span class="c1"># mrca_node = self.mrca(taxa=[n1.taxon, n2.taxon])</span>
        <span class="n">cur_node</span> <span class="o">=</span> <span class="n">n1</span>

        <span class="n">break_on_node</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># populated *iff* midpoint is exactly at an existing node</span>
        <span class="n">target_edge</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">head_node_edge_len</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># going up ...</span>
        <span class="k">while</span> <span class="n">cur_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mrca_node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">plen</span><span class="p">:</span>
                <span class="n">target_edge</span> <span class="o">=</span> <span class="n">cur_node</span><span class="o">.</span><span class="n">edge</span>
                <span class="n">head_node_edge_len</span> <span class="o">=</span> <span class="n">plen</span>  <span class="c1"># cur_node.edge.length - plen</span>
                <span class="n">plen</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">cur_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">plen</span><span class="p">:</span>
                <span class="n">plen</span> <span class="o">-=</span> <span class="n">cur_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                <span class="n">cur_node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="o">.</span><span class="n">_parent_node</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">break_on_node</span> <span class="o">=</span> <span class="n">cur_node</span>
                <span class="k">break</span>

        <span class="k">assert</span> <span class="n">break_on_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">target_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">break_on_node</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reseed_at</span><span class="p">(</span>
                <span class="n">break_on_node</span><span class="p">,</span>
                <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">new_seed_node</span> <span class="o">=</span> <span class="n">break_on_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tail_node_edge_len</span> <span class="o">=</span> <span class="n">target_edge</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">head_node_edge_len</span>
            <span class="n">old_head_node</span> <span class="o">=</span> <span class="n">target_edge</span><span class="o">.</span><span class="n">head_node</span>
            <span class="n">old_tail_node</span> <span class="o">=</span> <span class="n">target_edge</span><span class="o">.</span><span class="n">tail_node</span>
            <span class="n">old_tail_node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">old_head_node</span><span class="p">)</span>
            <span class="n">new_seed_node</span> <span class="o">=</span> <span class="n">_node</span><span class="o">.</span><span class="n">Node</span><span class="p">()</span>
            <span class="c1"># new_seed_node.add_child(old_head_node, edge_length=head_node_edge_len)</span>
            <span class="n">new_seed_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">old_head_node</span><span class="p">)</span>
            <span class="n">old_head_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">head_node_edge_len</span>
            <span class="c1"># old_tail_node.add_child(new_seed_node, edge_length=tail_node_edge_len)</span>
            <span class="n">old_tail_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">new_seed_node</span><span class="p">)</span>
            <span class="n">new_seed_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">tail_node_edge_len</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reseed_at</span><span class="p">(</span>
                <span class="n">new_seed_node</span><span class="p">,</span>
                <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
                <span class="n">collapse_unrooted_basal_bifurcation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_rooted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">update_bipartitions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_bipartitions</span><span class="p">(</span>
                <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">collapse_unrooted_basal_bifurcation</span><span class="o">=</span><span class="n">collapse_unrooted_basal_bifurcation</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span></div>


<div class="viewcode-block" id="Tree.suppress_unifurcations">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.suppress_unifurcations">[docs]</a>
    <span class="k">def</span> <span class="nf">suppress_unifurcations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete all nodes of outdegree-one from this tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        update_bipartitions : bool</span>
<span class="sd">            If |True| then the bipartitions encoding will be calculated.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">update_bipartitions</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">:</span>
            <span class="n">bipartitions_to_delete</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bipartitions_to_delete</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">remapped_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">remapped_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nd</span><span class="p">,</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                <span class="k">if</span> <span class="n">bipartitions_to_delete</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">bipartitions_to_delete</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parent</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">insert_child</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="c1"># assert children[0]._parent_node is parent</span>
                    <span class="c1"># assert children[0] in parent._child_nodes</span>
                    <span class="c1"># assert children[0].edge.tail_node is parent</span>
                    <span class="c1"># assert children[0].edge.head_node is children[0]</span>
                    <span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># assert nd is self.seed_node</span>
                    <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bipartitions_to_delete</span><span class="p">:</span>
            <span class="n">old_encoding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">old_encoding</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bipartitions_to_delete</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="n">remapped_nodes</span></div>


    <span class="k">def</span> <span class="nf">delete_outdegree_one_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;delete_outdegree_one_nodes()&#39; has been&quot;</span>
                <span class="s2">&quot; replaced by &#39;suppress_unifurcations()&#39;&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_unifurcations</span><span class="p">()</span>

<div class="viewcode-block" id="Tree.collapse_unweighted_edges">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.collapse_unweighted_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">collapse_unweighted_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0000001</span><span class="p">,</span> <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collapse all *internal* edges with edge lengths less than or equal to</span>
<span class="sd">        ``threshold`` (or with |None| for edge length).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_edge_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">is_internal</span><span class="p">():</span>
                <span class="n">e</span><span class="o">.</span><span class="n">collapse</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">update_bipartitions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_bipartitions</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tree.resolve_polytomies">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.resolve_polytomies">[docs]</a>
    <span class="k">def</span> <span class="nf">resolve_polytomies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arbitrarily resolve polytomies using 0-length edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        limit : int</span>
<span class="sd">            The maximum number of children a node can have before being</span>
<span class="sd">            resolved.</span>
<span class="sd">        update_bipartitions : bool</span>
<span class="sd">            If |True|, then bipartitions will be calculated.</span>
<span class="sd">        rng : ``random.Random`` object or |None|</span>
<span class="sd">            If ``rng`` is an object with a ``sample()`` method then the polytomy</span>
<span class="sd">            will be resolved by sequentially adding, generating all tree</span>
<span class="sd">            topologies equiprobably. ``rng.sample()`` should behave like</span>
<span class="sd">            ``random.sample()``</span>
<span class="sd">            If ``rng`` is |None|, then polytomy is broken deterministically by</span>
<span class="sd">            repeatedly joining pairs of children.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polytomies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
                <span class="n">polytomies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">polytomies</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rng</span><span class="p">:</span>
                <span class="n">to_attach</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">-</span> <span class="n">limit</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">to_attach</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="n">attachment_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span>
                <span class="n">attachment_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_attach</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">next_child</span> <span class="o">=</span> <span class="n">to_attach</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">next_sib</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">attachment_points</span><span class="p">)</span>
                    <span class="n">next_attachment</span> <span class="o">=</span> <span class="n">_node</span><span class="o">.</span><span class="n">Node</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">next_sib</span> <span class="ow">is</span> <span class="n">node</span><span class="p">:</span>
                        <span class="n">cc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">next_attachment</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                            <span class="n">next_attachment</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">next_child</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">next_sib</span><span class="o">.</span><span class="n">_parent_node</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">next_attachment</span><span class="p">)</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">next_sib</span><span class="p">)</span>
                        <span class="n">next_attachment</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">next_sib</span><span class="p">)</span>
                        <span class="n">next_attachment</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">next_child</span><span class="p">)</span>
                    <span class="n">next_attachment</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">attachment_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_attachment</span><span class="p">)</span>
                    <span class="n">attachment_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_child</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
                    <span class="n">nn1</span> <span class="o">=</span> <span class="n">_node</span><span class="o">.</span><span class="n">Node</span><span class="p">()</span>
                    <span class="n">nn1</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">c1</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">c2</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
                    <span class="n">nn1</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
                    <span class="n">nn1</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">nn1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">update_bipartitions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_bipartitions</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tree.prune_subtree">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.prune_subtree">[docs]</a>
    <span class="k">def</span> <span class="nf">prune_subtree</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes subtree starting at ``node`` from tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tried to remove an non-existing or null node&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Node has no parent and is implicit root: cannot be pruned&quot;</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">suppress_unifurcations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">suppress_unifurcations</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">update_bipartitions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_bipartitions</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tree.filter_leaf_nodes">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.filter_leaf_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">filter_leaf_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filter_fn</span><span class="p">,</span>
        <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all leaves for which ``filter_fn`` returns |False|. If recursive</span>
<span class="sd">        is |True|, then process is repeated until all leaf nodes in the tree will</span>
<span class="sd">        evaluate to |True| when passed to ``filter_fn``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ``filter_fn`` : function object</span>
<span class="sd">            A function that takes a |Node| object and returns |True| if</span>
<span class="sd">            the object is to be allowed as a leaf node, and |False| if otherwise.</span>
<span class="sd">        recursive : bool</span>
<span class="sd">            If |True|, then filter is repeatedly applied until all leaf nodes</span>
<span class="sd">            evaluate to |True| under ``filter_fn``. If |False|, then only a</span>
<span class="sd">            single pass is made on the current leaf set. This may result in new</span>
<span class="sd">            leaves for which the ``filter_fn`` is |False| (e.g., the parent node</span>
<span class="sd">            of a cherry in which both children evaluated to |False|</span>
<span class="sd">            under ``filter_fn`` now is a leaf node which may be |False|</span>
<span class="sd">            under ``filter_fn``).</span>
<span class="sd">        suppress_unifurcations : bool</span>
<span class="sd">            If |True|, nodes of outdegree 1 will be deleted as they are</span>
<span class="sd">            encountered.</span>
<span class="sd">        update_bipartitions : bool</span>
<span class="sd">            If |True|, then bipartitions will be calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nds : list[|Node|]</span>
<span class="sd">            List of nodes removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes_removed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">is_nodes_deleted</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">nodes_to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">nd</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_node_iter</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">nd</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">nodes_to_remove</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">SeedNodeDeletionException</span><span class="p">(</span>
                        <span class="s2">&quot;Attempting to remove seed node or node without parent&quot;</span>
                    <span class="p">)</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nodes_to_remove</span><span class="p">:</span>
                <span class="n">nodes_removed</span> <span class="o">+=</span> <span class="n">nodes_to_remove</span>
                <span class="n">is_nodes_deleted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_nodes_deleted</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">recursive</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">suppress_unifurcations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">suppress_unifurcations</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">update_bipartitions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_bipartitions</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">nodes_removed</span></div>


<div class="viewcode-block" id="Tree.prune_leaves_without_taxa">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.prune_leaves_without_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">prune_leaves_without_taxa</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all terminal nodes that have their ``taxon`` attribute set to</span>
<span class="sd">        |None|.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes_removed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">nodes_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_node_iter</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nodes_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">nodes_to_remove</span><span class="p">:</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
            <span class="n">nodes_removed</span> <span class="o">+=</span> <span class="n">nodes_to_remove</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes_to_remove</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">recursive</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">suppress_unifurcations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">suppress_unifurcations</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">update_bipartitions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_bipartitions</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">nodes_removed</span></div>


    <span class="k">def</span> <span class="nf">prune_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">,</span>
        <span class="n">prune_leaves_without_taxa</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Attempting to remove root node or node without parent&quot;</span><span class="p">)</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prune_leaves_without_taxa</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prune_leaves_without_taxa</span><span class="p">(</span>
                <span class="n">update_bipartitions</span><span class="o">=</span><span class="n">update_bipartitions</span><span class="p">,</span>
                <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
            <span class="p">)</span>

<div class="viewcode-block" id="Tree.prune_taxa">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.prune_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">prune_taxa</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">taxa</span><span class="p">,</span>
        <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">is_apply_filter_to_leaf_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">is_apply_filter_to_internal_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes terminal nodes associated with Taxon objects given by the container</span>
<span class="sd">        ``taxa`` (which can be any iterable, including a TaxonNamespace object) from ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxa</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span>
        <span class="n">nodes_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">is_apply_filter_to_internal_nodes</span> <span class="ow">and</span> <span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">is_apply_filter_to_leaf_nodes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">and</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">in</span> <span class="n">taxa</span><span class="p">):</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prune_leaves_without_taxa</span><span class="p">(</span>
            <span class="n">update_bipartitions</span><span class="o">=</span><span class="n">update_bipartitions</span><span class="p">,</span>
            <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.prune_taxa_with_labels">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.prune_taxa_with_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">prune_taxa_with_labels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">,</span>
        <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">is_apply_filter_to_leaf_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">is_apply_filter_to_internal_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes terminal nodes that are associated with Taxon objects with</span>
<span class="sd">        labels given by ``labels``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">get_taxa</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prune_taxa</span><span class="p">(</span>
            <span class="n">taxa</span><span class="o">=</span><span class="n">taxa</span><span class="p">,</span>
            <span class="n">update_bipartitions</span><span class="o">=</span><span class="n">update_bipartitions</span><span class="p">,</span>
            <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_leaf_nodes</span><span class="o">=</span><span class="n">is_apply_filter_to_leaf_nodes</span><span class="p">,</span>
            <span class="n">is_apply_filter_to_internal_nodes</span><span class="o">=</span><span class="n">is_apply_filter_to_internal_nodes</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.retain_taxa">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.retain_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">retain_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxa</span><span class="p">,</span> <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes terminal nodes that are not associated with any</span>
<span class="sd">        of the Taxon objects given by ``taxa`` (which can be any iterable, including a</span>
<span class="sd">        TaxonNamespace object) from the ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_prune</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">taxa</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prune_taxa</span><span class="p">(</span>
            <span class="n">to_prune</span><span class="p">,</span>
            <span class="n">update_bipartitions</span><span class="o">=</span><span class="n">update_bipartitions</span><span class="p">,</span>
            <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.retain_taxa_with_labels">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.retain_taxa_with_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">retain_taxa_with_labels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes terminal nodes that are not associated with Taxon objects with</span>
<span class="sd">        labels given by ``labels``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">get_taxa</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retain_taxa</span><span class="p">(</span>
            <span class="n">taxa</span><span class="o">=</span><span class="n">taxa</span><span class="p">,</span>
            <span class="n">update_bipartitions</span><span class="o">=</span><span class="n">update_bipartitions</span><span class="p">,</span>
            <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="n">suppress_unifurcations</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.randomly_reorient">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.randomly_reorient">[docs]</a>
    <span class="k">def</span> <span class="nf">randomly_reorient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update_bipartitions</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly picks a new rooting position and rotates the branches around all</span>
<span class="sd">        internal nodes in the ``self``. If ``update_bipartitions`` is True, the the ``bipartition_bitmask``</span>
<span class="sd">        and ``bipartition_edge_map`` attributes kept valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>  <span class="c1"># use the global rng by default</span>
        <span class="n">nd</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_outgroup_position</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">update_bipartitions</span><span class="o">=</span><span class="n">update_bipartitions</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reseed_at</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">update_bipartitions</span><span class="o">=</span><span class="n">update_bipartitions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomly_rotate</span><span class="p">(</span><span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.randomly_rotate">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.randomly_rotate">[docs]</a>
    <span class="k">def</span> <span class="nf">randomly_rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="s2">&quot;Randomly rotates the branches around all internal nodes in ``self``&quot;</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>  <span class="c1"># use the global rng by default</span>
        <span class="n">internal_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_nodes</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">internal_nodes</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
            <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">set_child_nodes</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.shuffle_taxa">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.shuffle_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">shuffle_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_internal_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly re-assigns taxa associated with nodes. Note that in the case</span>
<span class="sd">        of not all nodes being associated with taxa, this will NOT assign taxa</span>
<span class="sd">        to nodes that currently do not have them, nor will nodes currently</span>
<span class="sd">        associated with taxa end up not being associated with taxa.</span>
<span class="sd">        Returns a dictionary mapping the old taxa to their new counterparts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>  <span class="c1"># use the global rng by default</span>
        <span class="k">if</span> <span class="n">include_internal_nodes</span><span class="p">:</span>
            <span class="n">nd_iterator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nd_iterator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_node_iter</span>
        <span class="n">current_node_taxon_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">node_taxa</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">nd_iterator</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_node_taxon_map</span>
                <span class="n">current_node_taxon_map</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span>
                <span class="n">node_taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">taxon</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_node_taxon_map</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_taxa</span><span class="p">)</span>
        <span class="n">current_to_shuffled_taxon_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">current_node_taxon_map</span><span class="p">:</span>
            <span class="c1"># swap a random element to end of node_taxa...</span>
            <span class="n">random_index</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node_taxa</span><span class="p">))</span>
            <span class="n">node_taxa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">node_taxa</span><span class="p">[</span><span class="n">random_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">node_taxa</span><span class="p">[</span><span class="n">random_index</span><span class="p">],</span> <span class="n">node_taxa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="c1"># ... then pop it off the end and use it</span>
            <span class="n">new_taxon</span> <span class="o">=</span> <span class="n">node_taxa</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">current_to_shuffled_taxon_map</span><span class="p">[</span><span class="n">nd</span><span class="o">.</span><span class="n">taxon</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_taxon</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="n">new_taxon</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_taxa</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node_taxa</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_to_shuffled_taxon_map</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_node_taxon_map</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_to_shuffled_taxon_map</span></div>


<div class="viewcode-block" id="Tree.ladderize">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.ladderize">[docs]</a>
    <span class="k">def</span> <span class="nf">ladderize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts child nodes in ascending (if ``ascending`` is |True|) or</span>
<span class="sd">        descending (if ``ascending`` is |False|) order in terms of the number of</span>
<span class="sd">        children each child node has.</span>

<span class="sd">        Ladderize sort is stable. To control order between nodes with</span>
<span class="sd">        same child count, call ``reorder`` prior to ladderization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_desc_counts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">node_desc_counts</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
                    <span class="n">total</span> <span class="o">+=</span> <span class="n">node_desc_counts</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span>
                <span class="n">node_desc_counts</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                    <span class="n">key</span><span class="o">=</span><span class="n">node_desc_counts</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span>
                    <span class="n">reverse</span><span class="o">=</span><span class="ow">not</span> <span class="n">ascending</span><span class="p">,</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.reorder">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.reorder">[docs]</a>
    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">nd</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="s2">&quot;taxon&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorder the children of each node in the tree, by default in ascending</span>
<span class="sd">        order by Taxon with missing taxa treated as labeled as empty string.</span>
<span class="sd">        Does not alter tree topology.</span>

<span class="sd">        Specify ``key`` to sort by a different attribute or function of nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">():</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="ow">not</span> <span class="n">ascending</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">truncate_from_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance_from_root</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_node_root_distances</span><span class="p">()</span>
        <span class="n">new_terminals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span><span class="p">:</span>
                <span class="c1"># root node</span>
                <span class="c1"># TODO: strictly speaking, this might be a terminal if distance_from_root == 0</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">root_distance</span> <span class="o">==</span> <span class="n">distance_from_root</span><span class="p">:</span>
                    <span class="n">new_terminals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="n">nd</span><span class="o">.</span><span class="n">root_distance</span> <span class="o">&gt;</span> <span class="n">distance_from_root</span>
                    <span class="ow">and</span> <span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">root_distance</span> <span class="o">&lt;</span> <span class="n">distance_from_root</span>
                <span class="p">):</span>
                    <span class="c1"># cut above current node</span>
                    <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">distance_from_root</span> <span class="o">-</span> <span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">root_distance</span>
                    <span class="n">nd</span><span class="o">.</span><span class="n">root_distance</span> <span class="o">=</span> <span class="n">distance_from_root</span>
                    <span class="n">new_terminals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">new_terminals</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">nd</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">():</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.scale_edges">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.scale_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">scale_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_len_multiplier</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multiplies every edge length in ``self`` by ``edge_len_multiplier``&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_edge_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">length</span> <span class="o">*=</span> <span class="n">edge_len_multiplier</span></div>


<div class="viewcode-block" id="Tree.set_edge_lengths_from_node_ages">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.set_edge_lengths_from_node_ages">[docs]</a>
    <span class="k">def</span> <span class="nf">set_edge_lengths_from_node_ages</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">minimum_edge_length</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">error_on_negative_edge_lengths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the edge lengths of the tree so that the path lengths from the</span>
<span class="sd">        tips equal the value of the ``age`` attribute of the nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_edge_length : numeric</span>
<span class="sd">            All edge lengths calculated to have a value less than this will be</span>
<span class="sd">            set to this.</span>
<span class="sd">        error_on_negative_edge_lengths : bool</span>
<span class="sd">            If |True|, an inferred edge length that is less than 0 will result</span>
<span class="sd">            in a ValueError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if nd._parent_node.age &lt; nd.age:</span>
                <span class="c1">#    nd.edge.length = 0.0</span>
                <span class="c1"># else:</span>
                <span class="c1">#    nd.edge.length = nd._parent_node.age - nd.age</span>
                <span class="n">edge_length</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">age</span> <span class="o">-</span> <span class="n">nd</span><span class="o">.</span><span class="n">age</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">minimum_edge_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="n">edge_length</span> <span class="o">&lt;</span> <span class="n">minimum_edge_length</span>
                <span class="p">):</span>
                    <span class="n">edge_length</span> <span class="o">=</span> <span class="n">minimum_edge_length</span>
                <span class="k">if</span> <span class="n">error_on_negative_edge_lengths</span> <span class="ow">and</span> <span class="n">edge_length</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Negative edge length: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge_length</span><span class="p">))</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">edge_length</span></div>


<div class="viewcode-block" id="Tree.phylogenetic_distance_matrix">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.phylogenetic_distance_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">phylogenetic_distance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a |PhylogeneticDistanceMatrix| instance based</span>
<span class="sd">        on the tree (in its current state).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdc : a |PhylogeneticDistanceMatrix| instance</span>
<span class="sd">            A |PhylogeneticDistanceMatrix| instance corresponding to the</span>
<span class="sd">            tree in its current state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate.phylogeneticdistance</span> <span class="kn">import</span> <span class="n">PhylogeneticDistanceMatrix</span>

        <span class="k">return</span> <span class="n">PhylogeneticDistanceMatrix</span><span class="o">.</span><span class="n">from_tree</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">node_distance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate.phylogeneticdistance</span> <span class="kn">import</span> <span class="n">NodeDistanceMatrix</span>

        <span class="k">return</span> <span class="n">NodeDistanceMatrix</span><span class="o">.</span><span class="n">from_tree</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.resolve_node_depths">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.resolve_node_depths">[docs]</a>
    <span class="k">def</span> <span class="nf">resolve_node_depths</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_callback_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_edge_length_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attr_name</span><span class="o">=</span><span class="s2">&quot;depth&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an attribute given by ``attr_name`` to  each node, with the value equal to</span>
<span class="sd">        the sum of edge lengths from the root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">node_edge_length_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_edge_length_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">nd</span><span class="p">:</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span>
                <span class="n">v</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">node_edge_length_fn</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">+</span> <span class="n">cache</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span><span class="p">]</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">if</span> <span class="n">attr_name</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node_callback_fn</span><span class="p">:</span>
                <span class="n">node_callback_fn</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cache</span></div>


<div class="viewcode-block" id="Tree.resolve_node_ages">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.resolve_node_ages">[docs]</a>
    <span class="k">def</span> <span class="nf">resolve_node_ages</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_callback_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_edge_length_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attr_name</span><span class="o">=</span><span class="s2">&quot;age&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an attribute called &quot;age&quot; to  each node, with the value equal to</span>
<span class="sd">        the time elapsed since the present.</span>

<span class="sd">        This is calculated by:</span>
<span class="sd">        (1) setting the age of the root node to the sum of path lengths to the most distant tip</span>
<span class="sd">        (2) setting the age of each other node as the sum of path lengths from the root.</span>

<span class="sd">        Unlike the (legacy) `calc_node_ages()` there is no ultrametricity requirement or check.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">depth_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve_node_depths</span><span class="p">(</span>
            <span class="n">node_edge_length_fn</span><span class="o">=</span><span class="n">node_edge_length_fn</span><span class="p">,</span>
            <span class="n">attr_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">max_depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">depth_cache</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">():</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">max_depth</span> <span class="o">-</span> <span class="n">depth_cache</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">if</span> <span class="n">attr_name</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="c1"># if node is self.seed_node:</span>
            <span class="c1">#     assert abs(getattr(node, attr_name) - max_root_distance[0]) &lt;= 1e-8</span>
            <span class="k">if</span> <span class="n">node_callback_fn</span><span class="p">:</span>
                <span class="n">node_callback_fn</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cache</span></div>


<div class="viewcode-block" id="Tree.calc_node_ages">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.calc_node_ages">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_node_ages</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">DEFAULT_ULTRAMETRICITY_PRECISION</span><span class="p">,</span>
        <span class="n">is_force_max_age</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">is_force_min_age</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">set_node_age_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">is_return_internal_node_ages_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an attribute called &quot;age&quot; to  each node, with the value equal to</span>
<span class="sd">        the sum of edge lengths from the node to the tips.</span>

<span class="sd">        NOTE: Consider using the newer and more flexible `resolve_node_ages()`</span>
<span class="sd">        instead of this.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ultrametricity_precision : numeric or bool or None</span>
<span class="sd">            If the lengths of different paths to the node differ by more than</span>
<span class="sd">            ``ultrametricity_precision``, then a ValueError exception will be</span>
<span class="sd">            raised indicating deviation from ultrametricity. If</span>
<span class="sd">            ``ultrametricity_precision`` is negative or False, then this check</span>
<span class="sd">            will be skipped.</span>
<span class="sd">        is_force_max_age: bool</span>
<span class="sd">            If ``is_force_max_age`` is |True|, then each node will be set to the</span>
<span class="sd">            maximum possible age, by being set to the oldest age given its</span>
<span class="sd">            child set and the subtending edge lengths. This option only makes a</span>
<span class="sd">            difference if the tree is not ultrametric, and so the</span>
<span class="sd">            ultrametricity precision check is ignore if this option is set to</span>
<span class="sd">            True.</span>
<span class="sd">        is_force_min_age: bool</span>
<span class="sd">            If ``is_force_min_age`` is |True| then each node will be set to the</span>
<span class="sd">            minimum possible age, by being set to the youngest age given its</span>
<span class="sd">            child set and the subtending edge lengths. This option only makes a</span>
<span class="sd">            difference if the tree is not ultrametric, and so the</span>
<span class="sd">            ultrametricity precision check is ignore if this option is set to</span>
<span class="sd">            True.</span>
<span class="sd">        set_node_age_fn: function object</span>
<span class="sd">            If not |None|, then this should be a function that takes a node as</span>
<span class="sd">            an argument and returns |None| or a non-|None| value. If</span>
<span class="sd">            |None|, then this indicates that the node&#39;s age should be</span>
<span class="sd">            calculated by this function. If not |None|, then this is the</span>
<span class="sd">            value that this node&#39;s age should be set to. This can be used to</span>
<span class="sd">            set non-contemporary tip ages by passing something like:</span>

<span class="sd">                f = lambda nd: None if not nd.is_leaf else nd.annotations[&quot;height&quot;]</span>

<span class="sd">            which returns |None| if the node is an internal node, but</span>
<span class="sd">            otherwise returns the value in the ``height`` annotation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a : iterable[numeric]</span>
<span class="sd">            Returns collection of node ages.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">is_force_max_age</span> <span class="ow">and</span> <span class="n">is_force_min_age</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify both &#39;is_force_max_age&#39; and &#39;is_force_min_age&#39;&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="n">child_nodes</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">set_node_age_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">set_node_age_fn</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="c1"># print(&quot;Setting node age: {} = {}&quot;.format(node.taxon, node.age))</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">age</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_return_internal_node_ages_only</span><span class="p">:</span>
                    <span class="n">ages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_force_max_age</span><span class="p">:</span>
                    <span class="n">age_to_set</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="p">[(</span><span class="n">child</span><span class="o">.</span><span class="n">age</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">child_nodes</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">is_force_min_age</span><span class="p">:</span>
                    <span class="n">age_to_set</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="p">[(</span><span class="n">child</span><span class="o">.</span><span class="n">age</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">child_nodes</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">first_child</span> <span class="o">=</span> <span class="n">child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">first_child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="ow">and</span> <span class="n">first_child</span><span class="o">.</span><span class="n">age</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="p">):</span>
                        <span class="n">age_to_set</span> <span class="o">=</span> <span class="n">first_child</span><span class="o">.</span><span class="n">age</span> <span class="o">+</span> <span class="n">first_child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                    <span class="k">elif</span> <span class="n">first_child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">first_child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="n">age_to_set</span> <span class="o">=</span> <span class="n">first_child</span><span class="o">.</span><span class="n">age</span>
                    <span class="k">elif</span> <span class="n">first_child</span><span class="o">.</span><span class="n">age</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">first_child</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="n">age_to_set</span> <span class="o">=</span> <span class="n">first_child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">age_to_set</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">node</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age_to_set</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">is_force_max_age</span>
                    <span class="ow">or</span> <span class="n">is_force_min_age</span>
                    <span class="ow">or</span> <span class="n">ultrametricity_precision</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="ow">or</span> <span class="n">ultrametricity_precision</span> <span class="ow">is</span> <span class="kc">False</span>
                    <span class="ow">or</span> <span class="n">ultrametricity_precision</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="k">for</span> <span class="n">nnd</span> <span class="ow">in</span> <span class="n">child_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">ocnd</span> <span class="o">=</span> <span class="n">nnd</span><span class="o">.</span><span class="n">age</span> <span class="o">+</span> <span class="n">nnd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="n">nnd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">ocnd</span> <span class="o">=</span> <span class="n">nnd</span><span class="o">.</span><span class="n">age</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">age</span> <span class="o">-</span> <span class="n">ocnd</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">ultrametricity_precision</span><span class="p">:</span>
                            <span class="c1"># try:</span>
                            <span class="c1">#     self.encode_bipartitions()</span>
                            <span class="c1">#     node_id = nnd.bipartition.split_as_newick_string(taxon_namespace=self.taxon_namespace)</span>
                            <span class="c1"># except OSError:</span>
                            <span class="c1">#     node_id = str(nnd)</span>
                            <span class="n">node_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                            <span class="n">subtree</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_as_newick_string</span><span class="p">()</span>
                            <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">for</span> <span class="n">desc_nd</span> <span class="ow">in</span> <span class="n">child_nodes</span><span class="p">:</span>
                                <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s2">&quot;-   </span><span class="si">{}</span><span class="s2">: has age of </span><span class="si">{}</span><span class="s2"> and edge length of </span><span class="si">{}</span><span class="s2">,&quot;</span>
                                    <span class="s2">&quot; resulting in parent node age of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                        <span class="n">desc_nd</span><span class="p">,</span>
                                        <span class="n">desc_nd</span><span class="o">.</span><span class="n">age</span><span class="p">,</span>
                                        <span class="n">desc_nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                                        <span class="n">desc_nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">desc_nd</span><span class="o">.</span><span class="n">age</span><span class="p">,</span>
                                    <span class="p">)</span>
                                <span class="p">)</span>
                            <span class="n">desc</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">UltrametricityError</span><span class="p">(</span>
                                <span class="p">(</span>
                                    <span class="s2">&quot;Tree is not ultrametric within threshold of&quot;</span>
                                    <span class="s2">&quot; </span><span class="si">{threshold}</span><span class="s2">: </span><span class="si">{deviance}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">Encountered in subtree&quot;</span>
                                    <span class="s2">&quot; of node </span><span class="si">{node}</span><span class="s2"> (edge length of </span><span class="si">{length}</span><span class="s2">):</span><span class="se">\n\n</span><span class="s2">   &quot;</span>
                                    <span class="s2">&quot; </span><span class="si">{subtree}</span><span class="se">\n\n</span><span class="s2">Age of children:</span><span class="se">\n</span><span class="si">{desc}</span><span class="s2">&quot;</span>
                                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">threshold</span><span class="o">=</span><span class="n">ultrametricity_precision</span><span class="p">,</span>
                                    <span class="n">deviance</span><span class="o">=</span><span class="n">d</span><span class="p">,</span>
                                    <span class="n">node</span><span class="o">=</span><span class="n">node_id</span><span class="p">,</span>
                                    <span class="n">length</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                                    <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span>
                                    <span class="n">subtree</span><span class="o">=</span><span class="n">subtree</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                <span class="n">ages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ages</span></div>


<div class="viewcode-block" id="Tree.calc_node_root_distances">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.calc_node_root_distances">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_node_root_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_leaf_distances_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds attribute &quot;root_distance&quot; to each node, with value set to the</span>
<span class="sd">        sum of edge lengths from the node to the root. Returns list of</span>
<span class="sd">        distances. If ``return_leaf_distances_only`` is True, then only</span>
<span class="sd">        leaf distances will be true.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">root_distance</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">root_distance</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">root_distance</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">return_leaf_distances_only</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">root_distance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dists</span></div>


<div class="viewcode-block" id="Tree.internal_node_ages">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.internal_node_ages">[docs]</a>
    <span class="k">def</span> <span class="nf">internal_node_ages</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">DEFAULT_ULTRAMETRICITY_PRECISION</span><span class="p">,</span>
        <span class="n">is_force_max_age</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">is_force_min_age</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">set_node_age_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of ages of speciation events / coalescence times on tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_node_ages</span><span class="p">(</span>
            <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">ultrametricity_precision</span><span class="p">,</span>
            <span class="n">is_return_internal_node_ages_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">is_force_max_age</span><span class="o">=</span><span class="n">is_force_max_age</span><span class="p">,</span>
            <span class="n">is_force_min_age</span><span class="o">=</span><span class="n">is_force_min_age</span><span class="p">,</span>
            <span class="n">set_node_age_fn</span><span class="o">=</span><span class="n">set_node_age_fn</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ages</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ages</span></div>


<div class="viewcode-block" id="Tree.node_ages">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.node_ages">[docs]</a>
    <span class="k">def</span> <span class="nf">node_ages</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">DEFAULT_ULTRAMETRICITY_PRECISION</span><span class="p">,</span>
        <span class="n">is_force_max_age</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">is_force_min_age</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">set_node_age_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">internal_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of ages of all nodes on tree.</span>
<span class="sd">        NOTE: Changed from DendroPy3: this function now returns the ages of</span>
<span class="sd">        *ALL* nodes. To get only internal node ages, use</span>
<span class="sd">        `Tree.internal_node_ages`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_node_ages</span><span class="p">(</span>
            <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">ultrametricity_precision</span><span class="p">,</span>
            <span class="n">is_force_max_age</span><span class="o">=</span><span class="n">is_force_max_age</span><span class="p">,</span>
            <span class="n">is_force_min_age</span><span class="o">=</span><span class="n">is_force_min_age</span><span class="p">,</span>
            <span class="n">set_node_age_fn</span><span class="o">=</span><span class="n">set_node_age_fn</span><span class="p">,</span>
            <span class="n">is_return_internal_node_ages_only</span><span class="o">=</span><span class="n">internal_only</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ages</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ages</span></div>


<div class="viewcode-block" id="Tree.length">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.length">[docs]</a>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns sum of edge lengths of self. Edges with no lengths defined</span>
<span class="sd">        (None) will be considered to have a length of 0.</span>
<span class="sd">        Note that we do not overrride ``__len__`` as this requires an integer</span>
<span class="sd">        return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_edge_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">edge</span><span class="o">.</span><span class="n">length</span>
        <span class="k">return</span> <span class="n">total</span></div>


<div class="viewcode-block" id="Tree.max_distance_from_root">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.max_distance_from_root">[docs]</a>
    <span class="k">def</span> <span class="nf">max_distance_from_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns distance of node furthest from root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_node_root_distances</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.minmax_leaf_distance_from_root">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.minmax_leaf_distance_from_root">[docs]</a>
    <span class="k">def</span> <span class="nf">minmax_leaf_distance_from_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns pair of values, representing the distance of the leaf closest</span>
<span class="sd">        to a furthest from the root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_node_root_distances</span><span class="p">(</span><span class="n">return_leaf_distances_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">dists</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.coalescence_intervals">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.coalescence_intervals">[docs]</a>
    <span class="k">def</span> <span class="nf">coalescence_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of coalescence intervals of self., i.e., the waiting</span>
<span class="sd">        times between successive coalescence events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_ages</span><span class="p">()</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ages</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ages</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">ages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">intervals</span></div>


<div class="viewcode-block" id="Tree.num_lineages_at">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.num_lineages_at">[docs]</a>
    <span class="k">def</span> <span class="nf">num_lineages_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance_from_root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of lineages on the tree at a particular distance</span>
<span class="sd">        from the root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_node_root_distances</span><span class="p">()</span>
        <span class="n">num_lineages</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span><span class="p">:</span>
                <span class="c1"># root node</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">root_distance</span> <span class="o">==</span> <span class="n">distance_from_root</span><span class="p">:</span>
                    <span class="n">num_lineages</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="n">nd</span><span class="o">.</span><span class="n">root_distance</span> <span class="o">&gt;=</span> <span class="n">distance_from_root</span>
                    <span class="ow">and</span> <span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">root_distance</span> <span class="o">&lt;</span> <span class="n">distance_from_root</span>
                <span class="p">):</span>
                    <span class="n">num_lineages</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">num_lineages</span></div>


    <span class="k">def</span> <span class="nf">_compile_mutable_bipartition_for_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">compile_split_bitmask</span><span class="p">(</span>
            <span class="n">tree_leafset_bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span><span class="p">,</span>
            <span class="n">is_mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span>

    <span class="k">def</span> <span class="nf">_compile_immutable_bipartition_for_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">compile_split_bitmask</span><span class="p">(</span>
            <span class="n">tree_leafset_bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span><span class="p">,</span>
            <span class="n">is_mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span>

<div class="viewcode-block" id="Tree.encode_bipartitions">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.encode_bipartitions">[docs]</a>
    <span class="k">def</span> <span class="nf">encode_bipartitions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">suppress_unifurcations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">collapse_unrooted_basal_bifurcation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">suppress_storage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">is_bipartitions_mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the bipartitions of this tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        suppress_unifurcations : bool</span>
<span class="sd">            If |True|, nodes of outdegree 1 will be deleted as they are</span>
<span class="sd">            encountered.</span>
<span class="sd">        collapse_unrooted_basal_bifurcation: bool</span>
<span class="sd">            If |True|, then a basal bifurcation on an unrooted tree will be</span>
<span class="sd">            collapsed to a trifurcation. This mean that an unrooted tree like</span>
<span class="sd">            &#39;(A,(B,C))&#39; will be changed to &#39;(A,B,C)&#39; after this.</span>
<span class="sd">        suppress_storage : bool</span>
<span class="sd">            By default, the bipartition encoding is stored as a list (assigned</span>
<span class="sd">            to ``self.bipartition_encoding``) and returned. If ``suppress_storage``</span>
<span class="sd">            is |True|, then the list is not created.</span>
<span class="sd">        is_bipartitions_mutable : bool</span>
<span class="sd">            By default, the |Bipartition| instances coded will be locked</span>
<span class="sd">            or frozen, allowing their use in hashing containers such as</span>
<span class="sd">            dictionary (keys) and sets. To allow modification of values, the</span>
<span class="sd">            ``is_mutable`` attribute must be set to |True|.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[|Bipartition|] or |None|</span>
<span class="sd">            A list of |Bipartition| objects of this |Tree|</span>
<span class="sd">            representing the structure of this tree, or, if ``suppress_storage``</span>
<span class="sd">            is |True|, then |None|.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_bitmask_edge_map</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bipartition_edge_map</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_namespace</span>
        <span class="n">seed_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">seed_node</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">collapse_unrooted_basal_bifurcation</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">seed_node</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">):</span>
            <span class="c1"># We do this because an unrooted tree</span>
            <span class="c1"># has no *true* degree-3 internal nodes:</span>
            <span class="c1">#</span>
            <span class="c1">#      \  | |  /</span>
            <span class="c1">#       +-+-+-+</span>
            <span class="c1">#      /       \</span>
            <span class="c1">#</span>
            <span class="c1"># (whereas, with a rooted tree, the basal bipartition is a true</span>
            <span class="c1"># degree-3 node: the edge subtending it does not really</span>
            <span class="c1"># exist in the graph -- it is not a true link connecting</span>
            <span class="c1"># two nodes).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapse_basal_bifurcation</span><span class="p">()</span>
        <span class="n">tree_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_edge_iter</span><span class="p">():</span>
            <span class="n">leafset_bitmask</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">head_node</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">_head_node</span>
            <span class="n">child_nodes</span> <span class="o">=</span> <span class="n">head_node</span><span class="o">.</span><span class="n">_child_nodes</span>
            <span class="n">num_children</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_nodes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num_children</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">suppress_unifurcations</span><span class="p">:</span>
                <span class="c1"># collapsing node: remove, and do not process/add edge</span>
                <span class="k">if</span> <span class="n">head_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">head_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="n">head_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                <span class="k">if</span> <span class="n">head_node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parent</span> <span class="o">=</span> <span class="n">head_node</span><span class="o">.</span><span class="n">_parent_node</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_child_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">head_node</span><span class="p">)</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">head_node</span><span class="p">)</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">insert_child</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">head_node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span> <span class="o">=</span> <span class="n">child_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num_children</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tree_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                    <span class="n">taxon</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">_head_node</span><span class="o">.</span><span class="n">taxon</span>
                    <span class="k">if</span> <span class="n">taxon</span><span class="p">:</span>
                        <span class="n">leafset_bitmask</span> <span class="o">=</span> <span class="n">taxon_namespace</span><span class="o">.</span><span class="n">taxon_bitmask</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tree_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">child_nodes</span><span class="p">:</span>
                        <span class="n">leafset_bitmask</span> <span class="o">|=</span> <span class="n">child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span> <span class="o">=</span> <span class="n">_bipartition</span><span class="o">.</span><span class="n">Bipartition</span><span class="p">(</span>
                    <span class="n">compile_bipartition</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_mutable</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span> <span class="o">=</span> <span class="n">leafset_bitmask</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_is_rooted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span>
        <span class="c1"># Create normalized bitmasks, where the full (self) bipartition mask is *not*</span>
        <span class="c1"># all the taxa, but only those found on the self; this is to handle</span>
        <span class="c1"># cases where we are dealing with selfs with incomplete leaf-sets.</span>
        <span class="n">tree_leafset_bitmask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span>
        <span class="k">if</span> <span class="n">is_bipartitions_mutable</span><span class="p">:</span>
            <span class="n">_compile_bipartition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_mutable_bipartition_for_edge</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_compile_bipartition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_immutable_bipartition_for_edge</span>
        <span class="k">if</span> <span class="n">suppress_storage</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">_compile_bipartition</span><span class="p">,</span> <span class="n">tree_edges</span><span class="p">):</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># self.bipartition_encoding = dict(zip(map(self._compile_bipartition_for_edge, tree_edges), tree_edges))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_compile_bipartition</span><span class="p">,</span> <span class="n">tree_edges</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span></div>


<div class="viewcode-block" id="Tree.update_bipartitions">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.update_bipartitions">[docs]</a>
    <span class="k">def</span> <span class="nf">update_bipartitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recalculates bipartition hashes for tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.encode_splits">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.encode_splits">[docs]</a>
    <span class="k">def</span> <span class="nf">encode_splits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recalculates bipartition hashes for tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;Tree.encode_splits()&#39; will no longer be&quot;</span>
                <span class="s2">&quot; supported in future releases; use &#39;Tree.encode_bipartitions()&#39;&quot;</span>
                <span class="s2">&quot; instead&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.update_splits">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.update_splits">[docs]</a>
    <span class="k">def</span> <span class="nf">update_splits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recalculates bipartition hashes for tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: &#39;Tree.encode_splits()&#39; will no longer be&quot;</span>
                <span class="s2">&quot; supported in future releases; use &#39;Tree.update_bipartitions()&#39;&quot;</span>
                <span class="s2">&quot; instead&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_bipartition_edge_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bipartition_edge_map</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bipartition_edge_map</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_split_bitmask_edge_map</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_edge_iter</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bipartition_edge_map</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_split_bitmask_edge_map</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_bitmask</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bipartition_edge_map</span>

    <span class="n">bipartition_edge_map</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_bipartition_edge_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_split_bitmask_edge_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_bitmask_edge_map</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_bipartition_edge_map</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_bitmask_edge_map</span>

    <span class="n">split_bitmask_edge_map</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_split_bitmask_edge_map</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.__len__">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.__len__">[docs]</a>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns number of tips on tree (could be less than number of taxa in namespace).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">leaf_iter</span><span class="p">():</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span></div>


<div class="viewcode-block" id="Tree.B1">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.B1">[docs]</a>
    <span class="k">def</span> <span class="nf">B1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Use :func:`dendropy.calculate.treemeasure.B1()`.&quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">preamble</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: Unary statistics on trees are now&quot;</span>
                <span class="s2">&quot; implemented in the &#39;dendropy.calculate.treemeasure&#39; module.&quot;</span>
            <span class="p">),</span>
            <span class="n">old_construct</span><span class="o">=</span><span class="s2">&quot;tree.B1()&quot;</span><span class="p">,</span>
            <span class="n">new_construct</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;from dendropy.calculate import treemeasure</span><span class="se">\n</span><span class="s2">treemeasure.B1(tree)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">treemeasure</span>

        <span class="k">return</span> <span class="n">treemeasure</span><span class="o">.</span><span class="n">B1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.colless_tree_imbalance">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.colless_tree_imbalance">[docs]</a>
    <span class="k">def</span> <span class="nf">colless_tree_imbalance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Use &#39;dendropy.calculate.treemeasure.colless_tree_imbalance()&#39;.&quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">preamble</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: Unary statistics on trees are now&quot;</span>
                <span class="s2">&quot; implemented in the &#39;dendropy.calculate.treemeasure&#39; module.&quot;</span>
            <span class="p">),</span>
            <span class="n">old_construct</span><span class="o">=</span><span class="s2">&quot;tree.colless_tree_imbalance()&quot;</span><span class="p">,</span>
            <span class="n">new_construct</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;from dendropy.calculate import&quot;</span>
                <span class="s2">&quot; treemeasure</span><span class="se">\n</span><span class="s2">treemeasure.colless_tree_imbalance(tree)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">treemeasure</span>

        <span class="k">return</span> <span class="n">treemeasure</span><span class="o">.</span><span class="n">colless_tree_imbalance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.pybus_harvey_gamma">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.pybus_harvey_gamma">[docs]</a>
    <span class="k">def</span> <span class="nf">pybus_harvey_gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Use &#39;dendropy.calculate.treemeasure.pybus_harvey_gamma()&#39;.&quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">preamble</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: Unary statistics on trees are now&quot;</span>
                <span class="s2">&quot; implemented in the &#39;dendropy.calculate.treemeasure&#39; module.&quot;</span>
            <span class="p">),</span>
            <span class="n">old_construct</span><span class="o">=</span><span class="s2">&quot;tree.pybus_harvey_gamma()&quot;</span><span class="p">,</span>
            <span class="n">new_construct</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;from dendropy.calculate import&quot;</span>
                <span class="s2">&quot; treemeasure</span><span class="se">\n</span><span class="s2">treemeasure.pybus_harvey_gamma(tree)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">treemeasure</span>

        <span class="k">return</span> <span class="n">treemeasure</span><span class="o">.</span><span class="n">pybus_harvey_gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.N_bar">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.N_bar">[docs]</a>
    <span class="k">def</span> <span class="nf">N_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Use &#39;dendropy.calculate.treemeasure.N_bar()&#39;.&quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">preamble</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: Unary statistics on trees are now&quot;</span>
                <span class="s2">&quot; implemented in the &#39;dendropy.calculate.treemeasure&#39; module.&quot;</span>
            <span class="p">),</span>
            <span class="n">old_construct</span><span class="o">=</span><span class="s2">&quot;tree.N_bar()&quot;</span><span class="p">,</span>
            <span class="n">new_construct</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;from dendropy.calculate import treemeasure</span><span class="se">\n</span><span class="s2">treemeasure.N_bar(tree)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">treemeasure</span>

        <span class="k">return</span> <span class="n">treemeasure</span><span class="o">.</span><span class="n">N_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.sackin_index">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.sackin_index">[docs]</a>
    <span class="k">def</span> <span class="nf">sackin_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Use &#39;dendropy.calculate.treemeasure.sackin_index()&#39;.&quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">preamble</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: Unary statistics on trees are now&quot;</span>
                <span class="s2">&quot; implemented in the &#39;dendropy.calculate.treemeasure&#39; module.&quot;</span>
            <span class="p">),</span>
            <span class="n">old_construct</span><span class="o">=</span><span class="s2">&quot;tree.sackin_index()&quot;</span><span class="p">,</span>
            <span class="n">new_construct</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;from dendropy.calculate import&quot;</span>
                <span class="s2">&quot; treemeasure</span><span class="se">\n</span><span class="s2">treemeasure.sackin_index(tree)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">treemeasure</span>

        <span class="k">return</span> <span class="n">treemeasure</span><span class="o">.</span><span class="n">sackin_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.treeness">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.treeness">[docs]</a>
    <span class="k">def</span> <span class="nf">treeness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Use &#39;dendropy.calculate.treemeasure.treeness()&#39;.&quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">preamble</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: Unary statistics on trees are now&quot;</span>
                <span class="s2">&quot; implemented in the &#39;dendropy.calculate.treemeasure&#39; module.&quot;</span>
            <span class="p">),</span>
            <span class="n">old_construct</span><span class="o">=</span><span class="s2">&quot;tree.treeness()&quot;</span><span class="p">,</span>
            <span class="n">new_construct</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;from dendropy.calculate import treemeasure</span><span class="se">\n</span><span class="s2">treemeasure.treeness(tree)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">treemeasure</span>

        <span class="k">return</span> <span class="n">treemeasure</span><span class="o">.</span><span class="n">treeness</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.is_compatible_with_bipartition">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.is_compatible_with_bipartition">[docs]</a>
    <span class="k">def</span> <span class="nf">is_compatible_with_bipartition</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">bipartition</span><span class="p">,</span> <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if the |Bipartition| ``bipartition`` is compatible</span>
<span class="sd">        with all bipartitions of this tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bipartitions_updated</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">is_compatible_with</span><span class="p">(</span><span class="n">bipartition</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span></div>


    <span class="k">def</span> <span class="nf">is_compatible_with_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="Tree.find_missing_splits">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.find_missing_splits">[docs]</a>
    <span class="k">def</span> <span class="nf">find_missing_splits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tree</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Use &#39;dendropy.treecompare.find_missing_bipartitions()&#39;.&quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">preamble</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: Statistics comparing two trees are now&quot;</span>
                <span class="s2">&quot; implemented in the &#39;dendropy.calculate.treecompare&#39; module.&quot;</span>
            <span class="p">),</span>
            <span class="n">old_construct</span><span class="o">=</span><span class="s2">&quot;tree1.find_missing_splits(tree2)&quot;</span><span class="p">,</span>
            <span class="n">new_construct</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;from dendropy.calculate import&quot;</span>
                <span class="s2">&quot; treecompare</span><span class="se">\n</span><span class="s2">treecompare.find_missing_bipartitions(tree1, tree2)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">treecompare</span>

        <span class="k">return</span> <span class="n">treecompare</span><span class="o">.</span><span class="n">find_missing_splits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tree</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.symmetric_difference">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.symmetric_difference">[docs]</a>
    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tree</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Use &#39;dendropy.treecompare.symmetric_difference()&#39;.&quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">preamble</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: Statistics comparing two trees are now&quot;</span>
                <span class="s2">&quot; implemented in the &#39;dendropy.calculate.treecompare&#39; module.&quot;</span>
            <span class="p">),</span>
            <span class="n">old_construct</span><span class="o">=</span><span class="s2">&quot;tree1.symmetric_difference(tree2)&quot;</span><span class="p">,</span>
            <span class="n">new_construct</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;from dendropy.calculate import&quot;</span>
                <span class="s2">&quot; treecompare</span><span class="se">\n</span><span class="s2">treecompare.symmetric_difference(tree1, tree2)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">treecompare</span>

        <span class="k">return</span> <span class="n">treecompare</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tree</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.false_positives_and_negatives">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.false_positives_and_negatives">[docs]</a>
    <span class="k">def</span> <span class="nf">false_positives_and_negatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tree</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Use &#39;dendropy.treecompare.false_positives_and_negatives()&#39;.&quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">preamble</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: Statistics comparing two trees are now&quot;</span>
                <span class="s2">&quot; implemented in the &#39;dendropy.calculate.treecompare&#39; module.&quot;</span>
            <span class="p">),</span>
            <span class="n">old_construct</span><span class="o">=</span><span class="s2">&quot;tree1.false_positives_and_negatives(tree2)&quot;</span><span class="p">,</span>
            <span class="n">new_construct</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;from dendropy.calculate import&quot;</span>
                <span class="s2">&quot; treecompare</span><span class="se">\n</span><span class="s2">treecompare.false_positives_and_negatives(tree1, tree2)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">treecompare</span>

        <span class="k">return</span> <span class="n">treecompare</span><span class="o">.</span><span class="n">false_positives_and_negatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tree</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.robinson_foulds_distance">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.robinson_foulds_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">robinson_foulds_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tree</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Use &#39;dendropy.treecompare.weighted_robinson_foulds_distance()&#39;.&quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">preamble</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: Statistics comparing two trees are now&quot;</span>
                <span class="s2">&quot; implemented in the &#39;dendropy.calculate.treecompare&#39; module, and this&quot;</span>
                <span class="s2">&quot; method&#39;s functionality is available through the&quot;</span>
                <span class="s2">&quot; &#39;weighted_robinson_foulds_distance()&#39; function. For the *unweighted*&quot;</span>
                <span class="s2">&quot; RF distance, see&quot;</span>
                <span class="s2">&quot; &#39;dendropy.calculate.treecompare.symmetric_difference()&#39;.&quot;</span>
            <span class="p">),</span>
            <span class="n">old_construct</span><span class="o">=</span><span class="s2">&quot;tree1.robinson_foulds_distance(tree2)&quot;</span><span class="p">,</span>
            <span class="n">new_construct</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;from dendropy.calculate import&quot;</span>
                <span class="s2">&quot; treecompare</span><span class="se">\n</span><span class="s2">treecompare.weighted_robinson_foulds_distance(tree1,&quot;</span>
                <span class="s2">&quot; tree2)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">treecompare</span>

        <span class="k">return</span> <span class="n">treecompare</span><span class="o">.</span><span class="n">weighted_robinson_foulds_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tree</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.euclidean_distance">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.euclidean_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tree</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;DEPRECATED: Use &#39;dendropy.treecompare.euclidean_distance()&#39;.&quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">preamble</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated since DendroPy 4: Statistics comparing two trees are now&quot;</span>
                <span class="s2">&quot; implemented in the &#39;dendropy.calculate.treecompare&#39; module.&quot;</span>
            <span class="p">),</span>
            <span class="n">old_construct</span><span class="o">=</span><span class="s2">&quot;tree1.euclidean_distance(tree2)&quot;</span><span class="p">,</span>
            <span class="n">new_construct</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;from dendropy.calculate import&quot;</span>
                <span class="s2">&quot; treecompare</span><span class="se">\n</span><span class="s2">treecompare.euclidean_distance(tree1, tree2)&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">treecompare</span>

        <span class="k">return</span> <span class="n">treecompare</span><span class="o">.</span><span class="n">euclidean_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tree</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.strip_comments">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.strip_comments">[docs]</a>
    <span class="k">def</span> <span class="nf">strip_comments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove comments from tree/nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Tree.__str__">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.__str__">[docs]</a>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Dump Newick string.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_string</span><span class="p">(</span><span class="s2">&quot;newick&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> object at </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

<div class="viewcode-block" id="Tree.description">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.description">[docs]</a>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">itemize</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns description of object, up to level ``depth``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">output_strio</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot; (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot; (</span><span class="si">%s</span><span class="s2">: &#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
        <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">Tree object at </span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">itemize</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="n">label</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">newick_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_newick_string</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">newick_str</span><span class="p">:</span>
                <span class="n">newick_str</span> <span class="o">=</span> <span class="s2">&quot;()&quot;</span>
            <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">newick_str</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">num_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">nd</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">()])</span>
                <span class="n">num_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">ed</span> <span class="k">for</span> <span class="n">ed</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_edge_iter</span><span class="p">()])</span>
                <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;: </span><span class="si">%d</span><span class="s2"> Nodes, </span><span class="si">%d</span><span class="s2"> Edges&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">num_edges</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">[Taxon Set]</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">description</span><span class="p">(</span>
                        <span class="n">depth</span><span class="o">=</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">indent</span><span class="o">=</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
                        <span class="n">itemize</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                        <span class="n">output</span><span class="o">=</span><span class="n">output_strio</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">[Tree]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)))</span>
                <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">newick_str</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">[Nodes]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">()):</span>
                        <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">nd</span><span class="o">.</span><span class="n">description</span><span class="p">(</span>
                            <span class="n">depth</span><span class="o">=</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span>
                            <span class="n">indent</span><span class="o">=</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
                            <span class="n">itemize</span><span class="o">=</span><span class="s2">&quot;[</span><span class="si">%d</span><span class="s2">] &quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                            <span class="n">output</span><span class="o">=</span><span class="n">output_strio</span><span class="p">,</span>
                            <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">[Edges]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ed</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preorder_edge_iter</span><span class="p">()):</span>
                        <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">ed</span><span class="o">.</span><span class="n">description</span><span class="p">(</span>
                            <span class="n">depth</span><span class="o">=</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span>
                            <span class="n">indent</span><span class="o">=</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
                            <span class="n">itemize</span><span class="o">=</span><span class="s2">&quot;[</span><span class="si">%d</span><span class="s2">] &quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                            <span class="n">output</span><span class="o">=</span><span class="n">output_strio</span><span class="p">,</span>
                            <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">,</span>
                        <span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">output_strio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="Tree.as_python_source">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.as_python_source">[docs]</a>
    <span class="k">def</span> <span class="nf">as_python_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_obj_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tree_args</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns string that will rebuild this tree in Python.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">tree_obj_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tree_obj_name</span> <span class="o">=</span> <span class="s2">&quot;tree_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
        <span class="k">if</span> <span class="n">tree_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tree_args</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tree_args</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">tree_args</span>
        <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> = dendropy.Tree(label=</span><span class="si">%s%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tree_obj_name</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">tree_args</span><span class="p">))</span>

        <span class="n">taxon_obj_namer</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;tax_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="n">tobj_name</span> <span class="o">=</span> <span class="n">taxon_obj_namer</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">taxon</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="n">taxon</span><span class="o">.</span><span class="n">label</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
            <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">.taxon_namespace.require_taxon(label=</span><span class="si">%s</span><span class="s2">)&quot;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">tobj_name</span><span class="p">,</span>
                    <span class="n">tree_obj_name</span><span class="p">,</span>
                    <span class="n">label</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">node_obj_namer</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;nd_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="p">:</span>
                    <span class="n">nn</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.seed_node&quot;</span> <span class="o">%</span> <span class="n">tree_obj_name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nn</span> <span class="o">=</span> <span class="n">node_obj_namer</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ct</span> <span class="o">=</span> <span class="n">taxon_obj_namer</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">taxon</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ct</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
                <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">.new_child(label=</span><span class="si">%s</span><span class="s2">, taxon=</span><span class="si">%s</span><span class="s2">, edge_length=</span><span class="si">%s</span><span class="s2">)&quot;</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="n">node_obj_namer</span><span class="p">(</span><span class="n">child</span><span class="p">),</span>
                        <span class="n">nn</span><span class="p">,</span>
                        <span class="n">label</span><span class="p">,</span>
                        <span class="n">ct</span><span class="p">,</span>
                        <span class="n">child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.as_ascii_plot">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.as_ascii_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">as_ascii_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string representation a graphic of this tree using ASCII</span>
<span class="sd">        characters. See |AsciiTreePlot| for details on arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ap</span> <span class="o">=</span> <span class="n">AsciiTreePlot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ap</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.write_ascii_plot">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.write_ascii_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">write_ascii_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes an ASCII text graphic of this tree to ``stream``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_ascii_plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>


<div class="viewcode-block" id="Tree.print_plot">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.print_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">print_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes an ASCII text graphic of this tree to standard output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">sys</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write_ascii_plot</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.write_as_dot">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.Tree.write_as_dot">[docs]</a>
    <span class="k">def</span> <span class="nf">write_as_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the tree to ``out`` as a DOT formatted digraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;digraph G {</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nd_id_to_dot_nd</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">nd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">()):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">_format_node</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nd</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;root </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">label</span>
            <span class="n">dot_nd</span> <span class="o">=</span> <span class="s2">&quot;n</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; </span><span class="si">%s</span><span class="s1">  [label=&quot;</span><span class="si">%s</span><span class="s1">&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dot_nd</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
            <span class="n">nd_id_to_dot_nd</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot_nd</span>
        <span class="k">for</span> <span class="n">nd</span><span class="p">,</span> <span class="n">dot_nd</span> <span class="ow">in</span> <span class="n">nd_id_to_dot_nd</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span>
                <span class="n">par_dot_nd</span> <span class="o">=</span> <span class="n">nd_id_to_dot_nd</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">tail_node</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_format_edge</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39; </span><span class="si">%s</span><span class="s1"> -&gt; </span><span class="si">%s</span><span class="s1"> [label=&quot;</span><span class="si">%s</span><span class="s1">&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">par_dot_nd</span><span class="p">,</span> <span class="n">dot_nd</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_assign_node_labels_from_taxon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span>

    <span class="k">def</span> <span class="nf">_get_indented_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_indented_form</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_write_indented_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bipartitions&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">_write_indented_form</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_debug_check_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">logging</span><span class="o">,</span> <span class="nn">inspect</span>

        <span class="k">if</span> <span class="n">logger_obj</span> <span class="ow">and</span> <span class="n">logger_obj</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_tree_is_valid</span><span class="p">(</span><span class="n">logger_obj</span><span class="o">=</span><span class="n">logger_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">calling_frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_back</span>
                <span class="n">co</span> <span class="o">=</span> <span class="n">calling_frame</span><span class="o">.</span><span class="n">f_code</span>
                <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Called from file </span><span class="si">%s</span><span class="s2">, line </span><span class="si">%d</span><span class="s2">, in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">co_filename</span><span class="p">,</span>
                    <span class="n">calling_frame</span><span class="o">.</span><span class="n">f_lineno</span><span class="p">,</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">co_name</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">_LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="n">_LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_indented_form</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_tree_is_valid</span><span class="p">(</span><span class="n">logger_obj</span><span class="o">=</span><span class="n">logger_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_debug_tree_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs sanity-checks of the tree data structure.</span>

<span class="sd">        kwargs:</span>
<span class="sd">            ``check_bipartitions`` if True specifies that the bipartition attributes are checked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_bipartitions</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;check_bipartitions&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">unique_bipartition_edge_mapping</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;unique_bipartition_edge_mapping&quot;</span><span class="p">,</span> <span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="k">if</span> <span class="n">check_bipartitions</span><span class="p">:</span>
            <span class="n">taxa_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">curr_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">curr_node</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is seed node, but has non-&#39;None&#39; parent node: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">curr_node</span><span class="p">,</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">_parent_node</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">curr_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is seed node, but edge has non-&#39;None&#39; tail node: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">curr_node</span><span class="p">,</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">_parent_node</span>
        <span class="p">)</span>
        <span class="n">ancestors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">siblings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">curr_node</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">curr_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">,</span> <span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> seen multiple times&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">curr_node</span>
            <span class="p">)</span>
            <span class="n">curr_edge</span> <span class="o">=</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">edge</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">curr_edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span>
            <span class="p">),</span> <span class="s2">&quot;Edge of </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, is also an edge of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">curr_node</span><span class="p">,</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">edge</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">curr_edge</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">curr_edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_node</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_edge</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">curr_edge</span><span class="o">.</span><span class="n">head_node</span> <span class="ow">is</span> <span class="n">curr_node</span>
            <span class="p">),</span> <span class="s2">&quot;Head node of edge of </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, is </span><span class="si">{}</span><span class="s2">, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">curr_node</span><span class="p">,</span> <span class="n">curr_edge</span><span class="p">,</span> <span class="n">curr_edge</span><span class="o">.</span><span class="n">head_node</span><span class="p">,</span> <span class="n">curr_node</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">curr_edge</span><span class="o">.</span><span class="n">tail_node</span> <span class="ow">is</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">_parent_node</span>
            <span class="p">),</span> <span class="s2">&quot;Tail node of edge of </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, is </span><span class="si">{}</span><span class="s2">, but parent node is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">curr_node</span><span class="p">,</span> <span class="n">curr_edge</span><span class="p">,</span> <span class="n">curr_edge</span><span class="o">.</span><span class="n">tail_node</span><span class="p">,</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">_parent_node</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">check_bipartitions</span><span class="p">:</span>
                <span class="n">cm</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">curr_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span> <span class="o">|</span> <span class="n">taxa_mask</span>
                <span class="p">)</span> <span class="o">==</span> <span class="n">taxa_mask</span><span class="p">,</span> <span class="s2">&quot;Bipartition mask error: </span><span class="si">{}</span><span class="s2"> | </span><span class="si">{}</span><span class="s2"> == </span><span class="si">{}</span><span class="s2"> (expecting: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">curr_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_as_bitstring</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_as_bitstring</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">bitmask_as_bitstring</span><span class="p">(</span>
                        <span class="n">curr_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span> <span class="o">|</span> <span class="n">taxa_mask</span>
                    <span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_as_bitstring</span><span class="p">(),</span>
                <span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">_child_nodes</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span>
                        <span class="n">child</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="n">curr_node</span>
                    <span class="p">),</span> <span class="s2">&quot;Child of </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, has </span><span class="si">{}</span><span class="s2"> as parent&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">curr_node</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">_parent_node</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">check_bipartitions</span><span class="p">:</span>
                        <span class="n">cm</span> <span class="o">|=</span> <span class="n">child</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span>
            <span class="k">elif</span> <span class="n">check_bipartitions</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
                    <span class="s2">&quot;Cannot check bipartitions: </span><span class="si">{}</span><span class="s2"> is a leaf node, but its &#39;taxon&#39;&quot;</span>
                    <span class="s2">&quot; attribute is &#39;None&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">cm</span> <span class="o">=</span> <span class="n">taxon_namespace</span><span class="o">.</span><span class="n">taxon_bitmask</span><span class="p">(</span><span class="n">curr_node</span><span class="o">.</span><span class="n">taxon</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check_bipartitions</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">cm</span> <span class="o">&amp;</span> <span class="n">taxa_mask</span>
                <span class="p">)</span> <span class="o">==</span> <span class="n">curr_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">_leafset_bitmask</span><span class="p">,</span> <span class="p">(</span>
                    <span class="s2">&quot;Bipartition leafset bitmask error: </span><span class="si">{}</span><span class="s2"> (taxa: </span><span class="si">{}</span><span class="s2">, leafset: </span><span class="si">{}</span><span class="s2">)&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">curr_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">bitmask_as_bitstring</span><span class="p">(</span><span class="n">cm</span><span class="p">),</span>
                        <span class="n">curr_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">bitmask_as_bitstring</span><span class="p">(</span><span class="n">taxa_mask</span><span class="p">),</span>
                        <span class="n">curr_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_as_bitstring</span><span class="p">(),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">unique_bipartition_edge_mapping</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_edge_map</span><span class="p">[</span><span class="n">curr_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="p">]</span> <span class="ow">is</span> <span class="n">curr_edge</span>
                    <span class="p">),</span> <span class="p">(</span>
                        <span class="s2">&quot;Expecting edge </span><span class="si">{}</span><span class="s2"> for bipartition </span><span class="si">{}</span><span class="s2">, but instead found </span><span class="si">{}</span><span class="s2">&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">curr_edge</span><span class="p">,</span>
                            <span class="n">curr_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_edge_map</span><span class="p">[</span><span class="n">curr_edge</span><span class="o">.</span><span class="n">bipartition</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="n">curr_node</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">_preorder_list_manip</span><span class="p">(</span><span class="n">siblings</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_bipartitions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_edge_map</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2"> =&gt; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">tail_node</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">head_node</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">unique_bipartition_edge_mapping</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">e</span><span class="o">.</span><span class="n">bipartition</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_as_newick_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This returns the Node as a NEWICK statement according to the given</span>
<span class="sd">        formatting rules. This should be used for debugging purposes only.</span>
<span class="sd">        For production purposes, use the the full-fledged &#39;as_string()&#39;</span>
<span class="sd">        method of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">_as_newick_string</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_print_newick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method to newick string representation of this tree</span>
<span class="sd">        to the standard output stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">sys</span>

        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_as_newick_string</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_newick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This returns the Node as a NEWICK statement according to the given</span>
<span class="sd">        formatting rules. This should be used for debugging purposes only.  For</span>
<span class="sd">        production purposes, use the the full-fledged &#39;write_to_stream()&#39;</span>
<span class="sd">        method of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">_write_newick</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_plot_bipartitions_on_tree</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">show_splits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_leafsets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_taxon_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bipartitions_updated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_print_node</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">show_splits</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_bitstring</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">show_leafsets</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_as_bitstring</span><span class="p">())</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">show_taxon_labels</span> <span class="ow">and</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s2">&quot; (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ascii_plot</span><span class="p">(</span>
            <span class="n">show_internal_node_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">node_label_compose_fn</span><span class="o">=</span><span class="n">_print_node</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="AsciiTreePlot">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.AsciiTreePlot">[docs]</a>
<span class="k">class</span> <span class="nc">AsciiTreePlot</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="AsciiTreePlot.NullEdgeLengthError">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.AsciiTreePlot.NullEdgeLengthError">[docs]</a>
    <span class="k">class</span> <span class="nc">NullEdgeLengthError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="ne">ValueError</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Keyword Arguments</span>
<span class="sd">        -----------------</span>

<span class="sd">        plot_metric : str</span>
<span class="sd">            A string which specifies how branches should be scaled, one of:</span>
<span class="sd">            &#39;age&#39; (distance from tips), &#39;depth&#39; (distance from root),</span>
<span class="sd">            &#39;level&#39; (number of branches from root) or &#39;length&#39; (edge</span>
<span class="sd">            length/weights).</span>
<span class="sd">        show_internal_node_labels : bool</span>
<span class="sd">            Whether or not to write out internal node labels.</span>
<span class="sd">        leaf_spacing_factor : int</span>
<span class="sd">            Positive integer: number of rows between each leaf.</span>
<span class="sd">        width : int</span>
<span class="sd">            Force a particular display width, in terms of number of columns.</span>
<span class="sd">        node_label_compose_fn : function object</span>
<span class="sd">            A function that takes a Node object as an argument and returns</span>
<span class="sd">            the string to be used to display it.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_metric</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;plot_metric&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show_external_node_labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;show_external_node_labels&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show_internal_node_labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;show_internal_node_labels&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leaf_spacing_factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;leaf_spacing_factor&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_width</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;display_width&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>  <span class="c1"># legacy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compose_node</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;node_label_compose_fn&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compose_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_compose_node</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unrecognized or unsupported arguments: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">default_compose_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;@&quot;</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_row</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_col</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_leaf_row</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_label_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_calc_node_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_metric</span> <span class="o">==</span> <span class="s2">&quot;age&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_metric</span> <span class="o">==</span> <span class="s2">&quot;depth&quot;</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
                <span class="n">cnds</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_metric</span> <span class="o">==</span> <span class="s2">&quot;depth&quot;</span><span class="p">:</span>  <span class="c1"># &#39;number of branchings from tip&#39;</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cnds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">curr_node_offset</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">depths</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cnds</span><span class="p">]</span>
                        <span class="n">curr_node_offset</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">depths</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_metric</span> <span class="o">==</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span>  <span class="c1"># &#39;sum of edge weights from tip&#39;</span>
                    <span class="c1"># note: no enforcement of ultrametricity!</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cnds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">curr_node_offset</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">cnds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">curr_node_offset</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">cnds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">cnds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                            <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Unrecognized plot metric &#39;</span><span class="si">%s</span><span class="s2">&#39; (must be one of: &#39;age&#39;, &#39;depth&#39;,&quot;</span>
                        <span class="s2">&quot; &#39;level&#39;, or &#39;length&#39;)&quot;</span>
                        <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_metric</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_node_offset</span>
            <span class="n">flipped_origin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="n">flipped_origin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">preorder_node_iter</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_metric</span> <span class="o">==</span> <span class="s2">&quot;level&quot;</span><span class="p">:</span>  <span class="c1"># &#39;number of branchings from root&#39;</span>
                    <span class="n">curr_edge_len</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_metric</span> <span class="o">==</span> <span class="s2">&quot;length&quot;</span><span class="p">:</span>  <span class="c1"># &#39;sum of edge weights from root&#39;</span>
                    <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">curr_edge_len</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">curr_edge_len</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Unrecognized plot metric &#39;</span><span class="si">%s</span><span class="s2">&#39; (must be one of: &#39;age&#39;, &#39;depth&#39;,&quot;</span>
                        <span class="s2">&quot; &#39;level&#39;, or &#39;length&#39;)&quot;</span>
                        <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_metric</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_edge_len</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">curr_edge_len</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">nd</span><span class="o">.</span><span class="n">_parent_node</span><span class="p">]</span>
                    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
        <span class="n">dest</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_label_for_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_label_map</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_internal_node_labels</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">_child_nodes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_external_node_labels</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_label_map</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
            <span class="k">return</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">display_width</span> <span class="o">=</span> <span class="n">terminal</span><span class="o">.</span><span class="n">terminal_width</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">display_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_width</span>
        <span class="n">max_label_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_label_for_node</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">leaf_node_iter</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">max_label_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_label_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># effective_display_width = display_width - max_label_len - len(tree.internal_nodes) - 1</span>
        <span class="n">effective_display_width</span> <span class="o">=</span> <span class="n">display_width</span> <span class="o">-</span> <span class="n">max_label_len</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_node_offsets</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">leaf_node_iter</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="n">max_width</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">widths</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">max_width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AsciiTreePlot</span><span class="o">.</span><span class="n">NullEdgeLengthError</span><span class="p">(</span>
                <span class="s2">&quot;Tree cannot be plotted under metric &#39;</span><span class="si">%s</span><span class="s2">&#39; due to zero or null edge&quot;</span>
                <span class="s2">&quot; lengths: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_metric</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">_as_newick_string</span><span class="p">())</span>
            <span class="p">)</span>
        <span class="n">edge_scale_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">effective_display_width</span><span class="p">)</span> <span class="o">/</span> <span class="n">max_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_plot</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">seed_node</span><span class="p">,</span> <span class="n">edge_scale_factor</span><span class="o">=</span><span class="n">edge_scale_factor</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">())</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_spacing_factor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot; &quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">display_width</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_node</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">seed_node</span><span class="p">)</span>
        <span class="n">display</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">display</span>

<div class="viewcode-block" id="AsciiTreePlot.calc_plot">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.AsciiTreePlot.calc_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_scale_factor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First pass through tree, post-order traversal to calculate</span>
<span class="sd">        coordinates of each node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">child_nodes</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">child_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">child_nodes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calc_plot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edge_scale_factor</span><span class="p">)</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">child_nodes</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">((</span><span class="nb">max</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_leaf_row</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_leaf_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_leaf_row</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_spacing_factor</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">*</span> <span class="n">edge_scale_factor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">*</span> <span class="n">edge_scale_factor</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">draw_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">start_col</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">label</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">start_col</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">row</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">start_col</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<div class="viewcode-block" id="AsciiTreePlot.draw_node">
<a class="viewcode-back" href="../../../../library/treemodel.html#dendropy.datamodel.treemodel.AsciiTreePlot.draw_node">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Second pass through tree, plotting nodes onto given self.grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">child_nodes</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">child_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">child_nodes</span><span class="p">):</span>
                <span class="n">start_row</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">child_node</span><span class="p">]])</span>
                <span class="n">end_row</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">child_node</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">child_node</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span>
                    <span class="n">start_row</span> <span class="o">=</span> <span class="n">start_row</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">edge_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">child_node</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">child_node</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span>
                    <span class="n">edge_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">child_node</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">child_node</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
                    <span class="n">edge_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">child_node</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">draw_node</span><span class="p">(</span><span class="n">child_node</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">child_node</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">edge_row</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_row</span><span class="p">,</span> <span class="n">end_row</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span>
            <span class="n">label</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_internal_node_labels</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_for_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">draw_internal_text</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">node</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_for_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">draw_label</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_row</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_col</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">draw_internal_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">letter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                <span class="n">row</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">letter</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div style="text-align: center; padding-top: 20px; padding-bottom: 5px; width: 100%;">
    <a href="../../../../index.html"><img src="../../../../_static/dendropy_logo.png" /></a>
</div><div style="clear:both; width: 100%; height:1px;"></div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div>
    <!-- Documentation -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Documentation</h3>
        <ul>
            <li><a href="../../../../primer/downloading.html">Downloading and Installing DendroPy</a></li>
            <li><a href="../../../../primer/index.html">The DendroPy Primer</a></li>
            <li><a href="../../../../library/index.html">Library API Reference</a></li>
            <li>
                <a href="../../../../schemas/index.html">Schemas</a>
                <ul>
                    <li><a href="../../../../schemas/fasta.html">FASTA</a></li>
                    <li><a href="../../../../schemas/newick.html">Newick</a></li>
                    <li><a href="../../../../schemas/nexml.html">NeXML</a></li>
                    <li><a href="../../../../schemas/nexus.html">Nexus</a></li>
                    <li><a href="../../../../schemas/phylip.html">PHYLIP</a></li>
                </ul>
            </li>
            <li>
                <a href="../../../../programs/index.html">Programs</a>
                <ul>
                    <li><a href="../../../../programs/sumtrees.html">SumTrees</a></li>
                </ul>
            </li>
            <li><a href="../../../../glossary.html">Glossary and Terminological Reference</a></li>
            <li><a href="../../../../developer.html">Developer Guide</a></li>
            <li><a href="../../../../planning.html">Ongoing Development</a></li>
            <li><a href="../../../../changes.html">Change History</a></li>
        </ul>
    </div>

    <!-- Downloads -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Obtaining</h3>
        <ul>
            <li><a target="_blank" href="http://pypi.python.org/pypi/DendroPy">Install from the Python Package Index</a></li>
            <li><a target="_blank" href="http://pypi.python.org/packages/source/D/DendroPy/DendroPy-5.0.2.tar.gz">Download the Source Code Archive</a></li>
            <li><a target="_blank" href="http://github.com/jeetsukumaran/DendroPy">Clone the Source Code Repository</a></li>
        </ul>
    </div>

    <!-- Discussions -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Discussion</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot; DendroPy Users&quot; </a>group to follow and participate in discussion, troubleshooting, help, information, suggestions, etc. on the usage and development of the DendroPy phylogenetic computing library.</p>
            <form action="http://groups.google.com/group/dendropy-users/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot;dendropy-users&quot;</a> group, or click <a href="http://groups.google.com/group/dendropy-users?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Announcements -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Announcements</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; DendroPy Announcements&quot; </a>group to receive announcements of new releases, updates, changes and other news of interest to DendroPy users and developers.</p>
            <form action="http://groups.google.com/group/dendropy-announce/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; dendropy-announce&quot; </a>group, or click <a href="http://groups.google.com/group/dendropy-announce?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Development -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative; padding-bottom: 15px; margin-bottom:5px;">
        <h3><span style="text-align: left"><a href="https://github.com/jeetsukumaran/DendroPy/">Development</a></span><a href="https://github.com/jeetsukumaran/DendroPy/"><span style="position: absolute; right: 0; top: 10px "><img src="../../../../_static/Octocat.png" height="30px" alt="GitHub" /></span></a></h3>
        <div style="margin-top: 15px;">
            <!-- <a href="https://github.com/jeetsukumaran/DendroPy/issues">Issues</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/subscription">Watch</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/fork">Fork</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/stargazers">Star</a> &bull; <a href="https://github.com/jeetsukumaran/">Follow</a> -->
            <ul>
                <li>                <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/issues"><code>Issues</code></a></span> <span style="font-style: italic; font-size:80%;"> - Report bugs or request features</span></li>
                <li>     <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/subscription"><code>&nbsp;Watch</code></a></span> <span style="font-style: italic; font-size:80%;"> - Follow development activity</span></li>
                <li>        <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/fork"><code>&nbsp;&nbsp;Fork</code></a></span> <span style="font-style: italic; font-size:80%;"> - Contribute and collaborate</span></li>
                <li>  <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/stargazers"><code>&nbsp;&nbsp;Star</code></a></span> <span style="font-style: italic; font-size:80%;"> - Throw some glitter, add some glamour</span></li>
        </div>
    </div>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">DendroPy 5.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.datamodel.treemodel._tree</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2009-2024, Jeet Sukumaran and Mark T. Holder.
    </div>
  </body>
</html>