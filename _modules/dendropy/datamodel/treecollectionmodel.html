<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dendropy.datamodel.treecollectionmodel &#8212; DendroPy 5.0.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/rtd.css?v=cedc6a2f" />
    
    <script src="../../../_static/documentation_options.js?v=967d581c"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DendroPy 5.0.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.datamodel.treecollectionmodel</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for dendropy.datamodel.treecollectionmodel</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1">##############################################################################</span>
<span class="c1">##  DendroPy Phylogenetic Computing Library.</span>
<span class="c1">##</span>
<span class="c1">##  Copyright 2010-2015 Jeet Sukumaran and Mark T. Holder.</span>
<span class="c1">##  All rights reserved.</span>
<span class="c1">##</span>
<span class="c1">##  See &quot;LICENSE.rst&quot; for terms and conditions of usage.</span>
<span class="c1">##</span>
<span class="c1">##  If you use this work or any portion thereof in published work,</span>
<span class="c1">##  please cite it as:</span>
<span class="c1">##</span>
<span class="c1">##     Sukumaran, J. and M. T. Holder. 2010. DendroPy: a Python library</span>
<span class="c1">##     for phylogenetic computing. Bioinformatics 26: 1569-1571.</span>
<span class="c1">##</span>
<span class="c1">##############################################################################</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module handles the core definition of classes that model collections of</span>
<span class="sd">trees.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">error</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">bitprocessing</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">deprecate</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">statistics</span>
<span class="kn">from</span> <span class="nn">dendropy.datamodel</span> <span class="kn">import</span> <span class="n">basemodel</span>
<span class="kn">from</span> <span class="nn">dendropy.datamodel</span> <span class="kn">import</span> <span class="n">taxonmodel</span>
<span class="kn">from</span> <span class="nn">dendropy.datamodel</span> <span class="kn">import</span> <span class="n">treemodel</span>
<span class="kn">from</span> <span class="nn">dendropy</span> <span class="kn">import</span> <span class="n">dataio</span>

<span class="c1">##############################################################################</span>
<span class="c1">### TreeList</span>

<div class="viewcode-block" id="TreeList">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList">[docs]</a>
<span class="k">class</span> <span class="nc">TreeList</span><span class="p">(</span>
        <span class="n">taxonmodel</span><span class="o">.</span><span class="n">TaxonNamespaceAssociated</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">Annotable</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">Deserializable</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">MultiReadable</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">Serializable</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A collection of |Tree| objects, all referencing the same &quot;universe&quot; of</span>
<span class="sd">    opeational taxonomic unit concepts through the same |TaxonNamespace|</span>
<span class="sd">    object reference.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_parse_and_create_from_stream</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">stream</span><span class="p">,</span>
            <span class="n">schema</span><span class="p">,</span>
            <span class="n">collection_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">tree_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a new |TreeList| object and populates it with trees from</span>
<span class="sd">        file-like object ``stream``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        *All* operational taxonomic unit concepts in the data source will be included</span>
<span class="sd">        in the |TaxonNamespace| object associated with the new</span>
<span class="sd">        |TreeList| object and its contained |Tree| objects, even those</span>
<span class="sd">        not associated with trees or the particular trees being retrieved.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        stream : file or file-like object</span>
<span class="sd">            Source of data.</span>

<span class="sd">        schema : string</span>
<span class="sd">            Identifier of format of data in ``stream``</span>

<span class="sd">        collection_offset : integer or None</span>
<span class="sd">            0-based index indicating collection of trees to parse. If |None|,</span>
<span class="sd">            then all tree collections are retrieved, with each distinct</span>
<span class="sd">            collection parsed into a separate |TreeList| object. If the</span>
<span class="sd">            tree colleciton offset index is equal or greater than the number of</span>
<span class="sd">            tree collections in the data source, then IndexError is raised.</span>
<span class="sd">            Negative offsets work like negative list indexes; e.g., a</span>
<span class="sd">            ``collection_offset`` of -1 means to read the last collection of</span>
<span class="sd">            trees in the data source. For data formats that do not support the</span>
<span class="sd">            concept of distinct tree collections (e.g. NEWICK) are considered</span>
<span class="sd">            single-collection data source (i.e, the only acceptable</span>
<span class="sd">            ``collection_offset`` values are -1 or 0).</span>

<span class="sd">        tree_offset : integer or None</span>
<span class="sd">            0-based index indicating particular tree within a particular</span>
<span class="sd">            collection of trees at which to begin reading.  If not specified or</span>
<span class="sd">            |None| (default), then all trees are parsed.  Otherwise, must be an</span>
<span class="sd">            integer value up the length of the collection minus 1.  A positive</span>
<span class="sd">            offset indicates the number of trees in the collection to skip;</span>
<span class="sd">            e.g. a ``tree_offset`` of 20 means to skip the first 20 trees in the</span>
<span class="sd">            collection.  Negative offsets work like negative list indexes;</span>
<span class="sd">            e.g., a ``tree_offset`` value of -10 means to retrieve the last 10</span>
<span class="sd">            trees in the collection.  If the tree offset index is equal or</span>
<span class="sd">            greater than the number of trees in the collection, then IndexError</span>
<span class="sd">            is raised. Requires that a particular tree collection has been</span>
<span class="sd">            identified using the ``tree_collection_offset`` parameter: if</span>
<span class="sd">            ``tree_collection_offset`` is not specified, a TypeError is raised.</span>

<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            Arguments to customize parsing, instantiation, processing, and</span>
<span class="sd">            accession of |Tree| objects read from the data source, including</span>
<span class="sd">            schema- or format-specific handling.</span>

<span class="sd">            The following optional keyword arguments are recognized and handled</span>
<span class="sd">            by this function:</span>

<span class="sd">                * ``label`` Specifies the label or description of the new</span>
<span class="sd">                  |TreeList|.</span>
<span class="sd">                * ``taxon_namespace`` specifies the |TaxonNamespace|</span>
<span class="sd">                   object to be attached to the new |TreeList| object.</span>
<span class="sd">                   Note that *all* operational taxonomic unit concepts in the</span>
<span class="sd">                   data source will be accessioned into the specified</span>
<span class="sd">                   |TaxonNamespace| instance. This includes the</span>
<span class="sd">                   operation taxonomic unit definitions associated with all</span>
<span class="sd">                   tree collections and character matrices in the data source.</span>
<span class="sd">                * ``tree_list`` : **SPECIAL** If passed a |TreeList| using</span>
<span class="sd">                  this keyword, then this instance is populated and returned</span>
<span class="sd">                  (instead of a new instance being created).</span>

<span class="sd">            All other keyword arguments are passed directly to |TreeList|.read()`.</span>
<span class="sd">            Other keyword arguments may be available, depending on the implementation</span>
<span class="sd">            of the reader specialized to handle ``schema`` formats.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Note that in most cases, even if ``collection_offset`` and ``tree_offset``</span>
<span class="sd">        are specified to restrict the trees returned, the *entire* data source</span>
<span class="sd">        is still parsed and processed. So this is not more efficient than</span>
<span class="sd">        reading all the trees and then manually-extracting them later; just</span>
<span class="sd">        more convenient. If you need just a single subset of trees from a data</span>
<span class="sd">        source, there is no gain in efficiency. If you need multiple trees or</span>
<span class="sd">        subsets of trees from the same data source, it would be much more</span>
<span class="sd">        efficient to read the entire data source, and extract trees as needed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A |TreeList| object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># these must be pulled before passing the kwargs</span>
        <span class="c1"># down to the reader</span>
        <span class="n">tree_list</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;tree_list&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">taxonmodel</span><span class="o">.</span><span class="n">process_kwargs_dict_for_taxon_namespace</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># get the reader</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">dataio</span><span class="o">.</span><span class="n">get_reader</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Accommodate an existing TreeList object being passed</span>
        <span class="k">if</span> <span class="n">tree_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tree_list</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">collection_offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tree_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">collection_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">collection_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if tree_offset is not None:</span>
            <span class="c1">#     raise TypeError(&quot;Cannot specify ``tree_offset`` without specifying ``collection_offset``&quot;)</span>
            <span class="c1"># coerce all tree products into this list</span>
            <span class="n">reader</span><span class="o">.</span><span class="n">read_tree_lists</span><span class="p">(</span>
                        <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span>
                        <span class="n">taxon_namespace_factory</span><span class="o">=</span><span class="n">tree_list</span><span class="o">.</span><span class="n">_taxon_namespace_pseudofactory</span><span class="p">,</span>
                        <span class="n">tree_list_factory</span><span class="o">=</span><span class="n">tree_list</span><span class="o">.</span><span class="n">_tree_list_pseudofactory</span><span class="p">,</span>
                        <span class="n">global_annotations_target</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tree_lists</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_tree_lists</span><span class="p">(</span>
                        <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span>
                        <span class="n">taxon_namespace_factory</span><span class="o">=</span><span class="n">tree_list</span><span class="o">.</span><span class="n">_taxon_namespace_pseudofactory</span><span class="p">,</span>
                        <span class="n">tree_list_factory</span><span class="o">=</span><span class="n">tree_list</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                        <span class="n">global_annotations_target</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="c1"># if collection_offset &lt; 0:</span>
            <span class="c1">#     raise IndexError(&quot;Collection offset out of range: {} (minimum valid tree offset = 0)&quot;.format(collection_offset))</span>
            <span class="k">if</span> <span class="n">collection_offset</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree_lists</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Collection offset out of range: </span><span class="si">{}</span><span class="s2"> (number of collections = </span><span class="si">{}</span><span class="s2">, maximum valid collection offset = </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">collection_offset</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree_lists</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree_lists</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">target_tree_list</span> <span class="o">=</span> <span class="n">tree_lists</span><span class="p">[</span><span class="n">collection_offset</span><span class="p">]</span>
            <span class="n">tree_list</span><span class="o">.</span><span class="n">copy_annotations_from</span><span class="p">(</span><span class="n">target_tree_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tree_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if tree_offset &lt; 0:</span>
                <span class="c1">#     raise IndexError(&quot;Tree offset out of range: {} (minimum offset = 0)&quot;.format(tree_offset))</span>
                <span class="k">if</span> <span class="n">tree_offset</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_tree_list</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Tree offset out of range: </span><span class="si">{}</span><span class="s2"> (number of trees in source = </span><span class="si">{}</span><span class="s2">, maximum valid tree offset = </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tree_offset</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_tree_list</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_tree_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">target_tree_list</span><span class="p">[</span><span class="n">tree_offset</span><span class="p">:]:</span>
                    <span class="n">tree_list</span><span class="o">.</span><span class="n">_trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">target_tree_list</span><span class="p">:</span>
                    <span class="n">tree_list</span><span class="o">.</span><span class="n">_trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tree_list</span>
        <span class="c1"># taxon_namespace = taxonmodel.process_kwargs_dict_for_taxon_namespace(kwargs, None)</span>
        <span class="c1"># label = kwargs.pop(&quot;label&quot;, None)</span>
        <span class="c1"># tree_list = cls(label=label,</span>
        <span class="c1">#         taxon_namespace=taxon_namespace)</span>
        <span class="c1"># tree_list.read(</span>
        <span class="c1">#         stream=stream,</span>
        <span class="c1">#         schema=schema,</span>
        <span class="c1">#         collection_offset=collection_offset,</span>
        <span class="c1">#         tree_offset=tree_offset,</span>
        <span class="c1">#         **kwargs)</span>
        <span class="c1"># return tree_list</span>

<div class="viewcode-block" id="TreeList.get">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.get">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate and return a *new* |TreeList| object from a data source.</span>

<span class="sd">        **Mandatory Source-Specification Keyword Argument (Exactly One Required):**</span>

<span class="sd">            - **file** (*file*) -- File or file-like object of data opened for reading.</span>
<span class="sd">            - **path** (*str*) -- Path to file of data.</span>
<span class="sd">            - **url** (*str*) -- URL of data.</span>
<span class="sd">            - **data** (*str*) -- Data given directly.</span>

<span class="sd">        **Mandatory Schema-Specification Keyword Argument:**</span>

<span class="sd">            - **schema** (*str*) -- Identifier of format of data given by the</span>
<span class="sd">              &quot;``file``&quot;, &quot;``path``&quot;, &quot;``data``&quot;, or &quot;``url``&quot; argument</span>
<span class="sd">              specified above: &quot;:doc:`newick &lt;/schemas/newick&gt;`&quot;, &quot;:doc:`nexus</span>
<span class="sd">              &lt;/schemas/nexus&gt;`&quot;, or &quot;:doc:`nexml &lt;/schemas/nexml&gt;`&quot;. See</span>
<span class="sd">              &quot;|Schemas|&quot; for more details.</span>

<span class="sd">        **Optional General Keyword Arguments:**</span>

<span class="sd">            - **label** (*str*) -- Name or identifier to be assigned to the new</span>
<span class="sd">              object; if not given, will be assigned the one specified in the</span>
<span class="sd">              data source, or |None| otherwise.</span>
<span class="sd">            - **taxon_namespace** (|TaxonNamespace|) -- The |TaxonNamespace|</span>
<span class="sd">              instance to use to :doc:`manage the taxon names &lt;/primer/taxa&gt;`.</span>
<span class="sd">              If not specified, a new one will be created.</span>
<span class="sd">            - **collection_offset** (*int*) -- 0-based index of tree block or</span>
<span class="sd">              collection in source to be parsed. If not specified then the</span>
<span class="sd">              first collection (offset = 0) is assumed.</span>
<span class="sd">            - **tree_offset** (*int*) -- 0-based index of first tree within the</span>
<span class="sd">              collection specified by ``collection_offset`` to be parsed (i.e.,</span>
<span class="sd">              skipping the first ``tree_offset`` trees). If not</span>
<span class="sd">              specified, then the first tree (offset = 0) is assumed (i.e., no</span>
<span class="sd">              trees within the specified collection will be skipped). Use this</span>
<span class="sd">              to specify, e.g. a burn-in.</span>
<span class="sd">            - **ignore_unrecognized_keyword_arguments** (*bool*) -- If |True|,</span>
<span class="sd">              then unsupported or unrecognized keyword arguments will not</span>
<span class="sd">              result in an error. Default is |False|: unsupported keyword</span>
<span class="sd">              arguments will result in an error.</span>

<span class="sd">        **Optional Schema-Specific Keyword Arguments:**</span>

<span class="sd">            These provide control over how the data is interpreted and</span>
<span class="sd">            processed, and supported argument names and values depend on</span>
<span class="sd">            the schema as specified by the value passed as the &quot;``schema``&quot;</span>
<span class="sd">            argument. See &quot;|Schemas|&quot; for more details.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        ::</span>

<span class="sd">            tlst1 = dendropy.TreeList.get(</span>
<span class="sd">                    file=open(&#39;treefile.tre&#39;, &#39;rU&#39;),</span>
<span class="sd">                    schema=&quot;newick&quot;)</span>
<span class="sd">            tlst2 = dendropy.TreeList.get(</span>
<span class="sd">                    path=&#39;sometrees.nexus&#39;,</span>
<span class="sd">                    schema=&quot;nexus&quot;,</span>
<span class="sd">                    collection_offset=2,</span>
<span class="sd">                    tree_offset=100)</span>
<span class="sd">            tlst3 = dendropy.TreeList.get(</span>
<span class="sd">                    data=&quot;((A,B),(C,D));((A,C),(B,D));&quot;,</span>
<span class="sd">                    schema=&quot;newick&quot;)</span>
<span class="sd">            tree4 = dendropy.dendropy.TreeList.get(</span>
<span class="sd">                    url=&quot;http://api.opentreeoflife.org/v2/study/pg_1144/tree/tree2324.nex&quot;,</span>
<span class="sd">                    schema=&quot;nexus&quot;)</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_from</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="n">DEFAULT_TREE_TYPE</span> <span class="o">=</span> <span class="n">treemodel</span><span class="o">.</span><span class="n">Tree</span>

<div class="viewcode-block" id="TreeList.tree_factory">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.tree_factory">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">tree_factory</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns a |Tree| of a type that this list understands how to</span>
<span class="sd">        manage.</span>

<span class="sd">        Deriving classes can override this to provide for custom Tree-type</span>
<span class="sd">        object lists. You can simple override the class-level variable</span>
<span class="sd">        `DEFAULT_TREE_TYPE` in your derived class if the constructor signature</span>
<span class="sd">        of the alternate tree type is the same as |Tree|.</span>
<span class="sd">        If you want to have a TreeList *instance* that generates</span>
<span class="sd">        custom trees (i.e., as opposed to a TreeList-ish *class* of instances),</span>
<span class="sd">        set the ``tree_type`` attribute of the TreeList instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        \*args : positional arguments</span>
<span class="sd">            Passed directly to constructor of |Tree|.</span>

<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            Passed directly to constructor of |Tree|.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A |Tree| object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">DEFAULT_TREE_TYPE</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span></div>


    <span class="c1">###########################################################################</span>
    <span class="c1">### Lifecycle and Identity</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a new |TreeList| object, populating it with any iterable</span>
<span class="sd">        container with Tree object members passed as unnamed argument, or from</span>
<span class="sd">        a data source if ``stream`` and ``schema`` are passed.</span>

<span class="sd">        If passed an iterable container, the objects in that container must be</span>
<span class="sd">        of type |Tree| (or derived). If the container is of type |TreeList|,</span>
<span class="sd">        then, because each |Tree| object must have the same |TaxonNamespace|</span>
<span class="sd">        reference as the containing |TreeList|, the trees in the container</span>
<span class="sd">        passed as an initialization argument will be **deep**-copied (except</span>
<span class="sd">        for associated |TaxonNamespace| and |Taxon| objects, which will</span>
<span class="sd">        be shallow-copied). If the container is any other type of</span>
<span class="sd">        iterable, then the |Tree| objects will be **shallow**-copied.</span>

<span class="sd">        |TreeList| objects can directly thus be instantiated in the</span>
<span class="sd">        following ways::</span>

<span class="sd">            # /usr/bin/env python</span>

<span class="sd">            from dendropy import TaxonNamespace, Tree, TreeList</span>

<span class="sd">            # instantiate an empty tree</span>
<span class="sd">            tlst1 = TreeList()</span>

<span class="sd">            # TreeList objects can be instantiated from an external data source</span>
<span class="sd">            # using the &#39;get()&#39; factory class method</span>

<span class="sd">            tlst2 = TreeList.get(file=open(&#39;treefile.tre&#39;, &#39;rU&#39;), schema=&quot;newick&quot;)</span>
<span class="sd">            tlst3 = TreeList.get(path=&#39;sometrees.nexus&#39;, schema=&quot;nexus&quot;)</span>
<span class="sd">            tlst4 = TreeList.get(data=&quot;((A,B),(C,D));((A,C),(B,D));&quot;, schema=&quot;newick&quot;)</span>

<span class="sd">            # can also call `read()` on a TreeList object; each read adds</span>
<span class="sd">            # (appends) the tree(s) found to the TreeList</span>
<span class="sd">            tlst5 = TreeList()</span>
<span class="sd">            tlst5.read(file=open(&#39;boot1.tre&#39;, &#39;rU&#39;), schema=&quot;newick&quot;)</span>
<span class="sd">            tlst5.read(path=&quot;boot3.tre&quot;, schema=&quot;newick&quot;)</span>
<span class="sd">            tlst5.read(value=&quot;((A,B),(C,D));((A,C),(B,D));&quot;, schema=&quot;newick&quot;)</span>

<span class="sd">            # populated from list of Tree objects</span>
<span class="sd">            tlist6_1 = Tree.get(</span>
<span class="sd">                    data=&quot;((A,B),(C,D))&quot;,</span>
<span class="sd">                    schema=&quot;newick&quot;)</span>
<span class="sd">            tlist6_2 = Tree.get(</span>
<span class="sd">                    data=&quot;((A,C),(B,D))&quot;,</span>
<span class="sd">                    schema=&quot;newick&quot;)</span>
<span class="sd">            tlist6 = TreeList([tlist5_1, tlist5_2])</span>

<span class="sd">            # passing keywords to underlying tree parser</span>
<span class="sd">            tlst8 = TreeList.get(</span>
<span class="sd">                             data=&quot;((A,B),(C,D));((A,C),(B,D));&quot;,</span>
<span class="sd">                             schema=&quot;newick&quot;,</span>
<span class="sd">                             taxon_namespace=tlst3.taxon_namespace,</span>
<span class="sd">                             rooting=&quot;force-rooted&quot;,</span>
<span class="sd">                             extract_comment_metadata=True,</span>
<span class="sd">                             store_tree_weights=False,</span>
<span class="sd">                             preserve_underscores=True)</span>

<span class="sd">            # Subsets of trees can be read. Note that in most cases, the entire</span>
<span class="sd">            # data source is parsed, so this is not more efficient than reading</span>
<span class="sd">            # all the trees and then manually-extracting them later; just more</span>
<span class="sd">            # convenient</span>

<span class="sd">            # skip the *first* 100 trees in the *first* (offset=0) collection of trees</span>
<span class="sd">            trees = TreeList.get(</span>
<span class="sd">                        path=&quot;mcmc.tre&quot;,</span>
<span class="sd">                        schema=&quot;newick&quot;,</span>
<span class="sd">                        collection_offset=0,</span>
<span class="sd">                        tree_offset=100)</span>

<span class="sd">            # get the *last* 10 trees in the *second* (offset=1) collection of trees</span>
<span class="sd">            trees = TreeList.get(</span>
<span class="sd">                        path=&quot;mcmc.tre&quot;,</span>
<span class="sd">                        schema=&quot;newick&quot;,</span>
<span class="sd">                        collection_offset=1,</span>
<span class="sd">                        tree_offset=-10)</span>

<span class="sd">            # get the last 10 trees in the second-to-last collection of trees</span>
<span class="sd">            trees = TreeList.get(</span>
<span class="sd">                        path=&quot;mcmc.tre&quot;,</span>
<span class="sd">                        schema=&quot;newick&quot;,</span>
<span class="sd">                        collection_offset=-2,</span>
<span class="sd">                        tree_offset=100)</span>

<span class="sd">            # Slices give shallow-copy: trees are references</span>
<span class="sd">            tlst4copy0a = t4[:]</span>
<span class="sd">            assert tlst4copy0a[0] is t4[0]</span>
<span class="sd">            tlst4copy0b = t4[:4]</span>
<span class="sd">            assert tlst4copy0b[0] is t4[0]</span>

<span class="sd">            # &#39;Taxon-namespace-scoped&#39; copy:</span>
<span class="sd">            # I.e., Deep-copied objects but taxa and taxon namespace</span>
<span class="sd">            # are copied as references</span>
<span class="sd">            tlst4copy1a = TreeList(t4)</span>
<span class="sd">            tlst4copy1b = TreeList([Tree(t) for t in tlst5])</span>
<span class="sd">            assert tlst4copy1a[0] is not tlst4[0] # True</span>
<span class="sd">            assert tlst4copy1a.taxon_namespace is tlst4.taxon_namespace # True</span>
<span class="sd">            assert tlst4copy1b[0] is not tlst4[0] # True</span>
<span class="sd">            assert tlst4copy1b.taxon_namespace is tlst4.taxon_namespace # True</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># only allow 1 positional argument</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">TooManyArgumentsError</span><span class="p">(</span><span class="n">func_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">max_args</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TreeList</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clone_from</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">taxonmodel</span><span class="o">.</span><span class="n">TaxonNamespaceAssociated</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxonmodel</span><span class="o">.</span><span class="n">process_kwargs_dict_for_taxon_namespace</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;tree_type&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">DEFAULT_TREE_TYPE</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">aidx</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_type</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot add object not of &#39;Tree&#39; type to &#39;TreeList&#39;&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unrecognized or unsupported arguments: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TreeList</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_trees</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clone_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_list</span><span class="p">,</span> <span class="n">kwargs_dict</span><span class="p">):</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># memo[id(tree)] = self</span>
        <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">taxonmodel</span><span class="o">.</span><span class="n">process_kwargs_dict_for_taxon_namespace</span><span class="p">(</span><span class="n">kwargs_dict</span><span class="p">,</span> <span class="n">tree_list</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">tree_list</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)]</span> <span class="o">=</span> <span class="n">taxon_namespace</span>
        <span class="k">if</span> <span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tree_list</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t1</span> <span class="ow">in</span> <span class="n">tree_list</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="n">taxon_namespace</span><span class="o">.</span><span class="n">require_taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">t1</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
                <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">t2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t1</span> <span class="ow">in</span> <span class="n">tree_list</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
                <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">t1</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tree_list</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="n">tree_list</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">TreeList</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_trees</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">)</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">other</span>
        <span class="n">other</span><span class="o">.</span><span class="n">deep_copy_annotations_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span>

<div class="viewcode-block" id="TreeList.taxon_namespace_scoped_copy">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.taxon_namespace_scoped_copy">[docs]</a>
    <span class="k">def</span> <span class="nf">taxon_namespace_scoped_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># this populates ``memo`` with references to the</span>
        <span class="c1"># the TaxonNamespace and Taxon objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">populate_memo_for_taxon_namespace_scoped_copy</span><span class="p">(</span><span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__deepcopy__</span><span class="p">(</span><span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">basemodel</span><span class="o">.</span><span class="n">Annotable</span><span class="o">.</span><span class="n">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>

    <span class="c1">###########################################################################</span>
    <span class="c1">### Representation</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;TreeList </span><span class="si">{}</span><span class="s2"> &#39;</span><span class="si">{}</span><span class="s2">&#39;: [</span><span class="si">{}</span><span class="s2">]&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">))</span>

    <span class="c1">###########################################################################</span>
    <span class="c1">### Data I/O</span>

    <span class="k">def</span> <span class="nf">_taxon_namespace_pseudofactory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dummy factory to coerce all |TaxonNamespace| objects required when</span>
<span class="sd">        parsing a data source to reference ``self.taxon_namespace``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;label&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>

    <span class="k">def</span> <span class="nf">_tree_list_pseudofactory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dummy factory to coerce all |TreeList| objects required when</span>
<span class="sd">        parsing a data source to reference ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;label&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_parse_and_add_from_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">stream</span><span class="p">,</span>
            <span class="n">schema</span><span class="p">,</span>
            <span class="n">collection_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">tree_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses |Tree| objects from data source and adds to this collection.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        *All* operational taxonomic unit concepts in the data source will be included</span>
<span class="sd">        in the |TaxonNamespace| object associated with the new</span>
<span class="sd">        |TreeList| object and its contained |Tree| objects, even those</span>
<span class="sd">        not associated with trees or the particular trees being retrieved.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        stream : file or file-like object</span>
<span class="sd">            Source of data.</span>

<span class="sd">        schema : string</span>
<span class="sd">            Identifier of format of data in ``stream``.</span>

<span class="sd">        collection_offset : integer or None</span>
<span class="sd">            0-based index indicating collection of trees to parse. If |None|,</span>
<span class="sd">            then all tree collections are retrieved, with each distinct</span>
<span class="sd">            collection parsed into a separate |TreeList| object. If the</span>
<span class="sd">            tree colleciton offset index is equal or greater than the number of</span>
<span class="sd">            tree collections in the data source, then IndexError is raised.</span>
<span class="sd">            Negative offsets work like negative list indexes; e.g., a</span>
<span class="sd">            ``collection_offset`` of -1 means to read the last collection of</span>
<span class="sd">            trees in the data source. For data formats that do not support the</span>
<span class="sd">            concept of distinct tree collections (e.g. NEWICK) are considered</span>
<span class="sd">            single-collection data source (i.e, the only acceptable</span>
<span class="sd">            ``collection_offset`` values are -1 or 0).</span>

<span class="sd">        tree_offset : integer or None</span>
<span class="sd">            0-based index indicating particular tree within a particular</span>
<span class="sd">            collection of trees at which to begin reading.  If not specified or</span>
<span class="sd">            |None| (default), then all trees are parsed.  Otherwise, must be an</span>
<span class="sd">            integer value up the length of the collection minus 1.  A positive</span>
<span class="sd">            offset indicates the number of trees in the collection to skip;</span>
<span class="sd">            e.g. a ``tree_offset`` of 20 means to skip the first 20 trees in the</span>
<span class="sd">            collection.  Negative offsets work like negative list indexes;</span>
<span class="sd">            e.g., a ``tree_offset`` value of -10 means to retrieve the last 10</span>
<span class="sd">            trees in the collection.  If the tree offset index is equal or</span>
<span class="sd">            greater than the number of trees in the collection, then IndexError</span>
<span class="sd">            is raised. Requires that a particular tree collection has been</span>
<span class="sd">            identified using the ``tree_collection_offset`` parameter: if</span>
<span class="sd">            ``tree_collection_offset`` is not specified, a TypeError is raised.</span>

<span class="sd">        \*\*kwargs : keyword arguments</span>

<span class="sd">            Arguments to customize parsing, instantiation, processing, and</span>
<span class="sd">            accession of |Tree| objects read from the data source, including</span>
<span class="sd">            schema- or format-specific handling. These will be passed to the</span>
<span class="sd">            underlying schema-specific reader for handling.</span>

<span class="sd">            General (schema-agnostic) keyword arguments are:</span>

<span class="sd">                * ``rooted`` specifies the default rooting interpretation of the tree.</span>
<span class="sd">                * ``edge_length_type`` specifies the type of the edge lengths (int or</span>
<span class="sd">                  float; defaults to &#39;float&#39;)</span>

<span class="sd">            Other keyword arguments are available depending on the schema. See</span>
<span class="sd">            specific schema handlers (e.g., `NewickReader`, `NexusReader`,</span>
<span class="sd">            `NexmlReader`) for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Note that in most cases, even if ``collection_offset`` and ``tree_offset``</span>
<span class="sd">        are specified to restrict the trees read, the *entire* data source</span>
<span class="sd">        is still parsed and processed. So this is not more efficient than</span>
<span class="sd">        reading all the trees and then manually-extracting them later; just</span>
<span class="sd">        more convenient. If you need just a single subset of trees from a data</span>
<span class="sd">        source, there is no gain in efficiency. If you need multiple trees or</span>
<span class="sd">        subsets of trees from the same data source, it would be much more</span>
<span class="sd">        efficient to read the entire data source, and extract trees as needed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : ``int``</span>
<span class="sd">            The number of |Tree| objects read.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;taxon_namespace&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;taxon_namespace&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot change ``taxon_namespace`` when reading into an existing TreeList&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;tree_list&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">cur_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">)</span>
        <span class="n">TreeList</span><span class="o">.</span><span class="n">_parse_and_create_from_stream</span><span class="p">(</span>
                <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span>
                <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span>
                <span class="n">collection_offset</span><span class="o">=</span><span class="n">collection_offset</span><span class="p">,</span>
                <span class="n">tree_offset</span><span class="o">=</span><span class="n">tree_offset</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">new_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_size</span> <span class="o">-</span> <span class="n">cur_size</span>

<div class="viewcode-block" id="TreeList.read">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.read">[docs]</a>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add |Tree| objects to existing |TreeList| from data source providing</span>
<span class="sd">        one or more collections of trees.</span>

<span class="sd">        **Mandatory Source-Specification Keyword Argument (Exactly One Required):**</span>

<span class="sd">            - **file** (*file*) -- File or file-like object of data opened for reading.</span>
<span class="sd">            - **path** (*str*) -- Path to file of data.</span>
<span class="sd">            - **url** (*str*) -- URL of data.</span>
<span class="sd">            - **data** (*str*) -- Data given directly.</span>

<span class="sd">        **Mandatory Schema-Specification Keyword Argument:**</span>

<span class="sd">            - **schema** (*str*) -- Identifier of format of data given by the</span>
<span class="sd">              &quot;``file``&quot;, &quot;``path``&quot;, &quot;``data``&quot;, or &quot;``url``&quot; argument</span>
<span class="sd">              specified above: &quot;:doc:`newick &lt;/schemas/newick&gt;`&quot;, &quot;:doc:`nexus</span>
<span class="sd">              &lt;/schemas/nexus&gt;`&quot;, or &quot;:doc:`nexml &lt;/schemas/nexml&gt;`&quot;. See</span>
<span class="sd">              &quot;|Schemas|&quot; for more details.</span>

<span class="sd">        **Optional General Keyword Arguments:**</span>

<span class="sd">            - **collection_offset** (*int*) -- 0-based index of tree block or</span>
<span class="sd">              collection in source to be parsed. If not specified then the</span>
<span class="sd">              first collection (offset = 0) is assumed.</span>
<span class="sd">            - **tree_offset** (*int*) -- 0-based index of first tree within the</span>
<span class="sd">              collection specified by ``collection_offset`` to be parsed (i.e.,</span>
<span class="sd">              skipping the first ``tree_offset`` trees). If not</span>
<span class="sd">              specified, then the first tree (offset = 0) is assumed (i.e., no</span>
<span class="sd">              trees within the specified collection will be skipped). Use this</span>
<span class="sd">              to specify, e.g. a burn-in.</span>
<span class="sd">            - **ignore_unrecognized_keyword_arguments** (*bool*) -- If |True|,</span>
<span class="sd">              then unsupported or unrecognized keyword arguments will not</span>
<span class="sd">              result in an error. Default is |False|: unsupported keyword</span>
<span class="sd">              arguments will result in an error.</span>

<span class="sd">        **Optional Schema-Specific Keyword Arguments:**</span>

<span class="sd">            These provide control over how the data is interpreted and</span>
<span class="sd">            processed, and supported argument names and values depend on</span>
<span class="sd">            the schema as specified by the value passed as the &quot;``schema``&quot;</span>
<span class="sd">            argument. See &quot;|Schemas|&quot; for more details.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        ::</span>

<span class="sd">            tlist = dendropy.TreeList()</span>
<span class="sd">            tlist.read(</span>
<span class="sd">                    file=open(&#39;treefile.tre&#39;, &#39;rU&#39;),</span>
<span class="sd">                    schema=&quot;newick&quot;,</span>
<span class="sd">                    tree_offset=100)</span>
<span class="sd">            tlist.read(</span>
<span class="sd">                    path=&#39;sometrees.nexus&#39;,</span>
<span class="sd">                    schema=&quot;nexus&quot;,</span>
<span class="sd">                    collection_offset=2,</span>
<span class="sd">                    tree_offset=100)</span>
<span class="sd">            tlist.read(</span>
<span class="sd">                    data=&quot;((A,B),(C,D));((A,C),(B,D));&quot;,</span>
<span class="sd">                    schema=&quot;newick&quot;)</span>
<span class="sd">            tlist.read(</span>
<span class="sd">                    url=&quot;http://api.opentreeoflife.org/v2/study/pg_1144/tree/tree2324.nex&quot;,</span>
<span class="sd">                    schema=&quot;nexus&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">basemodel</span><span class="o">.</span><span class="n">MultiReadable</span><span class="o">.</span><span class="n">_read_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_format_and_write_to_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes out ``self`` in ``schema`` format to a destination given by</span>
<span class="sd">        file-like object ``stream``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : file or file-like object</span>
<span class="sd">            Destination for data.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Must be a recognized and tree file schema, such as &quot;nexus&quot;,</span>
<span class="sd">            &quot;newick&quot;, etc, for which a specialized tree list writer is</span>
<span class="sd">            available. If this is not implemented for the schema specified, then</span>
<span class="sd">            a UnsupportedSchemaError is raised.</span>

<span class="sd">        \*\*kwargs : keyword arguments, optional</span>
<span class="sd">            Keyword arguments will be passed directly to the writer for the</span>
<span class="sd">            specified schema. See documentation for details on keyword</span>
<span class="sd">            arguments supported by writers of various schemas.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">dataio</span><span class="o">.</span><span class="n">get_writer</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write_tree_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span>

    <span class="c1">###########################################################################</span>
    <span class="c1">### List Interface</span>

    <span class="k">def</span> <span class="nf">_import_tree_to_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">taxon_import_strategy</span><span class="o">=</span><span class="s2">&quot;migrate&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">taxon_import_strategy</span> <span class="o">==</span> <span class="s2">&quot;migrate&quot;</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">migrate_taxon_namespace</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">taxon_import_strategy</span> <span class="o">==</span> <span class="s2">&quot;add&quot;</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">_taxon_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">update_taxon_namespace</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized taxon import strategy: &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">taxon_import_strategy</span><span class="p">))</span>
        <span class="c1"># assert tree.taxon_namespace is self.taxon_namespace</span>
        <span class="k">return</span> <span class="n">tree</span>

<div class="viewcode-block" id="TreeList.insert">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.insert">[docs]</a>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">taxon_import_strategy</span><span class="o">=</span><span class="s2">&quot;migrate&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a |Tree| object, ``tree``, into the collection before</span>
<span class="sd">        ``index``.</span>

<span class="sd">        The |TaxonNamespace| reference of ``tree`` will be set to that of</span>
<span class="sd">        ``self``.  Any |Taxon| objects associated with nodes in ``tree``</span>
<span class="sd">        that are not already in ``self.taxon_namespace`` will be handled</span>
<span class="sd">        according to ``taxon_import_strategy``:</span>

<span class="sd">            - &#39;migrate&#39;</span>
<span class="sd">                |Taxon| objects associated with ``tree`` that are not already</span>
<span class="sd">                in ``self.taxon_nameaspace`` will be remapped based on their</span>
<span class="sd">                labels, with new :class|Taxon| objects being reconstructed if</span>
<span class="sd">                none with matching labels are found. Specifically,</span>
<span class="sd">                :meth:`dendropy.datamodel.treemodel.Tree.migrate_taxon_namespace()`</span>
<span class="sd">                will be called on ``tree``, where ``kwargs`` is as passed to</span>
<span class="sd">                this function.</span>
<span class="sd">            - &#39;add&#39;</span>
<span class="sd">                |Taxon| objects associated with ``tree`` that are not already</span>
<span class="sd">                in ``self.taxon_namespace`` will be added. Note that this might</span>
<span class="sd">                result in |Taxon| objects with duplicate labels as no</span>
<span class="sd">                attempt at mapping to existing |Taxon| objects based on</span>
<span class="sd">                label-matching is done.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : integer</span>
<span class="sd">            Position before which to insert ``tree``.</span>
<span class="sd">        tree : A |Tree| instance</span>
<span class="sd">            The |Tree| object to be added.</span>
<span class="sd">        taxon_import_strategy : string</span>
<span class="sd">            If ``tree`` is associated with a different |TaxonNamespace|,</span>
<span class="sd">            this argument determines how new |Taxon| objects in ``tree``</span>
<span class="sd">            are handled: &#39;migrate&#39; or &#39;add&#39;. See above for details.</span>
<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            These arguments will be passed directly to</span>
<span class="sd">            &#39;migrate_taxon_namespace()&#39; method call on ``tree``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        :meth:`Tree.migrate_taxon_namespace`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_import_tree_to_taxon_namespace</span><span class="p">(</span>
                <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                <span class="n">taxon_import_strategy</span><span class="o">=</span><span class="n">taxon_import_strategy</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeList.append">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.append">[docs]</a>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">taxon_import_strategy</span><span class="o">=</span><span class="s2">&quot;migrate&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a |Tree| object, ``tree``, to the collection.</span>

<span class="sd">        The |TaxonNamespace| reference of ``tree`` will be set to that of</span>
<span class="sd">        ``self``.  Any |Taxon| objects associated with nodes in ``tree``</span>
<span class="sd">        that are not already in ``self.taxon_namespace`` will be handled</span>
<span class="sd">        according to ``taxon_import_strategy``:</span>

<span class="sd">            - &#39;migrate&#39;</span>
<span class="sd">                |Taxon| objects associated with ``tree`` that are not already</span>
<span class="sd">                in ``self.taxon_nameaspace`` will be remapped based on their</span>
<span class="sd">                labels, with new :class|Taxon| objects being reconstructed if</span>
<span class="sd">                none with matching labels are found. Specifically,</span>
<span class="sd">                :meth:`dendropy.datamodel.treemodel.Tree.migrate_taxon_namespace()`</span>
<span class="sd">                will be called on ``tree``, where ``kwargs`` is as passed to this</span>
<span class="sd">                function.</span>
<span class="sd">            - &#39;add&#39;</span>
<span class="sd">                |Taxon| objects associated with ``tree`` that are not already</span>
<span class="sd">                in ``self.taxon_namespace`` will be added. Note that this might</span>
<span class="sd">                result in |Taxon| objects with duplicate labels as no</span>
<span class="sd">                attempt at mapping to existing |Taxon| objects based on</span>
<span class="sd">                label-matching is done.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree : A |Tree| instance</span>
<span class="sd">            The |Tree| object to be added.</span>
<span class="sd">        taxon_import_strategy : string</span>
<span class="sd">            If ``tree`` is associated with a different |TaxonNamespace|,</span>
<span class="sd">            this argument determines how new |Taxon| objects in ``tree``</span>
<span class="sd">            are handled: &#39;migrate&#39; or &#39;add&#39;. See above for details.</span>
<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            These arguments will be passed directly to</span>
<span class="sd">            &#39;migrate_taxon_namespace()&#39; method call on ``tree``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        :meth:`Tree.migrate_taxon_namespace`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_import_tree_to_taxon_namespace</span><span class="p">(</span>
                <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                <span class="n">taxon_import_strategy</span><span class="o">=</span><span class="n">taxon_import_strategy</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeList.extend">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.extend">[docs]</a>
    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-place addition of |Tree| objects in ``other`` to ``self``.</span>

<span class="sd">        If ``other`` is a |TreeList|, then the trees are *copied*</span>
<span class="sd">        and migrated into ``self.taxon_namespace``; otherwise, the original</span>
<span class="sd">        objects are migrated into ``self.taxon_namespace`` and added directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : iterable of |Tree| objects</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ``self`` : |TreeList|</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TreeList</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t0</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_type</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t0</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="TreeList.__iadd__">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.__iadd__">[docs]</a>
    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-place addition of |Tree| objects in ``other`` to ``self``.</span>

<span class="sd">        If ``other`` is a |TreeList|, then the trees are *copied*</span>
<span class="sd">        and migrated into ``self.taxon_namespace``; otherwise, the original</span>
<span class="sd">        objects are migrated into ``self.taxon_namespace`` and added directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : iterable of |Tree| objects</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ``self`` : |TreeList|</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeList.__add__">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.__add__">[docs]</a>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns new |TreeList| with clones of all trees in ``self``</span>
<span class="sd">        as well as all |Tree| objects in ``other``.  If ``other`` is a</span>
<span class="sd">        |TreeList|, then the trees are *cloned* and migrated into</span>
<span class="sd">        ``self.taxon_namespace``; otherwise, the original objects are migrated into</span>
<span class="sd">        ``self.taxon_namespace`` and added directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : iterable of |Tree| objects</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tlist : |TreeList| object</span>
<span class="sd">            |TreeList| object containing clones of |Tree| objects</span>
<span class="sd">            in ``self`` and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tlist</span> <span class="o">=</span> <span class="n">TreeList</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="n">tlist</span> <span class="o">+=</span> <span class="bp">self</span>
        <span class="n">tlist</span> <span class="o">+=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">tlist</span></div>


    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">)</span>

<div class="viewcode-block" id="TreeList.__getitem__">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If ``index`` is an integer, then |Tree| object at position ``index``</span>
<span class="sd">        is returned. If ``index`` is a slice, then a |TreeList| is returned</span>
<span class="sd">        with references (i.e., not copies or clones, but the actual original</span>
<span class="sd">        instances themselves) to |Tree| objects in the positions given</span>
<span class="sd">        by the slice. The |TaxonNamespace| is the same as ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : integer or slice</span>
<span class="sd">            Index or slice.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : |Tree| object or |TreeList| object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">TreeList</span><span class="p">(</span><span class="n">r</span><span class="p">,</span>
                    <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>


    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TreeList</span><span class="p">):</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">t0</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_type</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span>
                            <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
                    <span class="n">tt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">tt</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_import_tree_to_taxon_namespace</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_import_tree_to_taxon_namespace</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># list.clear() only with 3.4 or so ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">tns</span> <span class="o">=</span> <span class="n">taxonmodel</span><span class="o">.</span><span class="n">process_kwargs_dict_for_taxon_namespace</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot create new Tree with different TaxonNamespace&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span>

   <span class="c1">##############################################################################</span>
   <span class="c1">## Taxon Handling</span>

<div class="viewcode-block" id="TreeList.reconstruct_taxon_namespace">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.reconstruct_taxon_namespace">[docs]</a>
    <span class="k">def</span> <span class="nf">reconstruct_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">unify_taxa_by_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">taxon_mapping_memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">taxon_mapping_memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">taxon_mapping_memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">_taxon_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">reconstruct_taxon_namespace</span><span class="p">(</span>
                <span class="n">unify_taxa_by_label</span><span class="o">=</span><span class="n">unify_taxa_by_label</span><span class="p">,</span>
                <span class="n">taxon_mapping_memo</span><span class="o">=</span><span class="n">taxon_mapping_memo</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="TreeList.update_taxon_namespace">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.update_taxon_namespace">[docs]</a>
    <span class="k">def</span> <span class="nf">update_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">_taxon_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">update_taxon_namespace</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeList.poll_taxa">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.poll_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">poll_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxa</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a set populated with all of |Taxon| instances associated</span>
<span class="sd">        with ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxa : set()</span>
<span class="sd">            Set to populate. If not specified, a new one will be created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taxa : set[|Taxon|]</span>
<span class="sd">            Set of taxa associated with ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">taxa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">taxa</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">poll_taxa</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">taxa</span></div>


<div class="viewcode-block" id="TreeList.reindex_subcomponent_taxa">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.reindex_subcomponent_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">reindex_subcomponent_taxa</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


   <span class="c1">##############################################################################</span>
   <span class="c1">## Special Calculations and Operations on Entire Collection</span>

    <span class="k">def</span> <span class="nf">_get_tree_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">kwargs_dict</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return TreeArray containing information of trees currently</span>
<span class="sd">        in self. Processes ``kwargs_dict`` intelligently: removing</span>
<span class="sd">        and passing on keyword arguments pertaining to TreeArray</span>
<span class="sd">        construction, and leaving everything else.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: maybe ignore_node_ages defaults to |False| but ``ultrametricity_precision`` defaults to 0?</span>
        <span class="n">ta</span> <span class="o">=</span> <span class="n">TreeArray</span><span class="o">.</span><span class="n">from_tree_list</span><span class="p">(</span>
                <span class="n">trees</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="c1"># taxon_namespace=self.taxon_namespace,</span>
                <span class="n">is_rooted_trees</span><span class="o">=</span><span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;is_rooted_trees&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">ignore_edge_lengths</span><span class="o">=</span><span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ignore_edge_lengths&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                <span class="n">ignore_node_ages</span><span class="o">=</span><span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ignore_node_ages&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                <span class="n">use_tree_weights</span><span class="o">=</span><span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_tree_weights&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ultrametricity_precision&quot;</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">DEFAULT_ULTRAMETRICITY_PRECISION</span><span class="p">),</span>
                <span class="n">is_force_max_age</span><span class="o">=</span><span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;is_force_max_age&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">taxon_label_age_map</span><span class="o">=</span><span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;taxon_label_age_map&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;is_bipartitions_updated&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">ta</span>

<div class="viewcode-block" id="TreeList.split_distribution">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.split_distribution">[docs]</a>
    <span class="k">def</span> <span class="nf">split_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">default_edge_length_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return `SplitDistribution` collecting information on splits in</span>
<span class="sd">        contained trees. Keyword arguments get passed directly to</span>
<span class="sd">        `SplitDistribution` constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="s2">&quot;taxon_namespace&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="n">SplitDistribution</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">sd</span><span class="o">.</span><span class="n">count_splits_on_tree</span><span class="p">(</span>
                    <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                    <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="n">is_bipartitions_updated</span><span class="p">,</span>
                    <span class="n">default_edge_length_value</span><span class="o">=</span><span class="n">default_edge_length_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sd</span></div>


<div class="viewcode-block" id="TreeList.as_tree_array">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.as_tree_array">[docs]</a>
    <span class="k">def</span> <span class="nf">as_tree_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return |TreeArray| collecting information on splits in contained</span>
<span class="sd">        trees. Keyword arguments get passed directly to |TreeArray|</span>
<span class="sd">        constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ta</span> <span class="o">=</span> <span class="n">TreeArray</span><span class="o">.</span><span class="n">from_tree_list</span><span class="p">(</span>
                <span class="n">trees</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ta</span></div>


<div class="viewcode-block" id="TreeList.consensus">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.consensus">[docs]</a>
    <span class="k">def</span> <span class="nf">consensus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">min_freq</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">GREATER_THAN_HALF</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">summarize_splits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a consensus tree of all trees in self, with minumum frequency</span>
<span class="sd">        of bipartition to be added to the consensus tree given by ``min_freq``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tree_array</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ta</span><span class="o">.</span><span class="n">consensus_tree</span><span class="p">(</span><span class="n">min_freq</span><span class="o">=</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">summarize_splits</span><span class="o">=</span><span class="n">summarize_splits</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeList.maximum_product_of_split_support_tree">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.maximum_product_of_split_support_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">maximum_product_of_split_support_tree</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">include_external_splits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">score_attr</span><span class="o">=</span><span class="s2">&quot;log_product_of_split_support&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tree with that maximizes the product of split supports, also</span>
<span class="sd">        known as the &quot;Maximum Clade Credibility Tree&quot; or MCCT.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_external_splits : bool</span>
<span class="sd">            If |True|, then non-internal split posteriors will be included in</span>
<span class="sd">            the score. Defaults to |False|: these are skipped. This should only</span>
<span class="sd">            make a difference when dealing with splits collected from trees of</span>
<span class="sd">            different leaf sets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mcct_tree : Tree</span>
<span class="sd">            Tree that maximizes the product of split supports.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tree_array</span><span class="p">({})</span>
        <span class="n">scores</span><span class="p">,</span> <span class="n">max_score_tree_idx</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">calculate_log_product_of_split_supports</span><span class="p">(</span>
                <span class="n">include_external_splits</span><span class="o">=</span><span class="n">include_external_splits</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">max_score_tree_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">score_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">score_attr</span><span class="p">,</span> <span class="n">scores</span><span class="p">[</span><span class="n">max_score_tree_idx</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">tree</span></div>


<div class="viewcode-block" id="TreeList.maximum_sum_of_split_support_tree">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.maximum_sum_of_split_support_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">maximum_sum_of_split_support_tree</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">include_external_splits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">score_attr</span><span class="o">=</span><span class="s2">&quot;sum_of_split_support&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tree with that maximizes the *sum* of split supports.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_external_splits : bool</span>
<span class="sd">            If |True|, then non-internal split posteriors will be included in</span>
<span class="sd">            the score. Defaults to |False|: these are skipped. This should only</span>
<span class="sd">            make a difference when dealing with splits collected from trees of</span>
<span class="sd">            different leaf sets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mcct_tree : Tree</span>
<span class="sd">            Tree that maximizes the sum of split supports.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tree_array</span><span class="p">({})</span>
        <span class="n">scores</span><span class="p">,</span> <span class="n">max_score_tree_idx</span> <span class="o">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">calculate_sum_of_split_supports</span><span class="p">(</span>
                <span class="n">include_external_splits</span><span class="o">=</span><span class="n">include_external_splits</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">max_score_tree_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">score_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">score_attr</span><span class="p">,</span> <span class="n">scores</span><span class="p">[</span><span class="n">max_score_tree_idx</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">tree</span></div>


<div class="viewcode-block" id="TreeList.frequency_of_bipartition">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.frequency_of_bipartition">[docs]</a>
    <span class="k">def</span> <span class="nf">frequency_of_bipartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a bipartition specified as:</span>

<span class="sd">            - a |Bipartition| instance given the keyword &#39;bipartition&#39;</span>
<span class="sd">            - a split bitmask given the keyword &#39;split_bitmask&#39;</span>
<span class="sd">            - a list of |Taxon| objects given with the keyword ``taxa``</span>
<span class="sd">            - a list of taxon labels given with the keyword ``labels``</span>

<span class="sd">        this function returns the proportion of trees in self</span>
<span class="sd">        in which the split is found.</span>

<span class="sd">        If the tree(s) in the collection are unrooted, then the bipartition</span>
<span class="sd">        will be normalized for the comparison.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">split</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">is_bipartitions_updated</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;is_bipartitions_updated&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;split_bitmask&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">split</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;split_bitmask&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;bipartition&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">split</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;bipartition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split_bitmask</span>
        <span class="k">elif</span> <span class="s2">&quot;taxa&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">taxa_bitmask</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;taxa&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;taxa&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">bitprocessing</span><span class="o">.</span><span class="n">num_set_bits</span><span class="p">(</span><span class="n">split</span><span class="p">)</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Not all taxa could be mapped to bipartition (</span><span class="si">%s</span><span class="s1">): </span><span class="si">%s</span><span class="s1">&#39;</span> \
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">bitmask_as_bitstring</span><span class="p">(</span><span class="n">split</span><span class="p">),</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Need to specify one of the following keyword arguments: &#39;split_bitmask&#39;, &#39;bipartition&#39;, &#39;taxa&#39;, or &#39;labels&#39;&quot;</span><span class="p">)</span>
        <span class="n">unnormalized_split</span> <span class="o">=</span> <span class="n">split</span>
        <span class="n">normalized_split</span> <span class="o">=</span> <span class="n">treemodel</span><span class="o">.</span><span class="n">Bipartition</span><span class="o">.</span><span class="n">normalize_bitmask</span><span class="p">(</span>
            <span class="n">bitmask</span><span class="o">=</span><span class="n">split</span><span class="p">,</span>
            <span class="n">fill_bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">all_taxa_bitmask</span><span class="p">(),</span>
            <span class="n">lowest_relevant_bit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bipartitions_updated</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
            <span class="n">bipartition_encoding</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">split_bitmask</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">)</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_unrooted</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalized_split</span> <span class="ow">in</span> <span class="n">bipartition_encoding</span><span class="p">):</span>
                <span class="n">found</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_unrooted</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">unnormalized_split</span> <span class="ow">in</span> <span class="n">bipartition_encoding</span><span class="p">):</span>
                <span class="n">found</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">found</span><span class="p">)</span><span class="o">/</span><span class="n">total</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="TreeList.frequency_of_split">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeList.frequency_of_split">[docs]</a>
    <span class="k">def</span> <span class="nf">frequency_of_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: use &#39;frequency_of_bipartition()&#39; instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Deprecated since DendroPy 4: Instead of &#39;frequency_of_split()&#39; use &#39;frequency_of_bipartition()&#39;&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency_of_bipartition</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>


<span class="c1">###############################################################################</span>
<span class="c1">### SplitDistribution</span>

<div class="viewcode-block" id="SplitDistribution">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution">[docs]</a>
<span class="k">class</span> <span class="nc">SplitDistribution</span><span class="p">(</span><span class="n">taxonmodel</span><span class="o">.</span><span class="n">TaxonNamespaceAssociated</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collects information regarding splits over multiple trees.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SUMMARY_STATS_FIELDNAMES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">,</span> <span class="s1">&#39;hpd95&#39;</span><span class="p">,</span> <span class="s1">&#39;quant_5_95&#39;</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">taxon_namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ignore_edge_lengths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">ignore_node_ages</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">use_tree_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">DEFAULT_ULTRAMETRICITY_PRECISION</span><span class="p">,</span>
            <span class="n">is_force_max_age</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">taxon_label_age_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Taxon Namespace</span>
        <span class="n">taxonmodel</span><span class="o">.</span><span class="n">TaxonNamespaceAssociated</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">)</span>

        <span class="c1"># configuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_edge_lengths</span> <span class="o">=</span> <span class="n">ignore_edge_lengths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_node_ages</span> <span class="o">=</span> <span class="n">ignore_node_ages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_tree_weights</span> <span class="o">=</span> <span class="n">use_tree_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ultrametricity_precision</span> <span class="o">=</span> <span class="n">ultrametricity_precision</span>

        <span class="c1"># storage/function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_trees_counted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_of_tree_weights</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_edge_lengths</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_node_ages</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_force_max_age</span> <span class="o">=</span> <span class="n">is_force_max_age</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_force_min_age</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taxon_label_age_map</span> <span class="o">=</span> <span class="n">taxon_label_age_map</span>

        <span class="c1"># secondary/derived/generated/collected data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_freqs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trees_counted_for_freqs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_edge_length_summaries</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_node_age_summaries</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trees_counted_for_summaries</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># services</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_decorator</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">###########################################################################</span>
    <span class="c1">### Utility</span>

<div class="viewcode-block" id="SplitDistribution.normalize_bitmask">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution.normalize_bitmask">[docs]</a>
    <span class="k">def</span> <span class="nf">normalize_bitmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bitmask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;Normalizes&quot; split, by ensuring that the least-significant bit is</span>
<span class="sd">        always 1 (used on unrooted trees to establish split identity</span>
<span class="sd">        independent of rotation).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bitmask : integer</span>
<span class="sd">            Split bitmask hash to be normalized.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : integer</span>
<span class="sd">            Normalized split bitmask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">treemodel</span><span class="o">.</span><span class="n">Bipartition</span><span class="o">.</span><span class="n">normalize_bitmask</span><span class="p">(</span>
                <span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">,</span>
                <span class="n">fill_bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">all_taxa_bitmask</span><span class="p">(),</span>
                <span class="n">lowest_relevant_bit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


    <span class="c1">###########################################################################</span>
    <span class="c1">### Configuration</span>

    <span class="k">def</span> <span class="nf">_is_rooted_deprecation_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Deprecated since DendroPy 4: &#39;SplitDistribution.is_rooted&#39; and &#39;SplitDistribution.is_unrooted&#39; are no longer valid attributes; rooting state tracking and management is now the responsibility of client code.&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                <span class="p">)</span>
    <span class="k">def</span> <span class="nf">_get_is_rooted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_deprecation_warning</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span>
    <span class="k">def</span> <span class="nf">_set_is_rooted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_deprecation_warning</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span> <span class="o">=</span> <span class="n">val</span>
    <span class="n">is_rooted</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_rooted</span><span class="p">,</span> <span class="n">_set_is_rooted</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_get_is_unrooted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_deprecation_warning</span><span class="p">()</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span>
    <span class="k">def</span> <span class="nf">_set_is_unrooted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_deprecation_warning</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">val</span>
    <span class="n">is_unrooted</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_unrooted</span><span class="p">,</span> <span class="n">_set_is_unrooted</span><span class="p">)</span>

    <span class="c1">###########################################################################</span>
    <span class="c1">### Split Counting and Book-Keeping</span>

    <span class="k">def</span> <span class="nf">add_split_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">+=</span> <span class="n">count</span>

<div class="viewcode-block" id="SplitDistribution.count_splits_on_tree">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution.count_splits_on_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">count_splits_on_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">default_edge_length_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts splits in this tree and add to totals. ``tree`` must be decorated</span>
<span class="sd">        with splits, and no attempt is made to normalize taxa.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree : a |Tree| object.</span>
<span class="sd">            The tree on which to count the splits.</span>
<span class="sd">        is_bipartitions_updated : bool</span>
<span class="sd">            If |False| [default], then the tree will have its splits encoded or</span>
<span class="sd">            updated. Otherwise, if |True|, then the tree is assumed to have its</span>
<span class="sd">            splits already encoded and updated.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        s : iterable of splits</span>
<span class="sd">            A list of split bitmasks from ``tree``.</span>
<span class="sd">        e :</span>
<span class="sd">            A list of edge length values from ``tree``.</span>
<span class="sd">        a :</span>
<span class="sd">            A list of node age values from ``tree``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_trees_counted</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_node_ages</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_label_age_map</span><span class="p">:</span>
                <span class="n">set_node_age_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_node_age</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">set_node_age_fn</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">calc_node_ages</span><span class="p">(</span>
                    <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ultrametricity_precision</span><span class="p">,</span>
                    <span class="n">is_force_max_age</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_force_max_age</span><span class="p">,</span>
                    <span class="n">is_force_min_age</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_force_min_age</span><span class="p">,</span>
                    <span class="n">set_node_age_fn</span><span class="o">=</span><span class="n">set_node_age_fn</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_tree_weights</span><span class="p">:</span>
            <span class="n">weight_to_use</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weight_to_use</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_of_tree_weights</span> <span class="o">+=</span> <span class="n">weight_to_use</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_rooted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bipartitions_updated</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">node_ages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">:</span>
            <span class="n">split</span> <span class="o">=</span> <span class="n">bipartition</span><span class="o">.</span><span class="n">split_bitmask</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bipartition</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">):</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">bipartition</span><span class="o">.</span><span class="n">edge</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># @MAM we&#39;re just doing a lookup of bipartition, not storing it</span>
                <span class="c1"># so it&#39;s ok to override is_mutable here</span>
                <span class="n">was_mutable</span><span class="p">,</span> <span class="n">bipartition</span><span class="o">.</span><span class="n">is_mutable</span> <span class="o">=</span> <span class="n">bipartition</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">,</span> <span class="kc">False</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_edge_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bipartition</span><span class="p">)</span>
                <span class="n">bipartition</span><span class="o">.</span><span class="n">is_mutable</span> <span class="o">=</span> <span class="n">was_mutable</span>

            <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight_to_use</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_edge_lengths</span><span class="p">:</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_edge_lengths</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">split</span><span class="p">,[])</span>
                <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">elen</span> <span class="o">=</span> <span class="n">default_edge_length_value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">elen</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                <span class="n">sel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elen</span><span class="p">)</span>
                <span class="n">edge_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elen</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_node_ages</span><span class="p">:</span>
                <span class="n">sna</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_node_ages</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="p">[])</span>
                <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">head_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nage</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="o">.</span><span class="n">age</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nage</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">sna</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nage</span><span class="p">)</span>
                <span class="n">node_ages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nage</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sna</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">splits</span><span class="p">,</span> <span class="n">edge_lengths</span><span class="p">,</span> <span class="n">node_ages</span></div>


<div class="viewcode-block" id="SplitDistribution.splits_considered">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution.splits_considered">[docs]</a>
    <span class="k">def</span> <span class="nf">splits_considered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns 4 values:</span>
<span class="sd">            total number of splits counted</span>
<span class="sd">            total *weighted* number of unique splits counted</span>
<span class="sd">            total number of non-trivial splits counted</span>
<span class="sd">            total *weighted* number of unique non-trivial splits counted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">num_splits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_unique_splits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_nt_splits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_nt_unique_splits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">taxa_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">all_taxa_bitmask</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">:</span>
            <span class="n">num_unique_splits</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">num_splits</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">treemodel</span><span class="o">.</span><span class="n">Bipartition</span><span class="o">.</span><span class="n">is_trivial_bitmask</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">taxa_mask</span><span class="p">):</span>
                <span class="n">num_nt_unique_splits</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">num_nt_splits</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">num_splits</span><span class="p">,</span> <span class="n">num_unique_splits</span><span class="p">,</span> <span class="n">num_nt_splits</span><span class="p">,</span> <span class="n">num_nt_unique_splits</span></div>


<div class="viewcode-block" id="SplitDistribution.calc_freqs">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution.calc_freqs">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_freqs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Forces recalculation of frequencies.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_freqs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_trees_counted</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">split</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_split_freqs</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normalization_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_normalization_weight</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">split</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">[</span><span class="n">split</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_split_freqs</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">[</span><span class="n">split</span><span class="p">])</span> <span class="o">/</span> <span class="n">normalization_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trees_counted_for_freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_trees_counted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_edge_length_summaries</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_node_age_summaries</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_freqs</span></div>


    <span class="k">def</span> <span class="nf">calc_normalization_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_of_tree_weights</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_trees_counted</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sum_of_tree_weights</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_dist</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_trees_counted</span> <span class="o">+=</span> <span class="n">split_dist</span><span class="o">.</span><span class="n">total_trees_counted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_of_tree_weights</span> <span class="o">+=</span> <span class="n">split_dist</span><span class="o">.</span><span class="n">sum_of_tree_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_edge_length_summaries</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_node_age_summaries</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trees_counted_for_summaries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">split_dist</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">split</span> <span class="ow">in</span> <span class="n">split_dist</span><span class="o">.</span><span class="n">split_counts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">+=</span> <span class="n">split_dist</span><span class="o">.</span><span class="n">split_counts</span><span class="p">[</span><span class="n">split</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_edge_lengths</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">+=</span> <span class="n">split_dist</span><span class="o">.</span><span class="n">split_edge_lengths</span><span class="p">[</span><span class="n">split</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_node_ages</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">+=</span> <span class="n">split_dist</span><span class="o">.</span><span class="n">split_node_ages</span><span class="p">[</span><span class="n">split</span><span class="p">]</span>

    <span class="c1">###########################################################################</span>
    <span class="c1">### Basic Information Access</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_counts</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">s</span>

<div class="viewcode-block" id="SplitDistribution.__getitem__">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_bitmask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns freqency of split_bitmask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_split_frequencies</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">split_bitmask</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_split_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_freqs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees_counted_for_freqs</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_trees_counted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_freqs</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_freqs</span>
    <span class="n">split_frequencies</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_split_frequencies</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_mixed_rootings_counted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span> <span class="p">(</span><span class="kc">True</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="kc">False</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span> <span class="ow">or</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span><span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_all_counted_trees_rooted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">True</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_all_counted_trees_strictly_unrooted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">False</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_all_counted_trees_treated_as_unrooted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_rooting_types_counted</span>

    <span class="c1">###########################################################################</span>
    <span class="c1">### Summarization</span>

<div class="viewcode-block" id="SplitDistribution.split_support_iter">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution.split_support_iter">[docs]</a>
    <span class="k">def</span> <span class="nf">split_support_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">include_external_splits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">traversal_strategy</span><span class="o">=</span><span class="s2">&quot;preorder&quot;</span><span class="p">,</span>
            <span class="n">node_support_attr_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">edge_support_attr_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns iterator over support values for the splits of a given tree,</span>
<span class="sd">        where the support value is given by the proportional frequency of the</span>
<span class="sd">        split in the current split distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree : |Tree|</span>
<span class="sd">            The |Tree| which will be scored.</span>
<span class="sd">        is_bipartitions_updated : bool</span>
<span class="sd">            If |False| [default], then the tree will have its splits encoded or</span>
<span class="sd">            updated. Otherwise, if |True|, then the tree is assumed to have its</span>
<span class="sd">            splits already encoded and updated.</span>
<span class="sd">        include_external_splits : bool</span>
<span class="sd">            If |True|, then non-internal split posteriors will be included.</span>
<span class="sd">            If |False|, then these are skipped. This should only make a</span>
<span class="sd">            difference when dealing with splits collected from trees of</span>
<span class="sd">            different leaf sets.</span>
<span class="sd">        traversal_strategy : str</span>
<span class="sd">            One of: &quot;preorder&quot; or &quot;postorder&quot;. Specfies order in which splits</span>
<span class="sd">            are visited.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : list of floats</span>
<span class="sd">            List of values for splits in the tree corresponding to the</span>
<span class="sd">            proportional frequency that the split is found in the current</span>
<span class="sd">            distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">traversal_strategy</span> <span class="o">==</span> <span class="s2">&quot;preorder&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">include_external_splits</span><span class="p">:</span>
                <span class="n">iter_fn</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">preorder_node_iter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iter_fn</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">preorder_internal_node_iter</span>
        <span class="k">elif</span> <span class="n">traversal_strategy</span> <span class="o">==</span> <span class="s2">&quot;postorder&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">include_external_splits</span><span class="p">:</span>
                <span class="n">iter_fn</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder_node_iter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iter_fn</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder_internal_node_iter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Traversal strategy not supported: &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">traversal_strategy</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bipartitions_updated</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="n">split_frequencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_split_frequencies</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">iter_fn</span><span class="p">():</span>
            <span class="n">split</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">split_bitmask</span>
            <span class="n">support</span> <span class="o">=</span> <span class="n">split_frequencies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">support</span></div>


    <span class="k">def</span> <span class="nf">calc_split_edge_length_summaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_edge_length_summaries</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">split</span><span class="p">,</span> <span class="n">elens</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_edge_lengths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">elens</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_split_edge_length_summaries</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">elens</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_edge_length_summaries</span>

    <span class="k">def</span> <span class="nf">calc_split_node_age_summaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_node_age_summaries</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">split</span><span class="p">,</span> <span class="n">ages</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_node_ages</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ages</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_split_node_age_summaries</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">ages</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_node_age_summaries</span>

    <span class="k">def</span> <span class="nf">_set_node_age</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nd</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nd</span><span class="o">.</span><span class="n">_child_nodes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_label_age_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_split_edge_length_summaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_edge_length_summaries</span> <span class="ow">is</span> <span class="kc">None</span> \
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees_counted_for_summaries</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_trees_counted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_split_edge_length_summaries</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_edge_length_summaries</span>
    <span class="n">split_edge_length_summaries</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_split_edge_length_summaries</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_split_node_age_summaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_node_age_summaries</span> <span class="ow">is</span> <span class="kc">None</span> \
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees_counted_for_summaries</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_trees_counted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_split_node_age_summaries</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_node_age_summaries</span>
    <span class="n">split_node_age_summaries</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_split_node_age_summaries</span><span class="p">)</span>

<div class="viewcode-block" id="SplitDistribution.log_product_of_split_support_on_tree">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution.log_product_of_split_support_on_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">log_product_of_split_support_on_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">include_external_splits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the (log) product of the support of the splits of the</span>
<span class="sd">        tree, where the support is given by the proportional frequency of the</span>
<span class="sd">        split in the current split distribution.</span>

<span class="sd">        The tree that has the highest product of split support out of a sample</span>
<span class="sd">        of trees corresponds to the &quot;maximum credibility tree&quot; for that sample.</span>
<span class="sd">        This can also be referred to as the &quot;maximum clade credibility tree&quot;,</span>
<span class="sd">        though this latter term is sometimes use for the tree that has the</span>
<span class="sd">        highest *sum* of split support (see</span>
<span class="sd">        :meth:`SplitDistribution.sum_of_split_support_on_tree()`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree : |Tree|</span>
<span class="sd">            The tree for which the score should be calculated.</span>
<span class="sd">        is_bipartitions_updated : bool</span>
<span class="sd">            If |True|, then the splits are assumed to have already been encoded</span>
<span class="sd">            and will not be updated on the trees.</span>
<span class="sd">        include_external_splits : bool</span>
<span class="sd">            If |True|, then non-internal split posteriors will be included in</span>
<span class="sd">            the score. Defaults to |False|: these are skipped. This should only</span>
<span class="sd">            make a difference when dealing with splits collected from trees of</span>
<span class="sd">            different leaf sets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : numeric</span>
<span class="sd">            The log product of the support of the splits of the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log_product_of_split_support</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">split_support</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_support_iter</span><span class="p">(</span>
                <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="n">is_bipartitions_updated</span><span class="p">,</span>
                <span class="n">include_external_splits</span><span class="o">=</span><span class="n">include_external_splits</span><span class="p">,</span>
                <span class="n">traversal_strategy</span><span class="o">=</span><span class="s2">&quot;preorder&quot;</span><span class="p">,</span>
                <span class="p">):</span>
            <span class="k">if</span> <span class="n">split_support</span><span class="p">:</span>
                <span class="n">log_product_of_split_support</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">split_support</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">log_product_of_split_support</span></div>


<div class="viewcode-block" id="SplitDistribution.sum_of_split_support_on_tree">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution.sum_of_split_support_on_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">sum_of_split_support_on_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">include_external_splits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the sum of the support of the splits of the tree, where the</span>
<span class="sd">        support is given by the proportional frequency of the split in the</span>
<span class="sd">        current distribtion.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree : |Tree|</span>
<span class="sd">            The tree for which the score should be calculated.</span>
<span class="sd">        is_bipartitions_updated : bool</span>
<span class="sd">            If |True|, then the splits are assumed to have already been encoded</span>
<span class="sd">            and will not be updated on the trees.</span>
<span class="sd">        include_external_splits : bool</span>
<span class="sd">            If |True|, then non-internal split posteriors will be included in</span>
<span class="sd">            the score. Defaults to |False|: these are skipped. This should only</span>
<span class="sd">            make a difference when dealing with splits collected from trees of</span>
<span class="sd">            different leaf sets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : numeric</span>
<span class="sd">            The sum of the support of the splits of the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sum_of_split_support</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">split_support</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_support_iter</span><span class="p">(</span>
                <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="n">is_bipartitions_updated</span><span class="p">,</span>
                <span class="n">include_external_splits</span><span class="o">=</span><span class="n">include_external_splits</span><span class="p">,</span>
                <span class="n">traversal_strategy</span><span class="o">=</span><span class="s2">&quot;preorder&quot;</span><span class="p">,</span>
                <span class="p">):</span>
            <span class="n">sum_of_split_support</span> <span class="o">+=</span> <span class="n">split_support</span>
        <span class="k">return</span> <span class="n">sum_of_split_support</span></div>


<div class="viewcode-block" id="SplitDistribution.collapse_edges_with_less_than_minimum_support">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution.collapse_edges_with_less_than_minimum_support">[docs]</a>
    <span class="k">def</span> <span class="nf">collapse_edges_with_less_than_minimum_support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">min_freq</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">GREATER_THAN_HALF</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collapse edges on tree that have support less than indicated by</span>
<span class="sd">        ``min_freq``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_rooted</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_counted_trees_rooted</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tree is interpreted as unrooted, but split support is based on rooted trees&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_rooted</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_counted_trees_treated_as_unrooted</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tree is interpreted as rooted, but split support is based on unrooted trees&quot;</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="n">split_frequencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_split_frequencies</span><span class="p">()</span>
        <span class="n">to_collapse</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_bitmask</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">split_frequencies</span><span class="p">:</span>
                <span class="n">to_collapse</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">split_frequencies</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_freq</span><span class="p">:</span>
                <span class="n">to_collapse</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">to_collapse</span><span class="p">:</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="n">adjust_collapsed_head_children_edge_lengths</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="SplitDistribution.consensus_tree">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution.consensus_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">consensus_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">min_freq</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">GREATER_THAN_HALF</span><span class="p">,</span>
            <span class="n">is_rooted</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">summarize_splits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">split_summarization_kwargs</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a consensus tree from splits in ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        min_freq : real</span>
<span class="sd">            The minimum frequency of a split in this distribution for it to be</span>
<span class="sd">            added to the tree.</span>

<span class="sd">        is_rooted : bool</span>
<span class="sd">            Should tree be rooted or not? If *all* trees counted for splits are</span>
<span class="sd">            explicitly rooted or unrooted, then this will default to |True| or</span>
<span class="sd">            |False|, respectively. Otherwise it defaults to |None|.</span>

<span class="sd">        \*\*split_summarization_kwargs : keyword arguments</span>
<span class="sd">            These will be passed directly to the underlying</span>
<span class="sd">            `SplitDistributionSummarizer` object. See</span>
<span class="sd">            :meth:`SplitDistributionSummarizer.configure` for options.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : consensus tree</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_rooted</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_counted_trees_rooted</span><span class="p">():</span>
                <span class="n">is_rooted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_counted_trees_strictly_unrooted</span><span class="p">():</span>
                <span class="n">is_rooted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">split_frequencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_split_frequencies</span><span class="p">()</span>
        <span class="n">to_try_to_add</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_almost_one</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.0000001</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">split_frequencies</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">split_frequencies</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">min_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">min_freq</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">_almost_one</span><span class="p">(</span><span class="n">min_freq</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_almost_one</span><span class="p">(</span><span class="n">freq</span><span class="p">)):</span>
                <span class="n">to_try_to_add</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">freq</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
        <span class="n">to_try_to_add</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">splits_for_tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_try_to_add</span><span class="p">]</span>
        <span class="n">con_tree</span> <span class="o">=</span> <span class="n">treemodel</span><span class="o">.</span><span class="n">Tree</span><span class="o">.</span><span class="n">from_split_bitmasks</span><span class="p">(</span>
                <span class="n">split_bitmasks</span><span class="o">=</span><span class="n">splits_for_tree</span><span class="p">,</span>
                <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">,</span>
                <span class="n">is_rooted</span><span class="o">=</span><span class="n">is_rooted</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">summarize_splits</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summarize_splits_on_tree</span><span class="p">(</span>
                <span class="n">tree</span><span class="o">=</span><span class="n">con_tree</span><span class="p">,</span>
                <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">split_summarization_kwargs</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">con_tree</span></div>


<div class="viewcode-block" id="SplitDistribution.summarize_splits_on_tree">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistribution.summarize_splits_on_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">summarize_splits_on_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">split_summarization_kwargs</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summarizes support of splits/edges/node on tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        tree: |Tree| instance</span>
<span class="sd">            Tree to be decorated with support values.</span>

<span class="sd">        is_bipartitions_updated: bool</span>
<span class="sd">            If |True|, then bipartitions will not be recalculated.</span>

<span class="sd">        \*\*split_summarization_kwargs : keyword arguments</span>
<span class="sd">            These will be passed directly to the underlying</span>
<span class="sd">            `SplitDistributionSummarizer` object. See</span>
<span class="sd">            :meth:`SplitDistributionSummarizer.configure` for options.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">TaxonNamespaceIdentityError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_decorator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_decorator</span> <span class="o">=</span> <span class="n">SplitDistributionSummarizer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_decorator</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="o">**</span><span class="n">split_summarization_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_decorator</span><span class="o">.</span><span class="n">summarize_splits_on_tree</span><span class="p">(</span>
                <span class="n">split_distribution</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="n">is_bipartitions_updated</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span></div>


    <span class="c1">###########################################################################</span>
    <span class="c1">### legacy</span>

    <span class="k">def</span> <span class="nf">_get_taxon_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">dendropy</span> <span class="kn">import</span> <span class="n">taxonmodel</span>
        <span class="n">taxonmodel</span><span class="o">.</span><span class="n">taxon_set_deprecation_warning</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>

    <span class="k">def</span> <span class="nf">_set_taxon_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">dendropy</span> <span class="kn">import</span> <span class="n">taxonmodel</span>
        <span class="n">taxonmodel</span><span class="o">.</span><span class="n">taxon_set_deprecation_warning</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">_del_taxon_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">dendropy</span> <span class="kn">import</span> <span class="n">taxonmodel</span>
        <span class="n">taxonmodel</span><span class="o">.</span><span class="n">taxon_set_deprecation_warning</span><span class="p">()</span>

    <span class="n">taxon_set</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_taxon_set</span><span class="p">,</span> <span class="n">_set_taxon_set</span><span class="p">,</span> <span class="n">_del_taxon_set</span><span class="p">)</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">### SplitDistributionSummarizer</span>

<div class="viewcode-block" id="SplitDistributionSummarizer">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistributionSummarizer">[docs]</a>
<span class="k">class</span> <span class="nc">SplitDistributionSummarizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See :meth:`SplitDistributionSummarizer.configure` for configuration</span>
<span class="sd">        options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="SplitDistributionSummarizer.configure">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.SplitDistributionSummarizer.configure">[docs]</a>
    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure rendition/mark-up.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        set_edge_lengths : string</span>
<span class="sd">            For each edge, set the length based on:</span>

<span class="sd">                - &quot;support&quot;: use support values split corresponding to edge</span>
<span class="sd">                - &quot;mean-length&quot;: mean of edge lengths for split</span>
<span class="sd">                - &quot;median-length&quot;: median of edge lengths for split</span>
<span class="sd">                - &quot;mean-age&quot;: such that split age is equal to mean of ages</span>
<span class="sd">                - &quot;median-age&quot;: such that split age is equal to mean of ages</span>
<span class="sd">                - |None|: do not set edge lengths</span>

<span class="sd">        add_support_as_node_attribute: bool</span>
<span class="sd">            Adds each node&#39;s support value as an attribute of the node,</span>
<span class="sd">            &quot;``support``&quot;.</span>

<span class="sd">        add_support_as_node_annotation: bool</span>
<span class="sd">            Adds support as a metadata annotation, &quot;``support``&quot;. If</span>
<span class="sd">            ``add_support_as_node_attribute`` is |True|, then the value will be</span>
<span class="sd">            dynamically-bound to the value of the node&#39;s &quot;``support``&quot; attribute.</span>

<span class="sd">        set_support_as_node_label : bool</span>
<span class="sd">            Sets the ``label`` attribute of each node to the support value.</span>

<span class="sd">        add_node_age_summaries_as_node_attributes: bool</span>
<span class="sd">            Summarizes the distribution of the ages of each node in the</span>
<span class="sd">            following attributes:</span>

<span class="sd">                - ``age_mean``</span>
<span class="sd">                - ``age_median``</span>
<span class="sd">                - ``age_sd``</span>
<span class="sd">                - ``age_hpd95``</span>
<span class="sd">                - ``age_range``</span>

<span class="sd">        add_node_age_summaries_as_node_annotations: bool</span>
<span class="sd">            Summarizes the distribution of the ages of each node in the</span>
<span class="sd">            following metadata annotations:</span>

<span class="sd">                - ``age_mean``</span>
<span class="sd">                - ``age_median``</span>
<span class="sd">                - ``age_sd``</span>
<span class="sd">                - ``age_hpd95``</span>
<span class="sd">                - ``age_range``</span>

<span class="sd">            If ``add_node_age_summaries_as_node_attributes`` is |True|, then the</span>
<span class="sd">            values will be dynamically-bound to the corresponding node</span>
<span class="sd">            attributes.</span>

<span class="sd">        add_edge_length_summaries_as_edge_attributes: bool</span>
<span class="sd">            Summarizes the distribution of the lengths of each edge in the</span>
<span class="sd">            following attribtutes:</span>

<span class="sd">                - ``length_mean``</span>
<span class="sd">                - ``length_median``</span>
<span class="sd">                - ``length_sd``</span>
<span class="sd">                - ``length_hpd95``</span>
<span class="sd">                - ``length_range``</span>

<span class="sd">        add_edge_length_summaries_as_edge_annotations: bool</span>
<span class="sd">            Summarizes the distribution of the lengths of each edge in the</span>
<span class="sd">            following metadata annotations:</span>

<span class="sd">                - ``length_mean``</span>
<span class="sd">                - ``length_median``</span>
<span class="sd">                - ``length_sd``</span>
<span class="sd">                - ``length_hpd95``</span>
<span class="sd">                - ``length_range``</span>

<span class="sd">            If ``add_edge_length_summaries_as_edge_attributes`` is |True|, then the</span>
<span class="sd">            values will be dynamically-bound to the corresponding edge</span>
<span class="sd">            attributes.</span>

<span class="sd">        support_label_decimals: int</span>
<span class="sd">            Number of decimal places to express when rendering the support</span>
<span class="sd">            value as a string for the node label.</span>

<span class="sd">        support_as_percentages: bool</span>
<span class="sd">            Whether or not to express the support value as percentages (default</span>
<span class="sd">            is probability or proportion).</span>

<span class="sd">        minimum_edge_length : numeric</span>
<span class="sd">            All edge lengths calculated to have a value less than this will be</span>
<span class="sd">            set to this.</span>

<span class="sd">        error_on_negative_edge_lengths : bool</span>
<span class="sd">            If |True|, an inferred edge length that is less than 0 will result</span>
<span class="sd">            in a ValueError.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;set_edge_lengths&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_support_as_node_attribute</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_support_as_node_attribute&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_support_as_node_annotation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_support_as_node_annotation&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_support_as_node_label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;set_support_as_node_label&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_node_age_summaries_as_node_attributes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_node_age_summaries_as_node_attributes&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_node_age_summaries_as_node_annotations</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_node_age_summaries_as_node_annotations&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edge_length_summaries_as_edge_attributes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_edge_length_summaries_as_edge_attributes&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edge_length_summaries_as_edge_annotations</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;add_edge_length_summaries_as_edge_annotations&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">support_label_decimals</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;support_label_decimals&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">support_as_percentages</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;support_as_percentages&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">support_label_compose_fn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;support_label_compose_fn&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primary_fieldnames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;support&quot;</span><span class="p">,]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summary_stats_fieldnames</span> <span class="o">=</span> <span class="n">SplitDistribution</span><span class="o">.</span><span class="n">SUMMARY_STATS_FIELDNAMES</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_data_values</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;hpd95&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;quant_5_95&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_age_summaries_fieldnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s2">&quot;age_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary_stats_fieldnames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_length_summaries_fieldnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s2">&quot;length_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary_stats_fieldnames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_fieldnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_age_summaries_fieldnames</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_length_summaries_fieldnames</span>
        <span class="k">for</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldnames</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_attr_name&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldname</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_attr_name&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldname</span><span class="p">),</span> <span class="n">fieldname</span><span class="p">))</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_annotation_name&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldname</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_annotation_name&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldname</span><span class="p">),</span> <span class="n">fieldname</span><span class="p">))</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;is_</span><span class="si">{}</span><span class="s2">_annotation_dynamic&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldname</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;is_</span><span class="si">{}</span><span class="s2">_annotation_dynamic&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldname</span><span class="p">),</span> <span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_edge_length</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;minimum_edge_length&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_on_negative_edge_lengths</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;error_on_negative_edge_lengths&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unrecognized or unsupported arguments: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="nf">_decorate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">target</span><span class="p">,</span>
            <span class="n">fieldname</span><span class="p">,</span>
            <span class="n">value</span><span class="p">,</span>
            <span class="n">set_attribute</span><span class="p">,</span>
            <span class="n">set_annotation</span><span class="p">,</span>
            <span class="p">):</span>
        <span class="n">attr_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_attr_name&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldname</span><span class="p">))</span>
        <span class="n">annotation_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_annotation_name&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldname</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">set_attribute</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">set_annotation</span><span class="p">:</span>
                <span class="n">target</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">annotation_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;is_</span><span class="si">{}</span><span class="s2">_annotation_dynamic&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)):</span>
                    <span class="n">target</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">add_bound_attribute</span><span class="p">(</span>
                        <span class="n">attr_name</span><span class="o">=</span><span class="n">attr_name</span><span class="p">,</span>
                        <span class="n">annotation_name</span><span class="o">=</span><span class="n">annotation_name</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span>
                            <span class="n">name</span><span class="o">=</span><span class="n">annotation_name</span><span class="p">,</span>
                            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">set_annotation</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">annotation_name</span><span class="p">)</span>
            <span class="n">target</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">annotation_name</span><span class="p">,</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">summarize_splits_on_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">split_distribution</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">split_distribution</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">TaxonNamespaceIdentityError</span><span class="p">(</span><span class="n">split_distribution</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bipartitions_updated</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_label_compose_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">support_label_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">freq</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_label_compose_fn</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">support_label_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">freq</span><span class="p">:</span> <span class="s2">&quot;{:.</span><span class="si">{places}</span><span class="s2">f}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">support_label_decimals</span><span class="p">)</span>
        <span class="n">node_age_summaries</span> <span class="o">=</span> <span class="n">split_distribution</span><span class="o">.</span><span class="n">split_node_age_summaries</span>
        <span class="n">edge_length_summaries</span> <span class="o">=</span> <span class="n">split_distribution</span><span class="o">.</span><span class="n">split_edge_length_summaries</span>
        <span class="n">split_freqs</span> <span class="o">=</span> <span class="n">split_distribution</span><span class="o">.</span><span class="n">split_frequencies</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_age_summaries_fieldnames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">summary_stats_fieldnames</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
            <span class="n">split_bitmask</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_bitmask</span>
            <span class="n">split_support</span> <span class="o">=</span> <span class="n">split_freqs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">split_bitmask</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_as_percentages</span><span class="p">:</span>
                <span class="n">split_support</span> <span class="o">=</span> <span class="n">split_support</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decorate</span><span class="p">(</span>
                <span class="n">target</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                <span class="n">fieldname</span><span class="o">=</span><span class="s2">&quot;support&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">split_support</span><span class="p">,</span>
                <span class="n">set_attribute</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">add_support_as_node_attribute</span><span class="p">,</span>
                <span class="n">set_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">add_support_as_node_annotation</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_support_as_node_label</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">support_label_fn</span><span class="p">(</span><span class="n">split_support</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_node_age_summaries_as_node_attributes</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_node_age_summaries_as_node_annotations</span><span class="p">)</span> <span class="ow">and</span> <span class="n">node_age_summaries</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">stats_fieldname</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_age_summaries_fieldnames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary_stats_fieldnames</span><span class="p">):</span>
                    <span class="n">no_data_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_data_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">stats_fieldname</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">node_age_summaries</span> <span class="ow">or</span> <span class="n">split_bitmask</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_age_summaries</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">no_data_value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">node_age_summaries</span><span class="p">[</span><span class="n">split_bitmask</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">stats_fieldname</span><span class="p">,</span> <span class="n">no_data_value</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_decorate</span><span class="p">(</span>
                        <span class="n">target</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                        <span class="n">fieldname</span><span class="o">=</span><span class="n">fieldname</span><span class="p">,</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">set_attribute</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">add_node_age_summaries_as_node_attributes</span><span class="p">,</span>
                        <span class="n">set_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">add_node_age_summaries_as_node_annotations</span><span class="p">,</span>
                        <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_edge_length_summaries_as_edge_attributes</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_edge_length_summaries_as_edge_annotations</span><span class="p">)</span> <span class="ow">and</span> <span class="n">edge_length_summaries</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">stats_fieldname</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_length_summaries_fieldnames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary_stats_fieldnames</span><span class="p">):</span>
                    <span class="n">no_data_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_data_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">stats_fieldname</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">edge_length_summaries</span> <span class="ow">or</span> <span class="n">split_bitmask</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_length_summaries</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">no_data_value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">edge_length_summaries</span><span class="p">[</span><span class="n">split_bitmask</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">stats_fieldname</span><span class="p">,</span> <span class="n">no_data_value</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_decorate</span><span class="p">(</span>
                        <span class="n">target</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="p">,</span>
                        <span class="n">fieldname</span><span class="o">=</span><span class="n">fieldname</span><span class="p">,</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">set_attribute</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">add_edge_length_summaries_as_edge_attributes</span><span class="p">,</span>
                        <span class="n">set_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">add_edge_length_summaries_as_edge_annotations</span><span class="p">,</span>
                        <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="o">==</span> <span class="s2">&quot;keep&quot;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="o">==</span> <span class="s2">&quot;support&quot;</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">split_support</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="o">==</span> <span class="s2">&quot;clear&quot;</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;mean-age&quot;</span><span class="p">,</span> <span class="s2">&quot;median-age&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node_age_summaries</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node ages not available&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="o">==</span> <span class="s2">&quot;mean-age&quot;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">node_age_summaries</span><span class="p">[</span><span class="n">split_bitmask</span><span class="p">][</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_data_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="o">==</span> <span class="s2">&quot;median-age&quot;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">node_age_summaries</span><span class="p">[</span><span class="n">split_bitmask</span><span class="p">][</span><span class="s2">&quot;median&quot;</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_data_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;mean-length&quot;</span><span class="p">,</span> <span class="s2">&quot;median-length&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">edge_length_summaries</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge lengths not available&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="o">==</span> <span class="s2">&quot;mean-length&quot;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">edge_length_summaries</span><span class="p">[</span><span class="n">split_bitmask</span><span class="p">][</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_data_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="o">==</span> <span class="s2">&quot;median-length&quot;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">edge_length_summaries</span><span class="p">[</span><span class="n">split_bitmask</span><span class="p">][</span><span class="s2">&quot;median&quot;</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_data_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_edge_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_edge_length</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_edge_length</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;mean-age&quot;</span><span class="p">,</span> <span class="s2">&quot;median-age&quot;</span><span class="p">):</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">set_edge_lengths_from_node_ages</span><span class="p">(</span>
                    <span class="n">minimum_edge_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_edge_length</span><span class="p">,</span>
                    <span class="n">error_on_negative_edge_lengths</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">error_on_negative_edge_lengths</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_lengths</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;keep&quot;</span><span class="p">,</span> <span class="s2">&quot;clear&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_edge_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_edge_length</span>
                <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_edge_length</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_edge_length</span>
        <span class="k">return</span> <span class="n">tree</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">### TreeArray</span>

<div class="viewcode-block" id="TreeArray">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray">[docs]</a>
<span class="k">class</span> <span class="nc">TreeArray</span><span class="p">(</span>
        <span class="n">taxonmodel</span><span class="o">.</span><span class="n">TaxonNamespaceAssociated</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">MultiReadable</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    High-performance collection of tree structures.</span>

<span class="sd">    Storage of minimal tree structural information as represented by toplogy</span>
<span class="sd">    and edge lengths, minimizing memory and processing time.</span>
<span class="sd">    This class stores trees as collections of splits and edge lengths. All</span>
<span class="sd">    other information, such as labels, metadata annotations, etc. will be</span>
<span class="sd">    discarded. A full |Tree| instance can be reconstructed as needed</span>
<span class="sd">    from the structural information stored by this class, at the cost of</span>
<span class="sd">    computation time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TreeArray.IncompatibleTreeArrayUpdate">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.IncompatibleTreeArrayUpdate">[docs]</a>
    <span class="k">class</span> <span class="nc">IncompatibleTreeArrayUpdate</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="TreeArray.IncompatibleRootingTreeArrayUpdate">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.IncompatibleRootingTreeArrayUpdate">[docs]</a>
    <span class="k">class</span> <span class="nc">IncompatibleRootingTreeArrayUpdate</span><span class="p">(</span><span class="n">IncompatibleTreeArrayUpdate</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="TreeArray.IncompatibleEdgeLengthsTreeArrayUpdate">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.IncompatibleEdgeLengthsTreeArrayUpdate">[docs]</a>
    <span class="k">class</span> <span class="nc">IncompatibleEdgeLengthsTreeArrayUpdate</span><span class="p">(</span><span class="n">IncompatibleTreeArrayUpdate</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="TreeArray.IncompatibleNodeAgesTreeArrayUpdate">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.IncompatibleNodeAgesTreeArrayUpdate">[docs]</a>
    <span class="k">class</span> <span class="nc">IncompatibleNodeAgesTreeArrayUpdate</span><span class="p">(</span><span class="n">IncompatibleTreeArrayUpdate</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="TreeArray.IncompatibleTreeWeightsTreeArrayUpdate">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.IncompatibleTreeWeightsTreeArrayUpdate">[docs]</a>
    <span class="k">class</span> <span class="nc">IncompatibleTreeWeightsTreeArrayUpdate</span><span class="p">(</span><span class="n">IncompatibleTreeArrayUpdate</span><span class="p">):</span>
        <span class="k">pass</span></div>


    <span class="c1">##############################################################################</span>
    <span class="c1">## Factory Function</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_tree_list</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">trees</span><span class="p">,</span>
            <span class="n">is_rooted_trees</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ignore_edge_lengths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">ignore_node_ages</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">use_tree_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">DEFAULT_ULTRAMETRICITY_PRECISION</span><span class="p">,</span>
            <span class="n">is_force_max_age</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">taxon_label_age_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>
        <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">trees</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="n">ta</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">,</span>
            <span class="n">is_rooted_trees</span><span class="o">=</span><span class="n">is_rooted_trees</span><span class="p">,</span>
            <span class="n">ignore_edge_lengths</span><span class="o">=</span><span class="n">ignore_edge_lengths</span><span class="p">,</span>
            <span class="n">ignore_node_ages</span><span class="o">=</span><span class="n">ignore_node_ages</span><span class="p">,</span>
            <span class="n">use_tree_weights</span><span class="o">=</span><span class="n">use_tree_weights</span><span class="p">,</span>
            <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">ultrametricity_precision</span><span class="p">,</span>
            <span class="n">is_force_max_age</span><span class="o">=</span><span class="n">is_force_max_age</span><span class="p">,</span>
            <span class="n">taxon_label_age_map</span><span class="o">=</span><span class="n">taxon_label_age_map</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">add_trees</span><span class="p">(</span>
                <span class="n">trees</span><span class="o">=</span><span class="n">trees</span><span class="p">,</span>
                <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="n">is_bipartitions_updated</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ta</span>

    <span class="c1">##############################################################################</span>
    <span class="c1">## Life-Cycle</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">taxon_namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">is_rooted_trees</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ignore_edge_lengths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">ignore_node_ages</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">use_tree_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">DEFAULT_ULTRAMETRICITY_PRECISION</span><span class="p">,</span>
            <span class="n">is_force_max_age</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">taxon_label_age_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxon_namespace : |TaxonNamespace|</span>
<span class="sd">            The operational taxonomic unit concept namespace to manage taxon</span>
<span class="sd">            references.</span>
<span class="sd">        is_rooted_trees : bool</span>
<span class="sd">            If not set, then it will be set based on the rooting state of the</span>
<span class="sd">            first tree added. If |True|, then trying to add an unrooted tree</span>
<span class="sd">            will result in an error. If |False|, then trying to add a rooted</span>
<span class="sd">            tree will result in an error.</span>
<span class="sd">        ignore_edge_lengths : bool</span>
<span class="sd">            If |True|, then edge lengths of splits will not be stored. If</span>
<span class="sd">            |False|, then edge lengths will be stored.</span>
<span class="sd">        ignore_node_ages : bool</span>
<span class="sd">            If |True|, then node ages of splits will not be stored. If</span>
<span class="sd">            |False|, then node ages will be stored.</span>
<span class="sd">        use_tree_weights : bool</span>
<span class="sd">            If |False|, then tree weights will not be used to weight splits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxonmodel</span><span class="o">.</span><span class="n">TaxonNamespaceAssociated</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">)</span>

        <span class="c1"># Configuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span> <span class="o">=</span> <span class="n">is_rooted_trees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_edge_lengths</span> <span class="o">=</span> <span class="n">ignore_edge_lengths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_node_ages</span> <span class="o">=</span> <span class="n">ignore_node_ages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_tree_weights</span> <span class="o">=</span> <span class="n">use_tree_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_edge_length_value</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># edge.length of |None| gets this value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_type</span> <span class="o">=</span> <span class="n">treemodel</span><span class="o">.</span><span class="n">Tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taxon_label_age_map</span> <span class="o">=</span> <span class="n">taxon_label_age_map</span>

        <span class="c1"># Storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_edge_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_leafset_bitmasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span> <span class="o">=</span> <span class="n">SplitDistribution</span><span class="p">(</span>
                <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">,</span>
                <span class="n">ignore_edge_lengths</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore_edge_lengths</span><span class="p">,</span>
                <span class="n">ignore_node_ages</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore_node_ages</span><span class="p">,</span>
                <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">ultrametricity_precision</span><span class="p">,</span>
                <span class="n">is_force_max_age</span><span class="o">=</span><span class="n">is_force_max_age</span><span class="p">,</span>
                <span class="n">taxon_label_age_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_label_age_map</span><span class="p">,</span>
                <span class="p">)</span>

    <span class="c1">##############################################################################</span>
    <span class="c1">## Book-Keeping</span>

    <span class="k">def</span> <span class="nf">_get_is_rooted_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span>
    <span class="n">is_rooted_trees</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_rooted_trees</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_split_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span>
    <span class="n">split_distribution</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_split_distribution</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate_rooting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rooting_of_other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span> <span class="o">=</span> <span class="n">rooting_of_other</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span> <span class="o">!=</span> <span class="n">rooting_of_other</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span><span class="p">:</span>
                <span class="n">ta</span> <span class="o">=</span> <span class="s2">&quot;rooted&quot;</span>
                <span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;unrooted&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ta</span> <span class="o">=</span> <span class="s2">&quot;unrooted&quot;</span>
                <span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;rooted&quot;</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">MixedRootingError</span><span class="p">(</span><span class="s2">&quot;Cannot add </span><span class="si">{tree_rooting}</span><span class="s2"> tree to TreeArray with </span><span class="si">{tree_array_rooting}</span><span class="s2"> trees&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">tree_rooting</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                <span class="n">tree_array_rooting</span><span class="o">=</span><span class="n">ta</span><span class="p">))</span>

    <span class="c1">##############################################################################</span>
    <span class="c1">## Updating from Another TreeArray</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># self.validate_rooting(other._is_rooted_trees)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_is_rooted_trees</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TreeArray</span><span class="o">.</span><span class="n">IncompatibleRootingTreeArrayUpdate</span><span class="p">(</span><span class="s2">&quot;Updating from incompatible TreeArray: &#39;is_rooted_trees&#39; should be &#39;</span><span class="si">{}</span><span class="s2">&#39;, but is instead &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_is_rooted_trees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span><span class="p">,</span> <span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_edge_lengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">ignore_edge_lengths</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TreeArray</span><span class="o">.</span><span class="n">IncompatibleEdgeLengthsTreeArrayUpdate</span><span class="p">(</span><span class="s2">&quot;Updating from incompatible TreeArray: &#39;ignore_edge_lengths&#39; is not: </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ignore_edge_lengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_edge_lengths</span><span class="p">,</span> <span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_node_ages</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">ignore_node_ages</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TreeArray</span><span class="o">.</span><span class="n">IncompatibleNodeAgesTreeArrayUpdate</span><span class="p">(</span><span class="s2">&quot;Updating from incompatible TreeArray: &#39;ignore_node_ages&#39; should be &#39;</span><span class="si">{}</span><span class="s2">&#39;, but is instead &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ignore_node_ages</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_node_ages</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_tree_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">use_tree_weights</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TreeArray</span><span class="o">.</span><span class="n">IncompatibleTreeWeightsTreeArrayUpdate</span><span class="p">(</span><span class="s2">&quot;Updating from incompatible TreeArray: &#39;use_tree_weights&#39; should be &#39;</span><span class="si">{}</span><span class="s2">&#39;, but is instead &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">use_tree_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_tree_weights</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_is_rooted_trees</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignore_edge_lengths</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ignore_edge_lengths</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignore_node_ages</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ignore_node_ages</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_tree_weights</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">use_tree_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_edge_lengths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_tree_edge_lengths</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_leafset_bitmasks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_tree_leafset_bitmasks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_weights</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_tree_weights</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_split_distribution</span><span class="p">)</span>

    <span class="c1">##############################################################################</span>
    <span class="c1">## Fundamental Tree Accession</span>

<div class="viewcode-block" id="TreeArray.add_tree">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.add_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">add_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the structure represented by a |Tree| instance to the</span>
<span class="sd">        collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree : |Tree|</span>
<span class="sd">            A |Tree| instance. This must have the same rooting state as</span>
<span class="sd">            all the other trees accessioned into this collection as well as</span>
<span class="sd">            that of ``self.is_rooted_trees``.</span>
<span class="sd">        is_bipartitions_updated : bool</span>
<span class="sd">            If |False| [default], then the tree will have its splits encoded or</span>
<span class="sd">            updated. Otherwise, if |True|, then the tree is assumed to have its</span>
<span class="sd">            splits already encoded and updated.</span>
<span class="sd">        index : integer</span>
<span class="sd">            Insert before index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the accession.</span>
<span class="sd">        s : iterable of splits</span>
<span class="sd">            A list of split bitmasks from ``tree``.</span>
<span class="sd">        e :</span>
<span class="sd">            A list of edge length values from ``tree``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">TaxonNamespaceIdentityError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_rooting</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">is_rooted</span><span class="p">)</span>
        <span class="n">splits</span><span class="p">,</span> <span class="n">edge_lengths</span><span class="p">,</span> <span class="n">node_ages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">count_splits_on_tree</span><span class="p">(</span>
                <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="n">is_bipartitions_updated</span><span class="p">,</span>
                <span class="n">default_edge_length_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_edge_length_value</span><span class="p">)</span>

        <span class="c1"># pre-process splits</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">splits</span><span class="p">)</span>

        <span class="c1"># pre-process edge lengths</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_edge_lengths</span><span class="p">:</span>
            <span class="c1"># edge_lengths = tuple( [None] * len(splits) )</span>
            <span class="n">edge_lengths</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">splits</span><span class="p">))</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">splits</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_lengths</span><span class="p">),</span> <span class="s2">&quot;Unequal vectors:</span><span class="se">\n</span><span class="s2">    Splits: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">    Edges: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">splits</span><span class="p">,</span> <span class="n">edge_lengths</span><span class="p">)</span>
            <span class="n">edge_lengths</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge_lengths</span><span class="p">)</span>

        <span class="c1"># pre-process weights</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_tree_weights</span><span class="p">:</span>
            <span class="n">weight_to_use</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weight_to_use</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># accession info</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">splits</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tree_leafset_bitmasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_bitmask</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tree_edge_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_lengths</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tree_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight_to_use</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">splits</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tree_leafset_bitmasks</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span>
                    <span class="n">tree</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">leafset_bitmask</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tree_edge_lengths</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">edge_lengths</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tree_weights</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">weight_to_use</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">index</span><span class="p">,</span> <span class="n">splits</span><span class="p">,</span> <span class="n">edge_lengths</span><span class="p">,</span> <span class="n">weight_to_use</span></div>



<div class="viewcode-block" id="TreeArray.add_trees">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.add_trees">[docs]</a>
    <span class="k">def</span> <span class="nf">add_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">,</span> <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds multiple structures represneted by an iterator over or iterable of</span>
<span class="sd">        |Tree| instances to the collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trees : iterator over or iterable of |Tree| instances</span>
<span class="sd">            An iterator over or iterable of |Tree| instances. Thess must</span>
<span class="sd">            have the same rooting state as all the other trees accessioned into</span>
<span class="sd">            this collection as well as that of ``self.is_rooted_trees``.</span>
<span class="sd">        is_bipartitions_updated : bool</span>
<span class="sd">            If |False| [default], then the tree will have its splits encoded or</span>
<span class="sd">            updated. Otherwise, if |True|, then the tree is assumed to have its</span>
<span class="sd">            splits already encoded and updated.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span>
                    <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="n">is_bipartitions_updated</span><span class="p">)</span></div>


    <span class="c1">##############################################################################</span>
    <span class="c1">## I/O</span>

<div class="viewcode-block" id="TreeArray.read_from_files">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.read_from_files">[docs]</a>
    <span class="k">def</span> <span class="nf">read_from_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">files</span><span class="p">,</span>
            <span class="n">schema</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds multiple structures from one or more external file sources to the</span>
<span class="sd">        collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files : iterable of strings and/or file objects</span>
<span class="sd">            A list or some other iterable of file paths or file-like objects</span>
<span class="sd">            (string elements will be assumed to be paths to files, while all</span>
<span class="sd">            other types of elements will be assumed to be file-like</span>
<span class="sd">            objects opened for reading).</span>
<span class="sd">        schema : string</span>
<span class="sd">            The data format of the source. E.g., &quot;nexus&quot;, &quot;newick&quot;, &quot;nexml&quot;.</span>
<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            These will be passed directly to the underlying schema-specific</span>
<span class="sd">            reader implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;taxon_namespace&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;TaxonNamespace object passed as keyword argument is not the same as self&#39;s TaxonNamespace reference&quot;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">)</span>
        <span class="n">target_tree_offset</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;tree_offset&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">tree_yielder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_type</span><span class="o">.</span><span class="n">yield_from_files</span><span class="p">(</span>
                <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">,</span>
                <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span>
                <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">current_source_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">current_tree_offset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">tree_idx</span><span class="p">,</span> <span class="n">tree</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tree_yielder</span><span class="p">):</span>
            <span class="n">current_yielder_index</span> <span class="o">=</span> <span class="n">tree_yielder</span><span class="o">.</span><span class="n">current_file_index</span>
            <span class="k">if</span> <span class="n">current_source_index</span> <span class="o">!=</span> <span class="n">current_yielder_index</span><span class="p">:</span>
                <span class="n">current_source_index</span> <span class="o">=</span> <span class="n">current_yielder_index</span>
                <span class="n">current_tree_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">current_tree_offset</span> <span class="o">&gt;=</span> <span class="n">target_tree_offset</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_tree</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span> <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">current_tree_offset</span> <span class="o">+=</span> <span class="mi">1</span></div>


    <span class="k">def</span> <span class="nf">_parse_and_add_from_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">stream</span><span class="p">,</span>
            <span class="n">schema</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cur_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_from_files</span><span class="p">(</span><span class="n">files</span><span class="o">=</span><span class="p">[</span><span class="n">stream</span><span class="p">],</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">new_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_size</span> <span class="o">-</span> <span class="n">cur_size</span>

<div class="viewcode-block" id="TreeArray.read">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.read">[docs]</a>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add |Tree| objects to existing |TreeList| from data source providing</span>
<span class="sd">        one or more collections of trees.</span>

<span class="sd">        **Mandatory Source-Specification Keyword Argument (Exactly One Required):**</span>

<span class="sd">            - **file** (*file*) -- File or file-like object of data opened for reading.</span>
<span class="sd">            - **path** (*str*) -- Path to file of data.</span>
<span class="sd">            - **url** (*str*) -- URL of data.</span>
<span class="sd">            - **data** (*str*) -- Data given directly.</span>

<span class="sd">        **Mandatory Schema-Specification Keyword Argument:**</span>

<span class="sd">            - **schema** (*str*) -- Identifier of format of data given by the</span>
<span class="sd">              &quot;``file``&quot;, &quot;``path``&quot;, &quot;``data``&quot;, or &quot;``url``&quot; argument</span>
<span class="sd">              specified above: &quot;:doc:`newick &lt;/schemas/newick&gt;`&quot;, &quot;:doc:`nexus</span>
<span class="sd">              &lt;/schemas/nexus&gt;`&quot;, or &quot;:doc:`nexml &lt;/schemas/nexml&gt;`&quot;. See</span>
<span class="sd">              &quot;|Schemas|&quot; for more details.</span>

<span class="sd">        **Optional General Keyword Arguments:**</span>

<span class="sd">            - **collection_offset** (*int*) -- 0-based index of tree block or</span>
<span class="sd">              collection in source to be parsed. If not specified then the</span>
<span class="sd">              first collection (offset = 0) is assumed.</span>
<span class="sd">            - **tree_offset** (*int*) -- 0-based index of first tree within the</span>
<span class="sd">              collection specified by ``collection_offset`` to be parsed (i.e.,</span>
<span class="sd">              skipping the first ``tree_offset`` trees). If not</span>
<span class="sd">              specified, then the first tree (offset = 0) is assumed (i.e., no</span>
<span class="sd">              trees within the specified collection will be skipped). Use this</span>
<span class="sd">              to specify, e.g. a burn-in.</span>
<span class="sd">            - **ignore_unrecognized_keyword_arguments** (*bool*) -- If |True|,</span>
<span class="sd">              then unsupported or unrecognized keyword arguments will not</span>
<span class="sd">              result in an error. Default is |False|: unsupported keyword</span>
<span class="sd">              arguments will result in an error.</span>

<span class="sd">        **Optional Schema-Specific Keyword Arguments:**</span>

<span class="sd">            These provide control over how the data is interpreted and</span>
<span class="sd">            processed, and supported argument names and values depend on</span>
<span class="sd">            the schema as specified by the value passed as the &quot;``schema``&quot;</span>
<span class="sd">            argument. See &quot;|Schemas|&quot; for more details.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        ::</span>

<span class="sd">            tree_array = dendropy.TreeArray()</span>
<span class="sd">            tree_array.read(</span>
<span class="sd">                    file=open(&#39;treefile.tre&#39;, &#39;rU&#39;),</span>
<span class="sd">                    schema=&quot;newick&quot;,</span>
<span class="sd">                    tree_offset=100)</span>
<span class="sd">            tree_array.read(</span>
<span class="sd">                    path=&#39;sometrees.nexus&#39;,</span>
<span class="sd">                    schema=&quot;nexus&quot;,</span>
<span class="sd">                    collection_offset=2,</span>
<span class="sd">                    tree_offset=100)</span>
<span class="sd">            tree_array.read(</span>
<span class="sd">                    data=&quot;((A,B),(C,D));((A,C),(B,D));&quot;,</span>
<span class="sd">                    schema=&quot;newick&quot;)</span>
<span class="sd">            tree_array.read(</span>
<span class="sd">                    url=&quot;http://api.opentreeoflife.org/v2/study/pg_1144/tree/tree2324.nex&quot;,</span>
<span class="sd">                    schema=&quot;nexus&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">basemodel</span><span class="o">.</span><span class="n">MultiReadable</span><span class="o">.</span><span class="n">_read_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="c1">##############################################################################</span>
    <span class="c1">## Container (List) Interface</span>

<div class="viewcode-block" id="TreeArray.append">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.append">[docs]</a>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a |Tree| instance to the collection before position given</span>
<span class="sd">        by ``index``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree : |Tree|</span>
<span class="sd">            A |Tree| instance. This must have the same rooting state as</span>
<span class="sd">            all the other trees accessioned into this collection as well as</span>
<span class="sd">            that of ``self.is_rooted_trees``.</span>
<span class="sd">        is_bipartitions_updated : bool</span>
<span class="sd">            If |False| [default], then the tree will have its splits encoded or</span>
<span class="sd">            updated. Otherwise, if |True|, then the tree is assumed to have its</span>
<span class="sd">            splits already encoded and updated.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_tree</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="n">is_bipartitions_updated</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeArray.insert">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.insert">[docs]</a>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a |Tree| instance to the collection before position given</span>
<span class="sd">        by ``index``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : integer</span>
<span class="sd">            Insert before index.</span>
<span class="sd">        tree : |Tree|</span>
<span class="sd">            A |Tree| instance. This must have the same rooting state as</span>
<span class="sd">            all the other trees accessioned into this collection as well as</span>
<span class="sd">            that of ``self.is_rooted_trees``.</span>
<span class="sd">        is_bipartitions_updated : bool</span>
<span class="sd">            If |False| [default], then the tree will have its splits encoded or</span>
<span class="sd">            updated. Otherwise, if |True|, then the tree is assumed to have its</span>
<span class="sd">            splits already encoded and updated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the accession.</span>
<span class="sd">        s : iterable of splits</span>
<span class="sd">            A list of split bitmasks from ``tree``.</span>
<span class="sd">        e :</span>
<span class="sd">            A list of edge length values ``tree``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_tree</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="n">is_bipartitions_updated</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeArray.extend">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.extend">[docs]</a>
    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Accession of data from ``tree_array`` to self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree_array : |TreeArray|</span>
<span class="sd">            A |TreeArray| instance from which to add data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="n">tree_array</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span> <span class="ow">is</span> <span class="n">tree_array</span><span class="o">.</span><span class="n">_is_rooted_trees</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_edge_lengths</span> <span class="ow">is</span> <span class="n">tree_array</span><span class="o">.</span><span class="n">ignore_edge_lengths</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_node_ages</span> <span class="ow">is</span> <span class="n">tree_array</span><span class="o">.</span><span class="n">ignore_node_ages</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_tree_weights</span> <span class="ow">is</span> <span class="n">tree_array</span><span class="o">.</span><span class="n">use_tree_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tree_array</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_edge_lengths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tree_array</span><span class="o">.</span><span class="n">_tree_edge_lengths</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_weights</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tree_array</span><span class="o">.</span><span class="n">_tree_weights</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tree_array</span><span class="o">.</span><span class="n">_split_distribution</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="TreeArray.__iadd__">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.__iadd__">[docs]</a>
    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Accession of data from ``tree_array`` to self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree_array : |TreeArray|</span>
<span class="sd">            A |TreeArray| instance from which to add data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tree_array</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeArray.__add__">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.__add__">[docs]</a>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns new |TreeArray|.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : iterable of |Tree| objects</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tlist : |TreeArray| object</span>
<span class="sd">            |TreeArray| object containing clones of |Tree| objects</span>
<span class="sd">            in ``self`` and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ta</span> <span class="o">=</span> <span class="n">TreeArray</span><span class="p">(</span>
                <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">,</span>
                <span class="n">is_rooted_trees</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span><span class="p">,</span>
                <span class="n">ignore_edge_lengths</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore_edge_lengths</span><span class="p">,</span>
                <span class="n">ignore_node_ages</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore_node_ages</span><span class="p">,</span>
                <span class="n">use_tree_weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_tree_weights</span><span class="p">,</span>
                <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">ultrametricity_precision</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">default_edge_length_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_edge_length_value</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">tree_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_type</span>
        <span class="n">ta</span> <span class="o">+=</span> <span class="bp">self</span>
        <span class="n">ta</span> <span class="o">+=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">ta</span></div>


    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splits</span><span class="p">):</span>
        <span class="c1"># expensive!!</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">splits</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="c1"># expensive!!</span>
        <span class="c1"># tree_split_bitmasks = self._trees_splits[index]</span>
        <span class="c1">### TODO: remove this &quot;tree&quot; from underlying splits distribution</span>
        <span class="c1"># for split in tree_split_bitmasks:</span>
        <span class="c1">#   self._split_distribution.split_counts[split] -= 1</span>
        <span class="c1"># etc.</span>
        <span class="c1"># becomes complicated because tree weights need to be updated etc.</span>
        <span class="c1"># del self._tree_split_bitmasks[index]</span>
        <span class="c1"># del self._tree_edge_lengths[index]</span>
        <span class="c1"># return</span>

<div class="viewcode-block" id="TreeArray.__iter__">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.__iter__">[docs]</a>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yields pairs of (split, edge_length) from the store.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">split</span><span class="p">,</span> <span class="n">edge_length</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_edge_lengths</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">split</span><span class="p">,</span> <span class="n">edge_length</span></div>


    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="c1"># &quot;&quot;&quot;</span>
        <span class="c1"># Returns a pair of tuples, ( (splits...), (lengths...) ), corresponding</span>
        <span class="c1"># to the &quot;tree&quot; at ``index``.</span>
        <span class="c1"># &quot;&quot;&quot;</span>
        <span class="c1"># return self._tree_split_bitmasks[index], self._tree_edge_lengths[index]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_edge_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_leafset_bitmasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splits</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">splits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1">##############################################################################</span>
    <span class="c1">## Accessors/Settors</span>

<div class="viewcode-block" id="TreeArray.get_split_bitmask_and_edge_tuple">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.get_split_bitmask_and_edge_tuple">[docs]</a>
    <span class="k">def</span> <span class="nf">get_split_bitmask_and_edge_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a pair of tuples, ( (splits...), (lengths...) ), corresponding</span>
<span class="sd">        to the &quot;tree&quot; at ``index``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_edge_lengths</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>


    <span class="c1">##############################################################################</span>
    <span class="c1">## Calculations</span>

<div class="viewcode-block" id="TreeArray.calculate_log_product_of_split_supports">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.calculate_log_product_of_split_supports">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_log_product_of_split_supports</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">include_external_splits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the log product of split support for each of the trees in</span>
<span class="sd">        the collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_external_splits : bool</span>
<span class="sd">            If |True|, then non-internal split posteriors will be included in</span>
<span class="sd">            the score. Defaults to |False|: these are skipped. This should only</span>
<span class="sd">            make a difference when dealing with splits collected from trees of</span>
<span class="sd">            different leaf sets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : tuple(list[numeric], integer)</span>
<span class="sd">            Returns a tuple, with the first element being the list of scores</span>
<span class="sd">            and the second being the index of the highest score. The element order</span>
<span class="sd">            corresponds to the trees accessioned in the collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_leafset_bitmasks</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_score</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_score_tree_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">split_frequencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">split_frequencies</span>
        <span class="k">for</span> <span class="n">tree_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">tree_leafset_bitmask</span><span class="p">,</span> <span class="n">split_bitmasks</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_leafset_bitmasks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)):</span>
            <span class="n">log_product_of_split_support</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">split_bitmask</span> <span class="ow">in</span> <span class="n">split_bitmasks</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">include_external_splits</span>
                        <span class="ow">or</span> <span class="n">split_bitmask</span> <span class="o">==</span> <span class="n">tree_leafset_bitmask</span> <span class="c1"># count root edge (following BEAST)</span>
                        <span class="ow">or</span> <span class="ow">not</span> <span class="n">treemodel</span><span class="o">.</span><span class="n">Bipartition</span><span class="o">.</span><span class="n">is_trivial_bitmask</span><span class="p">(</span><span class="n">split_bitmask</span><span class="p">,</span> <span class="n">tree_leafset_bitmask</span><span class="p">)</span>
                        <span class="p">):</span>
                    <span class="n">split_support</span> <span class="o">=</span> <span class="n">split_frequencies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">split_bitmask</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">split_support</span><span class="p">:</span>
                        <span class="n">log_product_of_split_support</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">split_support</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_score</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_score</span> <span class="o">&lt;</span> <span class="n">log_product_of_split_support</span><span class="p">:</span>
                <span class="n">max_score</span> <span class="o">=</span> <span class="n">log_product_of_split_support</span>
                <span class="n">max_score_tree_idx</span> <span class="o">=</span> <span class="n">tree_idx</span>
            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">log_product_of_split_support</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scores</span><span class="p">,</span> <span class="n">max_score_tree_idx</span></div>


<div class="viewcode-block" id="TreeArray.maximum_product_of_split_support_tree">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.maximum_product_of_split_support_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">maximum_product_of_split_support_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">include_external_splits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">summarize_splits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">split_summarization_kwargs</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tree with that maximizes the product of split supports, also</span>
<span class="sd">        known as the &quot;Maximum Clade Credibility Tree&quot; or MCCT.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_external_splits : bool</span>
<span class="sd">            If |True|, then non-internal split posteriors will be included in</span>
<span class="sd">            the score. Defaults to |False|: these are skipped. This should only</span>
<span class="sd">            make a difference when dealing with splits collected from trees of</span>
<span class="sd">            different leaf sets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mcct_tree : Tree</span>
<span class="sd">            Tree that maximizes the product of split supports.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores</span><span class="p">,</span> <span class="n">max_score_tree_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_log_product_of_split_supports</span><span class="p">(</span>
                <span class="n">include_external_splits</span><span class="o">=</span><span class="n">include_external_splits</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">restore_tree</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="n">max_score_tree_idx</span><span class="p">,</span>
                <span class="o">**</span><span class="n">split_summarization_kwargs</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">log_product_of_split_support</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">max_score_tree_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">summarize_splits</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">summarize_splits_on_tree</span><span class="p">(</span>
                <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="o">**</span><span class="n">split_summarization_kwargs</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span></div>


<div class="viewcode-block" id="TreeArray.calculate_sum_of_split_supports">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.calculate_sum_of_split_supports">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_sum_of_split_supports</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">include_external_splits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the *sum* of split support for all trees in the</span>
<span class="sd">        collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_external_splits : bool</span>
<span class="sd">            If |True|, then non-internal split posteriors will be included in</span>
<span class="sd">            the score. Defaults to |False|: these are skipped. This should only</span>
<span class="sd">            make a difference when dealing with splits collected from trees of</span>
<span class="sd">            different leaf sets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : tuple(list[numeric], integer)</span>
<span class="sd">            Returns a tuple, with the first element being the list of scores</span>
<span class="sd">            and the second being the index of the highest score. The element order</span>
<span class="sd">            corresponds to the trees accessioned in the collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_leafset_bitmasks</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_score</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_score_tree_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">split_frequencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">split_frequencies</span>
        <span class="k">for</span> <span class="n">tree_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">tree_leafset_bitmask</span><span class="p">,</span> <span class="n">split_bitmasks</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_leafset_bitmasks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)):</span>
            <span class="n">sum_of_support</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">split_bitmask</span> <span class="ow">in</span> <span class="n">split_bitmasks</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">include_external_splits</span>
                        <span class="ow">or</span> <span class="n">split_bitmask</span> <span class="o">==</span> <span class="n">tree_leafset_bitmask</span> <span class="c1"># count root edge (following BEAST)</span>
                        <span class="ow">or</span> <span class="ow">not</span> <span class="n">treemodel</span><span class="o">.</span><span class="n">Bipartition</span><span class="o">.</span><span class="n">is_trivial_bitmask</span><span class="p">(</span><span class="n">split_bitmask</span><span class="p">,</span> <span class="n">tree_leafset_bitmask</span><span class="p">)</span>
                        <span class="p">):</span>
                    <span class="n">split_support</span> <span class="o">=</span> <span class="n">split_frequencies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">split_bitmask</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="n">sum_of_support</span> <span class="o">+=</span> <span class="n">split_support</span>
            <span class="k">if</span> <span class="n">max_score</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_score</span> <span class="o">&lt;</span> <span class="n">sum_of_support</span><span class="p">:</span>
                <span class="n">max_score</span> <span class="o">=</span> <span class="n">sum_of_support</span>
                <span class="n">max_score_tree_idx</span> <span class="o">=</span> <span class="n">tree_idx</span>
            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_of_support</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scores</span><span class="p">,</span> <span class="n">max_score_tree_idx</span></div>


<div class="viewcode-block" id="TreeArray.maximum_sum_of_split_support_tree">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.maximum_sum_of_split_support_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">maximum_sum_of_split_support_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">include_external_splits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">summarize_splits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">split_summarization_kwargs</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tree with that maximizes the *sum* of split supports.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_external_splits : bool</span>
<span class="sd">            If |True|, then non-internal split posteriors will be included in</span>
<span class="sd">            the score. Defaults to |False|: these are skipped. This should only</span>
<span class="sd">            make a difference when dealing with splits collected from trees of</span>
<span class="sd">            different leaf sets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mst_tree : Tree</span>
<span class="sd">            Tree that maximizes the sum of split supports.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores</span><span class="p">,</span> <span class="n">max_score_tree_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_sum_of_split_supports</span><span class="p">(</span>
                <span class="n">include_external_splits</span><span class="o">=</span><span class="n">include_external_splits</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">restore_tree</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="n">max_score_tree_idx</span><span class="p">,</span>
                <span class="o">**</span><span class="n">split_summarization_kwargs</span>
                <span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">sum_of_split_support</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">max_score_tree_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">summarize_splits</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">summarize_splits_on_tree</span><span class="p">(</span>
                <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="o">**</span><span class="n">split_summarization_kwargs</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span></div>


    <span class="k">def</span> <span class="nf">collapse_edges_with_less_than_minimum_support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">min_freq</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">GREATER_THAN_HALF</span><span class="p">,</span>
            <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_distribution</span><span class="o">.</span><span class="n">collapse_edges_with_less_than_minimum_support</span><span class="p">(</span>
                <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="n">min_freq</span><span class="p">)</span>

<div class="viewcode-block" id="TreeArray.consensus_tree">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.consensus_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">consensus_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">min_freq</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">GREATER_THAN_HALF</span><span class="p">,</span>
            <span class="n">summarize_splits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">split_summarization_kwargs</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a consensus tree from splits in ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        min_freq : real</span>
<span class="sd">            The minimum frequency of a split in this distribution for it to be</span>
<span class="sd">            added to the tree.</span>

<span class="sd">        is_rooted : bool</span>
<span class="sd">            Should tree be rooted or not? If *all* trees counted for splits are</span>
<span class="sd">            explicitly rooted or unrooted, then this will default to |True| or</span>
<span class="sd">            |False|, respectively. Otherwise it defaults to |None|.</span>

<span class="sd">        \*\*split_summarization_kwargs : keyword arguments</span>
<span class="sd">            These will be passed directly to the underlying</span>
<span class="sd">            `SplitDistributionSummarizer` object. See</span>
<span class="sd">            :meth:`SplitDistributionSummarizer.configure` for options.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : consensus tree</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">consensus_tree</span><span class="p">(</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">is_rooted</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_rooted_trees</span><span class="p">,</span>
                <span class="n">summarize_splits</span><span class="o">=</span><span class="n">summarize_splits</span><span class="p">,</span>
                <span class="o">**</span><span class="n">split_summarization_kwargs</span>
                <span class="p">)</span>
        <span class="c1"># return self._split_distribution.consensus_tree(*args, **kwargs)</span>
        <span class="k">return</span> <span class="n">tree</span></div>


    <span class="c1">##############################################################################</span>
    <span class="c1">## Mapping of Split Support</span>

    <span class="k">def</span> <span class="nf">summarize_splits_on_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">TaxonNamespaceIdentityError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">summarize_splits_on_tree</span><span class="p">(</span>
            <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
            <span class="n">is_bipartitions_updated</span><span class="o">=</span><span class="n">is_bipartitions_updated</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

    <span class="c1">##############################################################################</span>
    <span class="c1">## Tree Reconstructions</span>

    <span class="k">def</span> <span class="nf">restore_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">summarize_splits_on_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">split_summarization_kwargs</span>
            <span class="p">):</span>
        <span class="n">split_bitmasks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_edge_lengths</span><span class="p">:</span>
            <span class="n">split_edge_lengths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_edge_lengths</span><span class="p">)</span>
            <span class="n">edge_lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_edge_lengths</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">split_edge_lengths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">split_bitmasks</span><span class="p">,</span> <span class="n">edge_lengths</span><span class="p">))</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_type</span><span class="o">.</span><span class="n">from_split_bitmasks</span><span class="p">(</span>
                <span class="n">split_bitmasks</span><span class="o">=</span><span class="n">split_bitmasks</span><span class="p">,</span>
                <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">,</span>
                <span class="n">is_rooted</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span><span class="p">,</span>
                <span class="n">split_edge_lengths</span><span class="o">=</span><span class="n">split_edge_lengths</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># if update_bipartitions:</span>
        <span class="c1">#     tree.encode_bipartitions()</span>
        <span class="k">if</span> <span class="n">summarize_splits_on_tree</span><span class="p">:</span>
            <span class="n">split_summarization_kwargs</span><span class="p">[</span><span class="s2">&quot;is_bipartitions_updated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">summarize_splits_on_tree</span><span class="p">(</span>
                    <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">split_summarization_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span>

    <span class="c1">##############################################################################</span>
    <span class="c1">## Topology Frequencies</span>

<div class="viewcode-block" id="TreeArray.split_bitmask_set_frequencies">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.split_bitmask_set_frequencies">[docs]</a>
    <span class="k">def</span> <span class="nf">split_bitmask_set_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary with keys being sets of split bitmasks and values</span>
<span class="sd">        being the frequency of occurrence of trees represented by those split</span>
<span class="sd">        bitmask sets in the collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">split_bitmask_set_count_map</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_weights</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">split_bitmask_set</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_split_bitmasks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_weights</span><span class="p">):</span>
            <span class="n">split_bitmask_set_count_map</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">split_bitmask_set</span><span class="p">)]</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span>
        <span class="n">split_bitmask_set_freqs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">normalization_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_distribution</span><span class="o">.</span><span class="n">calc_normalization_weight</span><span class="p">()</span>
        <span class="c1"># print(&quot;===&gt; {}&quot;.format(normalization_weight))</span>
        <span class="k">for</span> <span class="n">split_bitmask_set</span> <span class="ow">in</span> <span class="n">split_bitmask_set_count_map</span><span class="p">:</span>
            <span class="n">split_bitmask_set_freqs</span><span class="p">[</span><span class="n">split_bitmask_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">split_bitmask_set_count_map</span><span class="p">[</span><span class="n">split_bitmask_set</span><span class="p">]</span> <span class="o">/</span> <span class="n">normalization_weight</span>
        <span class="k">return</span> <span class="n">split_bitmask_set_freqs</span></div>


<div class="viewcode-block" id="TreeArray.bipartition_encoding_frequencies">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.bipartition_encoding_frequencies">[docs]</a>
    <span class="k">def</span> <span class="nf">bipartition_encoding_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary with keys being bipartition encodings of trees</span>
<span class="sd">        (as ``frozenset`` collections of |Bipartition| objects) and</span>
<span class="sd">        values the frequency of occurrence of trees represented by that</span>
<span class="sd">        encoding in the collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># split_bitmask_set_freqs = self.split_bitmask_set_frequencies()</span>
        <span class="c1"># bipartition_encoding_freqs = {}</span>
        <span class="c1"># for split_bitmask_set, freq in split_bitmask_set_freqs.items():</span>
        <span class="c1">#     bipartition_encoding = []</span>
        <span class="c1">#     inferred_leafset = max(split_bitmask_set)</span>
        <span class="c1">#     for split_bitmask in split_bitmask_set:</span>
        <span class="c1">#         bipartition = treemodel.Bipartition(</span>
        <span class="c1">#                 bitmask=split_bitmask,</span>
        <span class="c1">#                 tree_leafset_bitmask=inferred_leafset,</span>
        <span class="c1">#                 is_rooted=self._is_rooted_trees,</span>
        <span class="c1">#                 is_mutable=False,</span>
        <span class="c1">#                 compile_bipartition=True,</span>
        <span class="c1">#                 )</span>
        <span class="c1">#         bipartition_encoding.append(bipartition)</span>
        <span class="c1">#     bipartition_encoding_freqs[frozenset(bipartition_encoding)] = freq</span>
        <span class="c1"># return bipartition_encoding_freqs</span>
        <span class="n">bipartition_encoding_freqs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">topologies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topologies</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">topologies</span><span class="p">:</span>
            <span class="n">bipartition_encoding_freqs</span><span class="p">[</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">())</span> <span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">frequency</span>
        <span class="k">return</span> <span class="n">bipartition_encoding_freqs</span></div>


<div class="viewcode-block" id="TreeArray.topologies">
<a class="viewcode-back" href="../../../library/treecollectionmodel.html#dendropy.datamodel.treecollectionmodel.TreeArray.topologies">[docs]</a>
    <span class="k">def</span> <span class="nf">topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">sort_descending</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">frequency_attr_name</span><span class="o">=</span><span class="s2">&quot;frequency&quot;</span><span class="p">,</span>
            <span class="n">frequency_annotation_name</span><span class="o">=</span><span class="s2">&quot;frequency&quot;</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a |TreeList| instance containing the reconstructed tree</span>
<span class="sd">        topologies (i.e. |Tree| instances with no edge weights) in the</span>
<span class="sd">        collection, with the frequency added as an attributed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sort_descending : bool</span>
<span class="sd">            If |True|, then topologies will be sorted in *descending* frequency</span>
<span class="sd">            order (i.e., topologies with the highest frequencies will be listed</span>
<span class="sd">            first). If |False|, then they will be sorted in *ascending*</span>
<span class="sd">            frequency. If |None| (default), then they will not be sorted.</span>
<span class="sd">        frequency_attr_name : str</span>
<span class="sd">            Name of attribute to add to each |Tree| representing</span>
<span class="sd">            the frequency of that topology in the collection. If |None|</span>
<span class="sd">            then the attribute will not be added.</span>
<span class="sd">        frequency_annotation_name : str</span>
<span class="sd">            Name of annotation to add to the annotations of each |Tree|,</span>
<span class="sd">            representing the frequency of that topology in the collection. The</span>
<span class="sd">            value of this annotation will be dynamically-bound to the attribute</span>
<span class="sd">            specified by ``frequency_attr_name`` unless that is |None|. If</span>
<span class="sd">            ``frequency_annotation_name`` is |None| then the annotation will not</span>
<span class="sd">            be added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sort_descending</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frequency_attr_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attribute needs to be set on topologies to enable sorting&quot;</span><span class="p">)</span>
        <span class="n">split_bitmask_set_freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_bitmask_set_frequencies</span><span class="p">()</span>
        <span class="n">topologies</span> <span class="o">=</span> <span class="n">TreeList</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">split_bitmask_set</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">split_bitmask_set_freqs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_type</span><span class="o">.</span><span class="n">from_split_bitmasks</span><span class="p">(</span>
                    <span class="n">split_bitmasks</span><span class="o">=</span><span class="n">split_bitmask_set</span><span class="p">,</span>
                    <span class="n">taxon_namespace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">,</span>
                    <span class="n">is_rooted</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_rooted_trees</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">frequency_attr_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">frequency_attr_name</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">frequency_annotation_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tree</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">add_bound_attribute</span><span class="p">(</span>
                        <span class="n">attr_name</span><span class="o">=</span><span class="n">frequency_attr_name</span><span class="p">,</span>
                        <span class="n">annotation_name</span><span class="o">=</span><span class="n">frequency_annotation_name</span><span class="p">,</span>
                        <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span>
                    <span class="n">frequency_annotation_name</span><span class="p">,</span>
                    <span class="n">freq</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="n">topologies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sort_descending</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">topologies</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">frequency_attr_name</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="n">sort_descending</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">topologies</span></div>
</div>




</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div style="text-align: center; padding-top: 20px; padding-bottom: 5px; width: 100%;">
    <a href="../../../index.html"><img src="../../../_static/dendropy_logo.png" /></a>
</div><div style="clear:both; width: 100%; height:1px;"></div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div>
    <!-- Documentation -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Documentation</h3>
        <ul>
            <li><a href="../../../primer/downloading.html">Downloading and Installing DendroPy</a></li>
            <li><a href="../../../primer/index.html">The DendroPy Primer</a></li>
            <li><a href="../../../library/index.html">Library API Reference</a></li>
            <li>
                <a href="../../../schemas/index.html">Schemas</a>
                <ul>
                    <li><a href="../../../schemas/fasta.html">FASTA</a></li>
                    <li><a href="../../../schemas/newick.html">Newick</a></li>
                    <li><a href="../../../schemas/nexml.html">NeXML</a></li>
                    <li><a href="../../../schemas/nexus.html">Nexus</a></li>
                    <li><a href="../../../schemas/phylip.html">PHYLIP</a></li>
                </ul>
            </li>
            <li>
                <a href="../../../programs/index.html">Programs</a>
                <ul>
                    <li><a href="../../../programs/sumtrees.html">SumTrees</a></li>
                </ul>
            </li>
            <li><a href="../../../glossary.html">Glossary and Terminological Reference</a></li>
            <li><a href="../../../developer.html">Developer Guide</a></li>
            <li><a href="../../../planning.html">Ongoing Development</a></li>
            <li><a href="../../../changes.html">Change History</a></li>
        </ul>
    </div>

    <!-- Downloads -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Obtaining</h3>
        <ul>
            <li><a target="_blank" href="http://pypi.python.org/pypi/DendroPy">Install from the Python Package Index</a></li>
            <li><a target="_blank" href="http://pypi.python.org/packages/source/D/DendroPy/DendroPy-5.0.5.tar.gz">Download the Source Code Archive</a></li>
            <li><a target="_blank" href="http://github.com/jeetsukumaran/DendroPy">Clone the Source Code Repository</a></li>
        </ul>
    </div>

    <!-- Discussions -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Discussion</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot; DendroPy Users&quot; </a>group to follow and participate in discussion, troubleshooting, help, information, suggestions, etc. on the usage and development of the DendroPy phylogenetic computing library.</p>
            <form action="http://groups.google.com/group/dendropy-users/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot;dendropy-users&quot;</a> group, or click <a href="http://groups.google.com/group/dendropy-users?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Announcements -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Announcements</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; DendroPy Announcements&quot; </a>group to receive announcements of new releases, updates, changes and other news of interest to DendroPy users and developers.</p>
            <form action="http://groups.google.com/group/dendropy-announce/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; dendropy-announce&quot; </a>group, or click <a href="http://groups.google.com/group/dendropy-announce?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Development -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative; padding-bottom: 15px; margin-bottom:5px;">
        <h3><span style="text-align: left"><a href="https://github.com/jeetsukumaran/DendroPy/">Development</a></span><a href="https://github.com/jeetsukumaran/DendroPy/"><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/Octocat.png" height="30px" alt="GitHub" /></span></a></h3>
        <div style="margin-top: 15px;">
            <!-- <a href="https://github.com/jeetsukumaran/DendroPy/issues">Issues</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/subscription">Watch</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/fork">Fork</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/stargazers">Star</a> &bull; <a href="https://github.com/jeetsukumaran/">Follow</a> -->
            <ul>
                <li>                <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/issues"><code>Issues</code></a></span> <span style="font-style: italic; font-size:80%;"> - Report bugs or request features</span></li>
                <li>     <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/subscription"><code>&nbsp;Watch</code></a></span> <span style="font-style: italic; font-size:80%;"> - Follow development activity</span></li>
                <li>        <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/fork"><code>&nbsp;&nbsp;Fork</code></a></span> <span style="font-style: italic; font-size:80%;"> - Contribute and collaborate</span></li>
                <li>  <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/stargazers"><code>&nbsp;&nbsp;Star</code></a></span> <span style="font-style: italic; font-size:80%;"> - Throw some glitter, add some glamour</span></li>
        </div>
    </div>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DendroPy 5.0.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.datamodel.treecollectionmodel</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2009-2025, Jeet Sukumaran and Mark T. Holder.
    </div>
  </body>
</html>