<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dendropy.datamodel.basemodel &#8212; DendroPy 5.0.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/rtd.css?v=cedc6a2f" />
    
    <script src="../../../_static/documentation_options.js?v=a185d276"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DendroPy 5.0.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.datamodel.basemodel</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for dendropy.datamodel.basemodel</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1">##############################################################################</span>
<span class="c1">##  DendroPy Phylogenetic Computing Library.</span>
<span class="c1">##</span>
<span class="c1">##  Copyright 2010-2015 Jeet Sukumaran and Mark T. Holder.</span>
<span class="c1">##  All rights reserved.</span>
<span class="c1">##</span>
<span class="c1">##  See &quot;LICENSE.rst&quot; for terms and conditions of usage.</span>
<span class="c1">##</span>
<span class="c1">##  If you use this work or any portion thereof in published work,</span>
<span class="c1">##  please cite it as:</span>
<span class="c1">##</span>
<span class="c1">##     Sukumaran, J. and M. T. Holder. 2010. DendroPy: a Python library</span>
<span class="c1">##     for phylogenetic computing. Bioinformatics 26: 1569-1571.</span>
<span class="c1">##</span>
<span class="c1">##############################################################################</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Infrastructure for phylogenetic data objects.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">container</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">bibtex</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">textprocessing</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">urlio</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">error</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">deprecate</span>

<span class="c1">##############################################################################</span>
<span class="c1">## Keyword Processor</span>

<span class="k">def</span> <span class="nf">_extract_serialization_target_keyword</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">target_type</span><span class="p">):</span>
    <span class="n">target_type_keywords</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;path&quot;</span><span class="p">,</span> <span class="s2">&quot;url&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;stream&quot;</span><span class="p">,</span> <span class="s2">&quot;string&quot;</span><span class="p">]</span>
    <span class="n">found_kw</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">target_type_keywords</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">found_kw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">found_kw</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> not specified; exactly one of the following keyword arguments required to be specified: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_type</span><span class="p">,</span> <span class="n">target_type_keywords</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">found_kw</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> specified multiple times: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_type</span><span class="p">,</span> <span class="n">found_kw</span><span class="p">))</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">found_kw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="s2">&quot;schema&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Mandatory keyword argument &#39;schema&#39; not specified&quot;</span><span class="p">)</span>
    <span class="n">schema</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;schema&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">found_kw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">,</span> <span class="n">schema</span>

<span class="c1">##############################################################################</span>
<span class="c1">## DataObject</span>

<div class="viewcode-block" id="DataObject">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.DataObject">[docs]</a>
<span class="k">class</span> <span class="nc">DataObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all phylogenetic data objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>
    <span class="k">def</span> <span class="nf">_set_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># self._label = str(v) if v is not None else v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">v</span>
    <span class="n">label</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_label</span><span class="p">,</span> <span class="n">_set_label</span><span class="p">)</span>

<div class="viewcode-block" id="DataObject.clone">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.DataObject.clone">[docs]</a>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns a copy of ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        depth : integer</span>
<span class="sd">            The depth of the copy:</span>

<span class="sd">                - 0: shallow-copy: All member objects are references,</span>
<span class="sd">                  except for :attr:``annotation_set`` of top-level object and</span>
<span class="sd">                  member |Annotation| objects: these are full,</span>
<span class="sd">                  independent instances (though any complex objects in the</span>
<span class="sd">                  ``value`` field of |Annotation| objects are also</span>
<span class="sd">                  just references).</span>
<span class="sd">                - 1: taxon-namespace-scoped copy: All member objects are full</span>
<span class="sd">                  independent instances, *except* for |TaxonNamespace|</span>
<span class="sd">                  and |Taxon| instances: these are references.</span>
<span class="sd">                - 2: Exhaustive deep-copy: all objects are cloned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace_scoped_copy</span><span class="p">(</span><span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported cloning depth: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">depth</span><span class="p">))</span></div>


<div class="viewcode-block" id="DataObject.taxon_namespace_scoped_copy">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.DataObject.taxon_namespace_scoped_copy">[docs]</a>
    <span class="k">def</span> <span class="nf">taxon_namespace_scoped_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cloning level: 1.</span>
<span class="sd">        Taxon-namespace-scoped copy: All member objects are full independent</span>
<span class="sd">        instances, *except* for |TaxonNamespace| and |Taxon|</span>
<span class="sd">        objects: these are preserved as references.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
</div>


<span class="c1">##############################################################################</span>
<span class="c1">## Deserializable</span>

<span class="k">class</span> <span class="nc">Deserializable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class which all classes that require deserialization should subclass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_parse_and_create_from_stream</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subclasses need to implement this method to create</span>
<span class="sd">        and return and instance of themselves read from the</span>
<span class="sd">        stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_from</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory method to return new object of this class from an external</span>
<span class="sd">        source by dispatching calls to more specialized ``get_from_*`` methods.</span>
<span class="sd">        Implementing classes will have a publically-exposed method, ``get()``,</span>
<span class="sd">        that wraps a call to this method. This allows for class-specific</span>
<span class="sd">        documentation of keyword arguments. E.g.::</span>

<span class="sd">            @classmethod</span>
<span class="sd">            def get(cls, **kwargs):</span>
<span class="sd">                &#39;&#39;&#39;</span>
<span class="sd">                ... (documentation) ...</span>
<span class="sd">                &#39;&#39;&#39;</span>
<span class="sd">                return cls._get_from(**kwargs)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">src_type</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">_extract_serialization_target_keyword</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="s2">&quot;Source&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="k">if</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span> <span class="ow">or</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;stream&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_from_stream</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;path&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_from_path</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span> <span class="ow">or</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_from_string</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;url&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_from_url</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported source type: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src_type</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_from_stream</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory method to return new object of this class from file-like object</span>
<span class="sd">        ``src``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src : file or file-like</span>
<span class="sd">            Source of data.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Specification of data format (e.g., &quot;nexus&quot;).</span>
<span class="sd">        kwargs : keyword arguments, optional</span>
<span class="sd">            Arguments to customize parsing, instantiation, processing, and</span>
<span class="sd">            accession of objects read from the data source, including schema-</span>
<span class="sd">            or format-specific handling. These will be passed to the underlying</span>
<span class="sd">            schema-specific reader for handling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdo : phylogenetic data object</span>
<span class="sd">            New instance of object, constructed and populated from data given</span>
<span class="sd">            in source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_and_create_from_stream</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">src</span><span class="p">,</span>
                <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_from_path</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory method to return new object of this class from file</span>
<span class="sd">        specified by string ``src``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src : string</span>
<span class="sd">            Full file path to source of data.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Specification of data format (e.g., &quot;nexus&quot;).</span>
<span class="sd">        kwargs : keyword arguments, optional</span>
<span class="sd">            Arguments to customize parsing, instantiation, processing, and</span>
<span class="sd">            accession of objects read from the data source, including schema-</span>
<span class="sd">            or format-specific handling. These will be passed to the underlying</span>
<span class="sd">            schema-specific reader for handling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdo : phylogenetic data object</span>
<span class="sd">            New instance of object, constructed and populated from data given</span>
<span class="sd">            in source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">open_args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;rU&quot;</span><span class="p">]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">open_args</span><span class="p">)</span> <span class="k">as</span> <span class="n">fsrc</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_and_create_from_stream</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">fsrc</span><span class="p">,</span>
                    <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_from_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory method to return new object of this class from string ``src``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src : string</span>
<span class="sd">            Data as a string.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Specification of data format (e.g., &quot;nexus&quot;).</span>
<span class="sd">        kwargs : keyword arguments, optional</span>
<span class="sd">            Arguments to customize parsing, instantiation, processing, and</span>
<span class="sd">            accession of objects read from the data source, including schema-</span>
<span class="sd">            or format-specific handling. These will be passed to the underlying</span>
<span class="sd">            schema-specific reader for handling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdo : phylogenetic data object</span>
<span class="sd">            New instance of object, constructed and populated from data given</span>
<span class="sd">            in source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ssrc</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_and_create_from_stream</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">ssrc</span><span class="p">,</span>
                <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_from_url</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">strip_markup</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory method to return a new object of this class from</span>
<span class="sd">        URL given by ``src``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src : string</span>
<span class="sd">            URL of location providing source of data.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Specification of data format (e.g., &quot;nexus&quot;).</span>
<span class="sd">        kwargs : keyword arguments, optional</span>
<span class="sd">            Arguments to customize parsing, instantiation, processing, and</span>
<span class="sd">            accession of objects read from the data source, including schema-</span>
<span class="sd">            or format-specific handling. These will be passed to the underlying</span>
<span class="sd">            schema-specific reader for handling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdo : phylogenetic data object</span>
<span class="sd">            New instance of object, constructed and populated from data given</span>
<span class="sd">            in source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">urlio</span><span class="o">.</span><span class="n">read_url</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">strip_markup</span><span class="o">=</span><span class="n">strip_markup</span><span class="p">)</span>
        <span class="n">ssrc</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_and_create_from_stream</span><span class="p">(</span>
                    <span class="n">stream</span><span class="o">=</span><span class="n">ssrc</span><span class="p">,</span>
                    <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">error</span><span class="o">.</span><span class="n">DataParseError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">exc</span><span class="o">.</span><span class="n">url_text</span> <span class="o">=</span> <span class="n">text</span>
            <span class="k">raise</span>

<span class="c1">##############################################################################</span>
<span class="c1">## MultiReadabe</span>

<span class="k">class</span> <span class="nc">MultiReadable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class which all classes that support multiple (e.g., aggregative) deserialization should subclass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_parse_and_add_from_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populates/constructs objects of this type from ``schema``-formatted</span>
<span class="sd">        data in the file-like object source ``stream``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : file or file-like</span>
<span class="sd">            Source of data.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Specification of data format (e.g., &quot;nexus&quot;).</span>
<span class="sd">        kwargs : keyword arguments, optional</span>
<span class="sd">            Arguments to customize parsing, instantiation, processing, and</span>
<span class="sd">            accession of objects read from the data source, including schema-</span>
<span class="sd">            or format-specific handling. These will be passed to the underlying</span>
<span class="sd">            schema-specific reader for handling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : ``int`` or ``tuple`` [``int``]</span>
<span class="sd">            A value indicating size of data read, where &quot;size&quot; depends on</span>
<span class="sd">            the object:</span>

<span class="sd">                - |Tree|: **undefined**</span>
<span class="sd">                - |TreeList|: number of trees</span>
<span class="sd">                - |CharacterMatrix|: number of sequences</span>
<span class="sd">                - |DataSet|: ``tuple`` (number of taxon namespaces, number of tree lists, number of matrices)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_read_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add data to objects of this class from an external</span>
<span class="sd">        source by dispatching calls to more specialized ``read_from_*`` methods.</span>
<span class="sd">        Implementing classes will have a publically-exposed method, ``read()``,</span>
<span class="sd">        that wraps a call to this method. This allows for class-specific</span>
<span class="sd">        documentation of keyword arguments. E.g.::</span>

<span class="sd">            def read(self, **kwargs):</span>
<span class="sd">                &#39;&#39;&#39;</span>
<span class="sd">                ... (documentation) ...</span>
<span class="sd">                &#39;&#39;&#39;</span>
<span class="sd">                return MultiReadable._read_from(self, **kwargs)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">src_type</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">_extract_serialization_target_keyword</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="s2">&quot;Source&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="k">if</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span> <span class="ow">or</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;stream&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_from_stream</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;path&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_from_path</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span> <span class="ow">or</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_from_string</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">src_type</span> <span class="o">==</span> <span class="s2">&quot;url&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_from_url</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported source type: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src_type</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">read_from_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads from file (exactly equivalent to just ``read()``, provided</span>
<span class="sd">        here as a separate method for completeness.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileobj : file or file-like</span>
<span class="sd">            Source of data.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Specification of data format (e.g., &quot;nexus&quot;).</span>
<span class="sd">        kwargs : keyword arguments, optional</span>
<span class="sd">            Arguments to customize parsing, instantiation, processing, and</span>
<span class="sd">            accession of objects read from the data source, including schema-</span>
<span class="sd">            or format-specific handling. These will be passed to the underlying</span>
<span class="sd">            schema-specific reader for handling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : ``tuple`` [integer]</span>
<span class="sd">            A value indicating size of data read, where &quot;size&quot; depends on</span>
<span class="sd">            the object:</span>

<span class="sd">                - |Tree|: **undefined**</span>
<span class="sd">                - |TreeList|: number of trees</span>
<span class="sd">                - |CharacterMatrix|: number of sequences</span>
<span class="sd">                - |DataSet|: ``tuple`` (number of taxon namespaces, number of tree lists, number of matrices)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_and_add_from_stream</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_from_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads data from file specified by ``filepath``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath : file or file-like</span>
<span class="sd">            Full file path to source of data.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Specification of data format (e.g., &quot;nexus&quot;).</span>
<span class="sd">        kwargs : keyword arguments, optional</span>
<span class="sd">            Arguments to customize parsing, instantiation, processing, and</span>
<span class="sd">            accession of objects read from the data source, including schema-</span>
<span class="sd">            or format-specific handling. These will be passed to the underlying</span>
<span class="sd">            schema-specific reader for handling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : ``tuple`` [integer]</span>
<span class="sd">            A value indicating size of data read, where &quot;size&quot; depends on</span>
<span class="sd">            the object:</span>

<span class="sd">                - |Tree|: **undefined**</span>
<span class="sd">                - |TreeList|: number of trees</span>
<span class="sd">                - |CharacterMatrix|: number of sequences</span>
<span class="sd">                - |DataSet|: ``tuple`` (number of taxon namespaces, number of tree lists, number of matrices)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">open_args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;rU&quot;</span><span class="p">]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">open_args</span><span class="p">)</span> <span class="k">as</span> <span class="n">fsrc</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_and_add_from_stream</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">fsrc</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_from_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads a string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_str : string</span>
<span class="sd">            Data as a string.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Specification of data format (e.g., &quot;nexus&quot;).</span>
<span class="sd">        kwargs : keyword arguments, optional</span>
<span class="sd">            Arguments to customize parsing, instantiation, processing, and</span>
<span class="sd">            accession of objects read from the data source, including schema-</span>
<span class="sd">            or format-specific handling. These will be passed to the underlying</span>
<span class="sd">            schema-specific reader for handling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : ``tuple`` [integer]</span>
<span class="sd">            A value indicating size of data read, where &quot;size&quot; depends on</span>
<span class="sd">            the object:</span>

<span class="sd">                - |Tree|: **undefined**</span>
<span class="sd">                - |TreeList|: number of trees</span>
<span class="sd">                - |CharacterMatrix|: number of sequences</span>
<span class="sd">                - |DataSet|: ``tuple`` (number of taxon namespaces, number of tree lists, number of matrices)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_and_add_from_stream</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_from_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads a URL source.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src : string</span>
<span class="sd">            URL of location providing source of data.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Specification of data format (e.g., &quot;nexus&quot;).</span>
<span class="sd">        kwargs : keyword arguments, optional</span>
<span class="sd">            Arguments to customize parsing, instantiation, processing, and</span>
<span class="sd">            accession of objects read from the data source, including schema-</span>
<span class="sd">            or format-specific handling. These will be passed to the underlying</span>
<span class="sd">            schema-specific reader for handling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : ``tuple`` [integer]</span>
<span class="sd">            A value indicating size of data read, where &quot;size&quot; depends on</span>
<span class="sd">            the object:</span>

<span class="sd">                - |Tree|: **undefined**</span>
<span class="sd">                - |TreeList|: number of trees</span>
<span class="sd">                - |CharacterMatrix|: number of sequences</span>
<span class="sd">                - |DataSet|: ``tuple`` (number of taxon namespaces, number of tree lists, number of matrices)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src_str</span> <span class="o">=</span> <span class="n">urlio</span><span class="o">.</span><span class="n">read_url</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">src_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_and_add_from_stream</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="c1">##############################################################################</span>
<span class="c1">## NonMultiReadable</span>

<span class="k">class</span> <span class="nc">NonMultiReadable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin to enforce transition from DendroPy 3 to DendroPy 4 API</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">funcname</span><span class="p">):</span>
        <span class="n">read_from_func</span> <span class="o">=</span> <span class="n">funcname</span>
        <span class="n">get_from_func</span> <span class="o">=</span> <span class="n">funcname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;read&quot;</span><span class="p">,</span> <span class="s2">&quot;get&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">((</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
                <span class="s2">&quot;The &#39;</span><span class="si">{classname}</span><span class="s2">&#39; class no longer supports           &quot;</span><span class="p">,</span>
                <span class="s2">&quot;(re-)population by re-reading data from an external  &quot;</span><span class="p">,</span>
                <span class="s2">&quot;source. Instantiate a new object using, for example, &quot;</span><span class="p">,</span>
                <span class="s2">&quot;&#39;</span><span class="si">{classname}</span><span class="s2">.</span><span class="si">{get_from_func}</span><span class="s2">()&#39; and bind it to&quot;</span><span class="p">,</span>
                <span class="s2">&quot;the variable name instead. That is, instead of:&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;    x.</span><span class="si">{read_from_func}</span><span class="s2">(...)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;use:&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;    x = </span><span class="si">{classname}</span><span class="s2">.</span><span class="si">{get_from_func}</span><span class="s2">(...)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="p">)))</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">classname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">get_from_func</span><span class="o">=</span><span class="n">get_from_func</span><span class="p">,</span> <span class="n">read_from_func</span><span class="o">=</span><span class="n">read_from_func</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">read_from_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;read_from_stream&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">read_from_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;read_from_path&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">read_from_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_str</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;read_from_string&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">read_from_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;read_from_url&quot;</span><span class="p">)</span>

<span class="c1">##############################################################################</span>
<span class="c1">## Serializable</span>

<span class="k">class</span> <span class="nc">Serializable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class which all classes that require serialization should subclass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_format_and_write_to_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the object to the file-like object ``stream`` in ``schema``</span>
<span class="sd">        schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_write_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write this object to an external resource by dispatching calls to more</span>
<span class="sd">        specialized ``write_to_*`` methods. Implementing classes will have a</span>
<span class="sd">        publically-exposed method, ``write()``, that wraps a call to this</span>
<span class="sd">        method. This allows for class-specific documentation of keyword</span>
<span class="sd">        arguments. E.g.::</span>

<span class="sd">            def write(self, **kwargs):</span>
<span class="sd">                &#39;&#39;&#39;</span>
<span class="sd">                ... (documentation) ...</span>
<span class="sd">                &#39;&#39;&#39;</span>
<span class="sd">                return Serializable._write_to(self, **kwargs)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dest_type</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">_extract_serialization_target_keyword</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="s2">&quot;Destination&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="k">if</span> <span class="n">dest_type</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_to_stream</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dest_type</span> <span class="o">==</span> <span class="s2">&quot;path&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_to_path</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported source type: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dest_type</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes out ``self`` in ``schema`` format.</span>

<span class="sd">        **Mandatory Destination-Specification Keyword Argument (Exactly One of the Following Required):**</span>

<span class="sd">            - **file** (*file*) -- File or file-like object opened for writing.</span>
<span class="sd">            - **path** (*str*) -- Path to file to which to write.</span>

<span class="sd">        **Mandatory Schema-Specification Keyword Argument:**</span>

<span class="sd">            - **schema** (*str*) -- Identifier of format of data. See</span>
<span class="sd">              &quot;|Schemas|&quot; for more details.</span>

<span class="sd">        **Optional Schema-Specific Keyword Arguments:**</span>

<span class="sd">            These provide control over how the data is formatted, and supported</span>
<span class="sd">            argument names and values depend on the schema as specified by the</span>
<span class="sd">            value passed as the &quot;``schema``&quot; argument. See &quot;|Schemas|&quot; for more</span>
<span class="sd">            details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ::</span>

<span class="sd">                # Using a file path:</span>
<span class="sd">                d.write(path=&quot;path/to/file.dat&quot;, schema=&quot;nexus&quot;)</span>

<span class="sd">                # Using an open file:</span>
<span class="sd">                with open(&quot;path/to/file.dat&quot;, &quot;w&quot;) as f:</span>
<span class="sd">                    d.write(file=f, schema=&quot;nexus&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Serializable</span><span class="o">.</span><span class="n">_write_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_to_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes to file-like object ``dest``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_and_write_to_stream</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_to_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes to file specified by ``dest``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expandvars</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">dest</span><span class="p">)),</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_and_write_to_stream</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Composes and returns string representation of the data.</span>

<span class="sd">        **Mandatory Schema-Specification Keyword Argument:**</span>

<span class="sd">            - **schema** (*str*) -- Identifier of format of data. See</span>
<span class="sd">              &quot;|Schemas|&quot; for more details.</span>

<span class="sd">        **Optional Schema-Specific Keyword Arguments:**</span>

<span class="sd">            These provide control over how the data is formatted, and supported</span>
<span class="sd">            argument names and values depend on the schema as specified by the</span>
<span class="sd">            value passed as the &quot;``schema``&quot; argument. See &quot;|Schemas|&quot; for more</span>
<span class="sd">            details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_format_and_write_to_stream</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

<span class="c1">##############################################################################</span>
<span class="c1">## Annotable</span>

<div class="viewcode-block" id="Annotable">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.Annotable">[docs]</a>
<span class="k">class</span> <span class="nc">Annotable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class which all classes that need to persist object attributes</span>
<span class="sd">    or other information as metadata should subclass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_get_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="n">AnnotationSet</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span>
    <span class="k">def</span> <span class="nf">_set_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="n">annotations</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">target</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">AnnotationSet</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set &#39;annotations&#39; to object of type &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">annotations</span><span class="p">)))</span>
        <span class="n">old_target</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="n">annotations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_attribute</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">old_target</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_annotations</span><span class="p">,</span> <span class="n">_set_annotations</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_has_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">has_annotations</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_has_annotations</span><span class="p">)</span>

<div class="viewcode-block" id="Annotable.copy_annotations_from">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.Annotable.copy_annotations_from">[docs]</a>
    <span class="k">def</span> <span class="nf">copy_annotations_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">attribute_object_mapper</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copies annotations from ``other``, which must be of |Annotable|</span>
<span class="sd">        type.</span>

<span class="sd">        Copies are deep-copies, in that the |Annotation| objects added</span>
<span class="sd">        to the ``annotation_set`` |AnnotationSet| collection of ``self`` are</span>
<span class="sd">        independent copies of those in the ``annotate_set`` collection of</span>
<span class="sd">        ``other``. However, dynamic bound-attribute annotations retain references</span>
<span class="sd">        to the original objects as given in ``other``, which may or may not be</span>
<span class="sd">        desirable. This is handled by updated the objects to which attributes</span>
<span class="sd">        are bound via mappings found in ``attribute_object_mapper``.</span>
<span class="sd">        In dynamic bound-attribute annotations, the ``_value`` attribute of the</span>
<span class="sd">        annotations object (:attr:`Annotation._value`) is a tuple consisting of</span>
<span class="sd">        &quot;``(obj, attr_name)``&quot;, which instructs the |Annotation| object to</span>
<span class="sd">        return &quot;``getattr(obj, attr_name)``&quot; (via: &quot;``getattr(*self._value)``&quot;)</span>
<span class="sd">        when returning the value of the Annotation. &quot;``obj``&quot; is typically the object</span>
<span class="sd">        to which the |AnnotationSet| belongs (i.e., ``self``). When a copy</span>
<span class="sd">        of |Annotation| is created, the object reference given in the</span>
<span class="sd">        first element of the ``_value`` tuple of dynamic bound-attribute</span>
<span class="sd">        annotations are unchanged, unless the id of the object reference is fo</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ``other`` : |Annotable|</span>
<span class="sd">            Source of annotations to copy.</span>

<span class="sd">        ``attribute_object_mapper`` : dict</span>
<span class="sd">            Like the ``memo`` of ``__deepcopy__``, maps object id&#39;s to objects. The</span>
<span class="sd">            purpose of this is to update the parent or owner objects of dynamic</span>
<span class="sd">            attribute annotations.</span>
<span class="sd">            If a dynamic attribute |Annotation|</span>
<span class="sd">            gives object ``x`` as the parent or owner of the attribute (that is,</span>
<span class="sd">            the first element of the :attr:`Annotation._value` tuple is</span>
<span class="sd">            ``other``) and ``id(x)`` is found in ``attribute_object_mapper``,</span>
<span class="sd">            then in the copy the owner of the attribute is changed to</span>
<span class="sd">            ``attribute_object_mapper[id(x)]``.</span>
<span class="sd">            If ``attribute_object_mapper`` is |None| (default), then the</span>
<span class="sd">            following mapping is automatically inserted: ``id(other): self``.</span>
<span class="sd">            That is, any references to ``other`` in any |Annotation|</span>
<span class="sd">            object will be remapped to ``self``.  If really no reattribution</span>
<span class="sd">            mappings are desired, then an empty dictionary should be passed</span>
<span class="sd">            instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attribute_object_mapper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attribute_object_mapper</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span><span class="bp">self</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">a1</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">attribute_object_mapper</span><span class="o">=</span><span class="n">attribute_object_mapper</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">a2</span><span class="o">.</span><span class="n">is_attribute</span> <span class="ow">and</span> <span class="n">a2</span><span class="o">.</span><span class="n">_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
                    <span class="n">a2</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">attribute_object_mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">other</span><span class="p">),</span> <span class="n">a2</span><span class="o">.</span><span class="n">_value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Annotable.deep_copy_annotations_from">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.Annotable.deep_copy_annotations_from">[docs]</a>
    <span class="k">def</span> <span class="nf">deep_copy_annotations_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Note that all references to ``other`` in any annotation value (and</span>
<span class="sd">        sub-annotation, and sub-sub-sub-annotation, etc.) will be</span>
<span class="sd">        replaced with references to ``self``. This may not always make sense</span>
<span class="sd">        (i.e., a reference to a particular entity may be absolute regardless of</span>
<span class="sd">        context).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">):</span>
            <span class="c1"># if not isinstance(self, other.__class__) or not isinstance(other, self.__class__):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot deep-copy annotations from different type (unable to assume object equivalence in dynamic or nested annotations)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">a1</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_annotations</span><span class="p">:</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
                <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">a1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a2</span>
                <span class="k">if</span> <span class="n">a2</span><span class="o">.</span><span class="n">is_attribute</span> <span class="ow">and</span> <span class="n">a1</span><span class="o">.</span><span class="n">_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
                    <span class="n">a2</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a1</span><span class="o">.</span><span class="n">_value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">):</span>
                <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_annotations</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span></div>


    <span class="c1"># def __copy__(self):</span>
    <span class="c1">#     o = self.__class__.__new__(self.__class__)</span>
    <span class="c1">#     for k in self.__dict__:</span>
    <span class="c1">#         if k == &quot;_annotations&quot;:</span>
    <span class="c1">#             continue</span>
    <span class="c1">#         o.__dict__[k] = self.__dict__[k]</span>
    <span class="c1">#     o.copy_annotations_from(self)</span>

<div class="viewcode-block" id="Annotable.__copy__">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.Annotable.__copy__">[docs]</a>
    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cloning level: 0.</span>
<span class="sd">        :attr:``annotation_set`` of top-level object and member |Annotation|</span>
<span class="sd">        objects are full, independent instances. All other member objects (include</span>
<span class="sd">        objects referenced by dynamically-bound attribute values of</span>
<span class="sd">        |Annotation| objects) are references.</span>
<span class="sd">        All member objects are references, except for</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy_annotations_from</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># ensure clone map</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># get or create clone of self</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># create object without initialization</span>
            <span class="c1"># other = type(self).__new__(self.__class__)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="c1"># store</span>
            <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">other</span>
        <span class="c1"># copy other attributes first, skipping annotations</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">memo</span><span class="p">)</span>
            <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="c1"># assert id(self.__dict__[k]) in memo</span>
        <span class="c1"># create annotations</span>
        <span class="n">other</span><span class="o">.</span><span class="n">deep_copy_annotations_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="c1"># return</span>
        <span class="k">return</span> <span class="n">other</span></div>


<span class="c1">##############################################################################</span>
<span class="c1">## Annotation</span>

<div class="viewcode-block" id="Annotation">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.Annotation">[docs]</a>
<span class="k">class</span> <span class="nc">Annotation</span><span class="p">(</span><span class="n">Annotable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metadata storage, composition and persistance, with the following attributes:</span>

<span class="sd">        * ``name``</span>
<span class="sd">        * ``value``</span>
<span class="sd">        * ``datatype_hint``</span>
<span class="sd">        * ``name_prefix``</span>
<span class="sd">        * ``namespace``</span>
<span class="sd">        * ``annotate_as_reference``</span>
<span class="sd">        * ``is_hidden``</span>
<span class="sd">        * ``real_value_format_specifier`` - format specifier for printing or rendering</span>
<span class="sd">          values as string, given in Python&#39;s format specification</span>
<span class="sd">          mini-language. E.g., &#39;.8f&#39;, &#39;4E&#39;, &#39;&gt;04d&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">value</span><span class="p">,</span>
            <span class="n">datatype_hint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">name_prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">name_is_prefixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">is_attribute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">annotate_as_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">is_hidden</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">real_value_format_specifier</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_attribute</span> <span class="o">=</span> <span class="n">is_attribute</span>
        <span class="k">if</span> <span class="n">name_is_prefixed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prefixed_name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">if</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_name_prefix</span> <span class="o">=</span> <span class="n">name_prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name_prefix</span> <span class="o">=</span> <span class="n">name_prefix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datatype_hint</span> <span class="o">=</span> <span class="n">datatype_hint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">namespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotate_as_reference</span> <span class="o">=</span> <span class="n">annotate_as_reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="n">is_hidden</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_value_format_specifier</span> <span class="o">=</span> <span class="n">real_value_format_specifier</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">o</span>
        <span class="c1"># if not isinstance(o, self.__class__):</span>
        <span class="c1">#     return False</span>
        <span class="c1"># if self._value != o._value:</span>
        <span class="c1">#     return False</span>
        <span class="c1"># if self.is_attribute != o.is_attribute:</span>
        <span class="c1">#     return False</span>
        <span class="c1"># if self.is_attribute and o.is_attribute:</span>
        <span class="c1">#     if getattr(*self._value) != getattr(*o._value):</span>
        <span class="c1">#         return False</span>
        <span class="c1"># # at this point, we have established that the values</span>
        <span class="c1"># # are equal</span>
        <span class="c1"># return (self.name == o.name</span>
        <span class="c1">#         and self._name_prefix == o._name_prefix</span>
        <span class="c1">#         and self.datatype_hint == o.datatype_hint</span>
        <span class="c1">#         and self._namespace == o._namespace</span>
        <span class="c1">#         and self.annotate_as_reference == o.annotate_as_reference</span>
        <span class="c1">#         and self.is_hidden == o.is_hidden</span>
        <span class="c1">#         and ( ((not hasattr(self, &quot;_annotations&quot;)) and (not hasattr(o, &quot;_annotations&quot;)))</span>
        <span class="c1">#             or (hasattr(self, &quot;_annotations&quot;) and hasattr(o, &quot;_annotations&quot;) and self._annotations == o._annotations)))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">=&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

    <span class="c1"># def __deepcopy__(self, memo=None):</span>
    <span class="c1">#     if memo is None:</span>
    <span class="c1">#         memo = {}</span>
    <span class="c1">#     o = self.__class__.__new__(self.__class__)</span>
    <span class="c1">#     memo[id(self)] = o</span>
    <span class="c1">#     for k in self.__dict__:</span>
    <span class="c1">#         # if k not in o.__dict__: # do not add attributes already added by base class</span>
    <span class="c1">#         print(&quot;---&gt;{}: {}&quot;.format(id(o), k))</span>
    <span class="c1">#         o.__dict__[k] = copy.deepcopy(self.__dict__[k], memo)</span>
    <span class="c1">#         memo[id(self.__dict__[k])] = o.__dict__[k]</span>
    <span class="c1">#     return o</span>

<div class="viewcode-block" id="Annotation.clone">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.Annotation.clone">[docs]</a>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute_object_mapper</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Essentially a shallow-copy, except that any objects in the ``_value``</span>
<span class="sd">        field with an ``id`` found in ``attribute_object_mapper`` will be replaced</span>
<span class="sd">        with ``attribute_object_mapper[id]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attribute_object_mapper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attribute_object_mapper</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="n">o</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">):</span>
            <span class="n">o</span><span class="o">.</span><span class="n">copy_annotations_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">o</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">o</span></div>


    <span class="k">def</span> <span class="nf">is_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;name_prefix&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_prefix</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;prefixed_name&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixed_name</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;namespace&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_attribute</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>
    <span class="k">def</span> <span class="nf">_set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_value</span><span class="p">,</span> <span class="n">_set_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_name_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name_prefix</span> <span class="o">=</span> <span class="s2">&quot;dendropy&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_prefix</span>
    <span class="k">def</span> <span class="nf">_set_name_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name_prefix</span> <span class="o">=</span> <span class="n">prefix</span>
    <span class="n">name_prefix</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_name_prefix</span><span class="p">,</span> <span class="n">_set_name_prefix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span> <span class="o">=</span> <span class="s2">&quot;http://pypi.org/project/DendroPy/&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span>
    <span class="k">def</span> <span class="nf">_set_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_namespace</span> <span class="o">=</span> <span class="n">prefix</span>
    <span class="n">namespace</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_namespace</span><span class="p">,</span> <span class="n">_set_namespace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_prefixed_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_set_prefixed_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefixed_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name_prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">textprocessing</span><span class="o">.</span><span class="n">parse_curie_standard_qualified_name</span><span class="p">(</span><span class="n">prefixed_name</span><span class="p">)</span>
    <span class="n">prefixed_name</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_prefixed_name</span><span class="p">,</span> <span class="n">_set_prefixed_name</span><span class="p">)</span></div>


<span class="c1">##############################################################################</span>
<span class="c1">## AnnotationSet</span>

<div class="viewcode-block" id="AnnotationSet">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet">[docs]</a>
<span class="k">class</span> <span class="nc">AnnotationSet</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">OrderedSet</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">container</span><span class="o">.</span><span class="n">OrderedSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">OrderedSet</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
                <span class="c1">#and self.target is other.target) # we consider two</span>
                <span class="c1"># AnnotationSet objects equal even if their targets are</span>
                <span class="c1"># different; this is because (a) the target is convenience</span>
                <span class="c1"># artifact, so client code calls to ``add_bound_attribute`` do</span>
                <span class="c1"># not need to specify an owner, and (b) the target is not part</span>
                <span class="c1"># of the contents of the AnnotationSet</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;AnnotationSet([</span><span class="si">{}</span><span class="s2">])&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;deepcopy error: object id </span><span class="si">{}</span><span class="s2"> not found: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)))</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">o</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
            <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">o</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">o</span>

<div class="viewcode-block" id="AnnotationSet.__getitem__">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Experimental! Inefficient! Volatile! Subject to change!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">container</span><span class="o">.</span><span class="n">OrderedSet</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span></div>


<div class="viewcode-block" id="AnnotationSet.__setitem__">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.__setitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Experimental! Inefficient! Volatile! Subject to change!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">container</span><span class="o">.</span><span class="n">OrderedSet</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="AnnotationSet.add_new">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.add_new">[docs]</a>
    <span class="k">def</span> <span class="nf">add_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">value</span><span class="p">,</span>
            <span class="n">datatype_hint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">name_prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">name_is_prefixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">is_attribute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">annotate_as_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">is_hidden</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">real_value_format_specifier</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an annotation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            The property/subject/field of the annotation (e.g. &quot;color&quot;,</span>
<span class="sd">            &quot;locality&quot;, &quot;dc:citation&quot;)</span>
<span class="sd">        value: string</span>
<span class="sd">            The content of the annotation.</span>
<span class="sd">        datatype_hint : string, optional</span>
<span class="sd">            Mainly for NeXML output (e.g. &quot;xsd:string&quot;).</span>
<span class="sd">        namespace_prefix : string, optional</span>
<span class="sd">            Mainly for NeXML output (e.g. &quot;dc:&quot;).</span>
<span class="sd">        namespace : string, optional</span>
<span class="sd">            Mainly for NeXML output (e.g. &quot;http://www.w3.org/XML/1998/namespace&quot;).</span>
<span class="sd">        name_is_prefixed : string, optional</span>
<span class="sd">            Mainly for NeXML *input*: name will be split into prefix and local part</span>
<span class="sd">            before storage (e.g., &quot;dc:citations&quot; will result in prefix = &quot;dc&quot; and</span>
<span class="sd">            name=&quot;citations&quot;)</span>
<span class="sd">        is_attribute : boolean, optional</span>
<span class="sd">            If value is passed as a tuple of (object, &quot;attribute_name&quot;) and this</span>
<span class="sd">            is True, then actual content will be the result of calling</span>
<span class="sd">            ``getattr(object, &quot;attribute_name&quot;)``.</span>
<span class="sd">        annotate_as_reference : boolean, optional</span>
<span class="sd">            The value should be interpreted as a URI that points to content.</span>
<span class="sd">        is_hidden : boolean, optional</span>
<span class="sd">            Do not write or print this annotation when writing data.</span>
<span class="sd">        real_value_format_specifier : str</span>
<span class="sd">          Format specifier for printing or rendering values as string, given</span>
<span class="sd">          in Python&#39;s format specification mini-language. E.g., &#39;.8f&#39;, &#39;4E&#39;,</span>
<span class="sd">          &#39;&gt;04d&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        annotation : |Annotation|</span>
<span class="sd">            The new |Annotation| created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name_is_prefixed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name_prefix</span> <span class="o">=</span> <span class="s2">&quot;dendropy&quot;</span>
                <span class="n">namespace</span> <span class="o">=</span> <span class="s2">&quot;http://pypi.org/project/DendroPy/&quot;</span>
            <span class="k">elif</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify &#39;name_prefix&#39; for unqualified name without specifying &#39;namespace&#39;&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify &#39;namespace&#39; for unqualified name without specifying &#39;name_prefix&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify qualified name without specifying &#39;namespace&#39;&quot;</span><span class="p">)</span>
        <span class="n">annote</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                <span class="n">datatype_hint</span><span class="o">=</span><span class="n">datatype_hint</span><span class="p">,</span>
                <span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">,</span>
                <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span>
                <span class="n">name_is_prefixed</span><span class="o">=</span><span class="n">name_is_prefixed</span><span class="p">,</span>
                <span class="n">is_attribute</span><span class="o">=</span><span class="n">is_attribute</span><span class="p">,</span>
                <span class="n">annotate_as_reference</span><span class="o">=</span><span class="n">annotate_as_reference</span><span class="p">,</span>
                <span class="n">is_hidden</span><span class="o">=</span><span class="n">is_hidden</span><span class="p">,</span>
                <span class="n">real_value_format_specifier</span><span class="o">=</span><span class="n">real_value_format_specifier</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annote</span><span class="p">)</span></div>


<div class="viewcode-block" id="AnnotationSet.add_bound_attribute">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.add_bound_attribute">[docs]</a>
    <span class="k">def</span> <span class="nf">add_bound_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">attr_name</span><span class="p">,</span>
            <span class="n">annotation_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">datatype_hint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">name_prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">name_is_prefixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">annotate_as_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">is_hidden</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">real_value_format_specifier</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">owner_instance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an attribute of an object as a dynamic annotation. The value of the</span>
<span class="sd">        annotation will be dynamically bound to the value of the attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attr_name : string</span>
<span class="sd">            The (string) name of the attribute to be used as the source of the</span>
<span class="sd">            content or value of the annotation.</span>
<span class="sd">        annotation_name : string, optional</span>
<span class="sd">            Use this string as the annotation field/name rather than the attribute</span>
<span class="sd">            name.</span>
<span class="sd">        datatype_hint : string, optional</span>
<span class="sd">            Mainly for NeXML output (e.g. &quot;xsd:string&quot;).</span>
<span class="sd">        namespace_prefix : string, optional</span>
<span class="sd">            Mainly for NeXML output (e.g. &quot;dc:&quot;).</span>
<span class="sd">        namespace : string, optional</span>
<span class="sd">            Mainly for NeXML output (e.g. &quot;http://www.w3.org/XML/1998/namespace&quot;).</span>
<span class="sd">        name_is_prefixed : string, optional</span>
<span class="sd">            Mainly for NeXML *input*: name will be split into prefix and local part</span>
<span class="sd">            before storage (e.g., &quot;dc:citations&quot; will result in prefix = &quot;dc&quot; and</span>
<span class="sd">            name=&quot;citations&quot;)</span>
<span class="sd">        annotate_as_reference : bool, optional</span>
<span class="sd">            The value should be interpreted as a URI that points to content.</span>
<span class="sd">        is_hidden : bool, optional</span>
<span class="sd">            Do not write or print this annotation when writing data.</span>
<span class="sd">        owner_instance : object, optional</span>
<span class="sd">            The object whose attribute is to be used as the value of the</span>
<span class="sd">            annotation. Defaults to ``self.target``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        annotation : |Annotation|</span>
<span class="sd">            The new |Annotation| created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">annotation_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">annotation_name</span> <span class="o">=</span> <span class="n">attr_name</span>
        <span class="k">if</span> <span class="n">owner_instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">owner_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">owner_instance</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">attr_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name_is_prefixed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name_prefix</span> <span class="o">=</span> <span class="s2">&quot;dendropy&quot;</span>
                <span class="n">namespace</span> <span class="o">=</span> <span class="s2">&quot;http://pypi.org/project/DendroPy/&quot;</span>
            <span class="k">elif</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify &#39;name_prefix&#39; for unqualified name without specifying &#39;namespace&#39;&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify &#39;namespace&#39; for unqualified name without specifying &#39;name_prefix&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify qualified name without specifying &#39;namespace&#39;&quot;</span><span class="p">)</span>
        <span class="n">annote</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">annotation_name</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="p">(</span><span class="n">owner_instance</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">),</span>
                <span class="n">datatype_hint</span><span class="o">=</span><span class="n">datatype_hint</span><span class="p">,</span>
                <span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">,</span>
                <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span>
                <span class="n">name_is_prefixed</span><span class="o">=</span><span class="n">name_is_prefixed</span><span class="p">,</span>
                <span class="n">is_attribute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">annotate_as_reference</span><span class="o">=</span><span class="n">annotate_as_reference</span><span class="p">,</span>
                <span class="n">is_hidden</span><span class="o">=</span><span class="n">is_hidden</span><span class="p">,</span>
                <span class="n">real_value_format_specifier</span><span class="o">=</span><span class="n">real_value_format_specifier</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annote</span><span class="p">)</span></div>


<div class="viewcode-block" id="AnnotationSet.add_citation">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.add_citation">[docs]</a>
    <span class="k">def</span> <span class="nf">add_citation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">citation</span><span class="p">,</span>
            <span class="n">read_as</span><span class="o">=</span><span class="s2">&quot;bibtex&quot;</span><span class="p">,</span>
            <span class="n">store_as</span><span class="o">=</span><span class="s2">&quot;bibtex&quot;</span><span class="p">,</span>
            <span class="n">name_prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">is_hidden</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a citation as an annotation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        citation : string or dict or `BibTexEntry`</span>
<span class="sd">            The citation to be added. If a string, then it must be a</span>
<span class="sd">            BibTex-formatted entry. If a dictionary, then it must have</span>
<span class="sd">            BibTex fields as keys and contents as values.</span>
<span class="sd">        read_as : string, optional</span>
<span class="sd">            Specifies the format/schema/structure of the citation. Currently</span>
<span class="sd">            only supports &#39;bibtex&#39;.</span>
<span class="sd">        store_as : string, optional</span>
<span class="sd">            Specifies how to record the citation, with one of the</span>
<span class="sd">            following strings as values: &quot;bibtex&quot; (a set of annotations, where</span>
<span class="sd">            each BibTex field becomes a separate annotation); &quot;prism&quot;</span>
<span class="sd">            (a set of PRISM [Publishing Requirements for Industry Standard</span>
<span class="sd">            Metadata] annotations); &quot;dublin&quot; (A set of of Dublic Core</span>
<span class="sd">            annotations). Defaults to &quot;bibtex&quot;.</span>
<span class="sd">        name_prefix : string, optional</span>
<span class="sd">            Mainly for NeXML output (e.g. &quot;dc:&quot;).</span>
<span class="sd">        namespace : string, optional</span>
<span class="sd">            Mainly for NeXML output (e.g. &quot;http://www.w3.org/XML/1998/namespace&quot;).</span>
<span class="sd">        is_hidden : boolean, optional</span>
<span class="sd">            Do not write or print this annotation when writing data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        annotation : |Annotation|</span>
<span class="sd">            The new |Annotation| created.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;BibTexEntry is deprecated as of DendroPy 5.0 and will be removed in a future release .&quot;</span>
                <span class="s2">&quot;It no longer maintaned, and known to be broken. &quot;</span>
                <span class="s2">&quot;If this functionality is needed, please open an issue on GitHub.&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">read_as</span> <span class="o">==</span> <span class="s2">&quot;bibtex&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_bibtex</span><span class="p">(</span><span class="n">citation</span><span class="o">=</span><span class="n">citation</span><span class="p">,</span>
                    <span class="n">store_as</span><span class="o">=</span><span class="n">store_as</span><span class="p">,</span>
                    <span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">,</span>
                    <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span>
                    <span class="n">is_hidden</span><span class="o">=</span><span class="n">is_hidden</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Source format &#39;</span><span class="si">{}</span><span class="s2">&#39; is not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">read_as</span><span class="p">))</span></div>


<div class="viewcode-block" id="AnnotationSet.add_bibtex">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.add_bibtex">[docs]</a>
    <span class="k">def</span> <span class="nf">add_bibtex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">citation</span><span class="p">,</span>
            <span class="n">store_as</span><span class="o">=</span><span class="s2">&quot;bibtex&quot;</span><span class="p">,</span>
            <span class="n">name_prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">is_hidden</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a citation as an annotation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        citation : string or dict or `BibTexEntry`</span>
<span class="sd">            The citation to be added. If a string, then it must be a</span>
<span class="sd">            BibTex-formatted entry. If a dictionary, then it must have</span>
<span class="sd">            BibTex fields as keys and contents as values.</span>
<span class="sd">        store_as : string, optional</span>
<span class="sd">            Specifies how to record the citation, with one of the</span>
<span class="sd">            following strings as values: &quot;bibtex&quot; (a set of annotations, where</span>
<span class="sd">            each BibTex field becomes a separate annotation); &quot;prism&quot;</span>
<span class="sd">            (a set of PRISM [Publishing Requirements for Industry Standard</span>
<span class="sd">            Metadata] annotations); &quot;dublin&quot; (A set of of Dublic Core</span>
<span class="sd">            annotations). Defaults to &quot;bibtex&quot;.</span>
<span class="sd">        name_prefix : string, optional</span>
<span class="sd">            Mainly for NeXML output (e.g. &quot;dc:&quot;).</span>
<span class="sd">        namespace : string, optional</span>
<span class="sd">            Mainly for NeXML output (e.g. &quot;http://www.w3.org/XML/1998/namespace&quot;).</span>
<span class="sd">        is_hidden : boolean, optional</span>
<span class="sd">            Do not write or print this annotation when writing data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        annotation : |Annotation|</span>
<span class="sd">            The new |Annotation| created.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;BibTexEntry is deprecated as of DendroPy 5.0 and will be removed in a future release .&quot;</span>
                <span class="s2">&quot;It no longer maintaned, and known to be broken. &quot;</span>
                <span class="s2">&quot;If this functionality is needed, please open an issue on GitHub.&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="n">bt</span> <span class="o">=</span> <span class="n">bibtex</span><span class="o">.</span><span class="n">BibTexEntry</span><span class="p">(</span><span class="n">citation</span><span class="p">)</span>
        <span class="n">bt_dict</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">fields_as_dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify &#39;name_prefix&#39; for unqualified name without specifying &#39;namespace&#39;&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify &#39;namespace&#39; for unqualified name without specifying &#39;name_prefix&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">store_as</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;bibtex&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name_prefix</span> <span class="o">=</span> <span class="s2">&quot;bibtex&quot;</span>
                <span class="n">namespace</span> <span class="o">=</span> <span class="s2">&quot;http://www.edutella.org/bibtex#&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;bibtype&quot;</span><span class="p">,</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">bt</span><span class="o">.</span><span class="n">bibtype</span><span class="p">,</span>
                    <span class="n">datatype_hint</span><span class="o">=</span><span class="s2">&quot;xsd:string&quot;</span><span class="p">,</span>
                    <span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">,</span>
                    <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span>
                    <span class="n">name_is_prefixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">is_attribute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">annotate_as_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">is_hidden</span><span class="o">=</span><span class="n">is_hidden</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;citekey&quot;</span><span class="p">,</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">bt</span><span class="o">.</span><span class="n">citekey</span><span class="p">,</span>
                    <span class="n">datatype_hint</span><span class="o">=</span><span class="s2">&quot;xsd:string&quot;</span><span class="p">,</span>
                    <span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">,</span>
                    <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span>
                    <span class="n">name_is_prefixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">is_attribute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">annotate_as_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">is_hidden</span><span class="o">=</span><span class="n">is_hidden</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">entry_key</span><span class="p">,</span> <span class="n">entry_value</span> <span class="ow">in</span> <span class="n">bt_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">entry_key</span><span class="p">,</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">entry_value</span><span class="p">,</span>
                        <span class="n">datatype_hint</span><span class="o">=</span><span class="s2">&quot;xsd:string&quot;</span><span class="p">,</span>
                        <span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">,</span>
                        <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span>
                        <span class="n">name_is_prefixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">is_attribute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">annotate_as_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">is_hidden</span><span class="o">=</span><span class="n">is_hidden</span><span class="p">)</span>
        <span class="c1"># elif store_as.lower().startswith(&quot;bibtex-record&quot;):</span>
        <span class="c1">#     if name_prefix is None and namespace is None:</span>
        <span class="c1">#         name_prefix = &quot;dendropy&quot;</span>
        <span class="c1">#         namespace = &quot;http://pypi.org/project/DendroPy/&quot;</span>
        <span class="c1">#     self.add_new(</span>
        <span class="c1">#             name=&quot;bibtex&quot;,</span>
        <span class="c1">#             value=bt.as_compact_bibtex(),</span>
        <span class="c1">#             datatype_hint=&quot;xsd:string&quot;,</span>
        <span class="c1">#             name_is_prefixed=False,</span>
        <span class="c1">#             name_prefix=name_prefix,</span>
        <span class="c1">#             namespace=namespace,</span>
        <span class="c1">#             is_attribute=False,</span>
        <span class="c1">#             annotate_as_reference=False,</span>
        <span class="c1">#             is_hidden=is_hidden)</span>
        <span class="k">elif</span> <span class="n">store_as</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;prism&quot;</span><span class="p">):</span>
            <span class="n">prism_map</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;volume&#39;</span><span class="p">:</span> <span class="n">bt_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;volume&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="s1">&#39;publicationName&#39;</span><span class="p">:</span>  <span class="n">bt_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;journal&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="s1">&#39;pageRange&#39;</span><span class="p">:</span> <span class="n">bt_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pages&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="s1">&#39;publicationDate&#39;</span><span class="p">:</span> <span class="n">bt_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="p">}</span>
            <span class="k">if</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name_prefix</span> <span class="o">=</span> <span class="s2">&quot;prism&quot;</span>
                <span class="n">namespace</span> <span class="o">=</span> <span class="s2">&quot;http://prismstandard.org/namespaces/1.2/basic/&quot;</span>
            <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">prism_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">datatype_hint</span><span class="o">=</span><span class="s2">&quot;xsd:string&quot;</span><span class="p">,</span>
                        <span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">,</span>
                        <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span>
                        <span class="n">name_is_prefixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">is_attribute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">annotate_as_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">is_hidden</span><span class="o">=</span><span class="n">is_hidden</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">store_as</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;dublin&quot;</span><span class="p">):</span>
            <span class="n">dc_map</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="n">bt_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="s1">&#39;creator&#39;</span><span class="p">:</span>  <span class="n">bt_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;author&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="s1">&#39;publisher&#39;</span><span class="p">:</span> <span class="n">bt_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;journal&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="n">bt_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="p">}</span>
            <span class="k">if</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name_prefix</span> <span class="o">=</span> <span class="s2">&quot;dc&quot;</span>
                <span class="n">namespace</span> <span class="o">=</span> <span class="s2">&quot;http://purl.org/dc/elements/1.1/&quot;</span>
            <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dc_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">field</span><span class="p">,</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">datatype_hint</span><span class="o">=</span><span class="s2">&quot;xsd:string&quot;</span><span class="p">,</span>
                        <span class="n">name_is_prefixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">,</span>
                        <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span>
                        <span class="n">is_attribute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">annotate_as_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">is_hidden</span><span class="o">=</span><span class="n">is_hidden</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized composition specification: &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">store_as</span><span class="p">))</span></div>


<div class="viewcode-block" id="AnnotationSet.findall">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.findall">[docs]</a>
    <span class="k">def</span> <span class="nf">findall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns AnnotationSet of Annotation objects associated with self.target</span>
<span class="sd">        that match based on *all* criteria specified in keyword arguments::</span>

<span class="sd">            &gt;&gt;&gt; notes = tree.annotations.findall(name=&quot;color&quot;)</span>
<span class="sd">            &gt;&gt;&gt; notes = tree.annotations.findall(namespace=&quot;http://pypi.org/project/DendroPy/&quot;)</span>
<span class="sd">            &gt;&gt;&gt; notes = tree.annotations.findall(namespace=&quot;http://pypi.org/project/DendroPy/&quot;,</span>
<span class="sd">                                          name=&quot;color&quot;)</span>
<span class="sd">            &gt;&gt;&gt; notes = tree.annotations.findall(name_prefix=&quot;dc&quot;)</span>
<span class="sd">            &gt;&gt;&gt; notes = tree.annotations.findall(prefixed_name=&quot;dc:color&quot;)</span>

<span class="sd">        If no matches are found, the return AnnotationSet is empty.</span>

<span class="sd">        If no keyword arguments are given, *all* annotations are returned::</span>

<span class="sd">            &gt;&gt;&gt; notes = tree.annotations.findall()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : |AnnotationSet| or |None|</span>
<span class="sd">            |AnnotationSet| containing |Annotation| objects that</span>
<span class="sd">            match criteria, or |None| if no matching annotations found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_match</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">AnnotationSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="AnnotationSet.find">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.find">[docs]</a>
    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the *first* Annotation associated with self.target</span>
<span class="sd">        which matches based on *all* criteria specified in keyword arguments::</span>

<span class="sd">            &gt;&gt;&gt; note = tree.annotations.find(name=&quot;color&quot;)</span>
<span class="sd">            &gt;&gt;&gt; note = tree.annotations.find(name_prefix=&quot;dc&quot;, name=&quot;color&quot;)</span>
<span class="sd">            &gt;&gt;&gt; note = tree.annotations.find(prefixed_name=&quot;dc:color&quot;)</span>

<span class="sd">        If no match is found, None is returned.</span>

<span class="sd">        If no keyword arguments are given, a TypeError is raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : |Annotation| or |None|</span>
<span class="sd">            First |Annotation| object found that matches criteria, or</span>
<span class="sd">            |None| if no matching annotations found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;default&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">default</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Search criteria not specified&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_match</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span>
        <span class="k">return</span> <span class="n">default</span></div>


<div class="viewcode-block" id="AnnotationSet.get_value">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.get_value">[docs]</a>
    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the *value* of the *first* Annotation associated with</span>
<span class="sd">        self.target which has ``name`` in the name field.</span>

<span class="sd">        If no match is found, then ``default`` is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            Name of |Annotation| object whose value is to be returned.</span>

<span class="sd">        default : any, optional</span>
<span class="sd">            Value to return if no matching |Annotation| object found.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : |Annotation| or |None|</span>
<span class="sd">            ``value`` of first |Annotation| object found that matches</span>
<span class="sd">            criteria, or |None| if no matching annotations found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_match</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">default</span></div>


<div class="viewcode-block" id="AnnotationSet.require_value">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.require_value">[docs]</a>
    <span class="k">def</span> <span class="nf">require_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the *value* of the *first* Annotation associated with</span>
<span class="sd">        self.target which has ``name`` in the name field.</span>

<span class="sd">        If no match is found, then KeyError is raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            Name of |Annotation| object whose value is to be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : |Annotation| or |None|</span>
<span class="sd">            ``value`` of first |Annotation| object found that matches</span>
<span class="sd">            criteria.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span></div>


<div class="viewcode-block" id="AnnotationSet.drop">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.drop">[docs]</a>
    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes Annotation objects that match based on *all* criteria specified</span>
<span class="sd">        in keyword arguments.</span>

<span class="sd">        Remove all annotation objects with ``name`` ==</span>
<span class="sd">        &quot;color&quot;::</span>

<span class="sd">            &gt;&gt;&gt; tree.annotations.drop(name=&quot;color&quot;)</span>

<span class="sd">        Remove all annotation objects with ``namespace`` ==</span>
<span class="sd">        &quot;http://pypi.org/project/DendroPy/&quot;::</span>

<span class="sd">            &gt;&gt;&gt; tree.annotations.drop(namespace=&quot;http://pypi.org/project/DendroPy/&quot;)</span>

<span class="sd">        Remove all annotation objects with ``namespace`` ==</span>
<span class="sd">        &quot;http://pypi.org/project/DendroPy/&quot; *and* ``name`` == &quot;color&quot;::</span>

<span class="sd">            &gt;&gt;&gt; tree.annotations.drop(namespace=&quot;http://pypi.org/project/DendroPy/&quot;,</span>
<span class="sd">                    name=&quot;color&quot;)</span>

<span class="sd">        Remove all annotation objects with ``name_prefix`` == &quot;dc&quot;::</span>

<span class="sd">            &gt;&gt;&gt; tree.annotations.drop(name_prefix=&quot;dc&quot;)</span>

<span class="sd">        Remove all annotation objects with ``prefixed_name`` == &quot;dc:color&quot;::</span>

<span class="sd">            &gt;&gt;&gt; tree.annotations.drop(prefixed_name=&quot;dc:color&quot;)</span>

<span class="sd">        If no keyword argument filter criteria are given, *all* annotations are</span>
<span class="sd">        removed::</span>

<span class="sd">            &gt;&gt;&gt; tree.annotations.drop()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : |AnnotationSet|</span>
<span class="sd">            |AnnotationSet| containing |Annotation| objects that</span>
<span class="sd">            were removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_match</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AnnotationSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">)</span></div>


<div class="viewcode-block" id="AnnotationSet.values_as_dict">
<a class="viewcode-back" href="../../../library/basemodel.html#dendropy.datamodel.basemodel.AnnotationSet.values_as_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">values_as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns annotation set as a dictionary. The keys and values for the dictionary will</span>
<span class="sd">        be generated based on the following keyword arguments:</span>

<span class="sd">        Keyword Arguments</span>
<span class="sd">        -----------------</span>
<span class="sd">        key_attr : string</span>
<span class="sd">            String specifying an Annotation object attribute name to be used</span>
<span class="sd">            as keys for the dictionary.</span>
<span class="sd">        key_fn : string</span>
<span class="sd">            Function that takes an Annotation object as an argument and returns</span>
<span class="sd">            the value to be used as a key for the dictionary.</span>
<span class="sd">        value_attr : string</span>
<span class="sd">            String specifying an Annotation object attribute name to be used</span>
<span class="sd">            as values for the dictionary.</span>
<span class="sd">        value_fn : string</span>
<span class="sd">            Function that takes an Annotation object as an argument and returns</span>
<span class="sd">            the value to be used as a value for the dictionary.</span>

<span class="sd">        At most one of ``key_attr`` or ``key_fn`` can be specified. If neither</span>
<span class="sd">        is specified, then by default the keys are generated from Annotation.name.</span>
<span class="sd">        At most one of ``value_attr`` or ``value_fn`` can be specified. If neither</span>
<span class="sd">        is specified, then by default the values are generated from Annotation.value.</span>
<span class="sd">        Key collisions will result in the dictionary entry for that key being</span>
<span class="sd">        overwritten.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;key_attr&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s2">&quot;key_fn&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both &#39;key_attr&#39; and &#39;key_fn&#39;&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;key_attr&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">key_attr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;key_attr&quot;</span><span class="p">]</span>
            <span class="n">key_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">key_attr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;key_fn&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">key_fn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;key_fn&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="s2">&quot;value_attr&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s2">&quot;value_fn&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both &#39;value_attr&#39; and &#39;value_fn&#39;&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;value_attr&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">value_attr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;value_attr&quot;</span><span class="p">]</span>
            <span class="n">value_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">value_attr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;value_fn&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">value_fn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;value_fn&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">value</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key_fn</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value_fn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>
</div>


</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div style="text-align: center; padding-top: 20px; padding-bottom: 5px; width: 100%;">
    <a href="../../../index.html"><img src="../../../_static/dendropy_logo.png" /></a>
</div><div style="clear:both; width: 100%; height:1px;"></div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div>
    <!-- Documentation -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Documentation</h3>
        <ul>
            <li><a href="../../../primer/downloading.html">Downloading and Installing DendroPy</a></li>
            <li><a href="../../../primer/index.html">The DendroPy Primer</a></li>
            <li><a href="../../../library/index.html">Library API Reference</a></li>
            <li>
                <a href="../../../schemas/index.html">Schemas</a>
                <ul>
                    <li><a href="../../../schemas/fasta.html">FASTA</a></li>
                    <li><a href="../../../schemas/newick.html">Newick</a></li>
                    <li><a href="../../../schemas/nexml.html">NeXML</a></li>
                    <li><a href="../../../schemas/nexus.html">Nexus</a></li>
                    <li><a href="../../../schemas/phylip.html">PHYLIP</a></li>
                </ul>
            </li>
            <li>
                <a href="../../../programs/index.html">Programs</a>
                <ul>
                    <li><a href="../../../programs/sumtrees.html">SumTrees</a></li>
                </ul>
            </li>
            <li><a href="../../../glossary.html">Glossary and Terminological Reference</a></li>
            <li><a href="../../../developer.html">Developer Guide</a></li>
            <li><a href="../../../planning.html">Ongoing Development</a></li>
            <li><a href="../../../changes.html">Change History</a></li>
        </ul>
    </div>

    <!-- Downloads -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Obtaining</h3>
        <ul>
            <li><a target="_blank" href="http://pypi.python.org/pypi/DendroPy">Install from the Python Package Index</a></li>
            <li><a target="_blank" href="http://pypi.python.org/packages/source/D/DendroPy/DendroPy-5.0.6.tar.gz">Download the Source Code Archive</a></li>
            <li><a target="_blank" href="http://github.com/jeetsukumaran/DendroPy">Clone the Source Code Repository</a></li>
        </ul>
    </div>

    <!-- Discussions -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Discussion</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot; DendroPy Users&quot; </a>group to follow and participate in discussion, troubleshooting, help, information, suggestions, etc. on the usage and development of the DendroPy phylogenetic computing library.</p>
            <form action="http://groups.google.com/group/dendropy-users/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot;dendropy-users&quot;</a> group, or click <a href="http://groups.google.com/group/dendropy-users?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Announcements -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Announcements</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; DendroPy Announcements&quot; </a>group to receive announcements of new releases, updates, changes and other news of interest to DendroPy users and developers.</p>
            <form action="http://groups.google.com/group/dendropy-announce/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; dendropy-announce&quot; </a>group, or click <a href="http://groups.google.com/group/dendropy-announce?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Development -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative; padding-bottom: 15px; margin-bottom:5px;">
        <h3><span style="text-align: left"><a href="https://github.com/jeetsukumaran/DendroPy/">Development</a></span><a href="https://github.com/jeetsukumaran/DendroPy/"><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/Octocat.png" height="30px" alt="GitHub" /></span></a></h3>
        <div style="margin-top: 15px;">
            <!-- <a href="https://github.com/jeetsukumaran/DendroPy/issues">Issues</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/subscription">Watch</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/fork">Fork</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/stargazers">Star</a> &bull; <a href="https://github.com/jeetsukumaran/">Follow</a> -->
            <ul>
                <li>                <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/issues"><code>Issues</code></a></span> <span style="font-style: italic; font-size:80%;"> - Report bugs or request features</span></li>
                <li>     <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/subscription"><code>&nbsp;Watch</code></a></span> <span style="font-style: italic; font-size:80%;"> - Follow development activity</span></li>
                <li>        <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/fork"><code>&nbsp;&nbsp;Fork</code></a></span> <span style="font-style: italic; font-size:80%;"> - Contribute and collaborate</span></li>
                <li>  <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/stargazers"><code>&nbsp;&nbsp;Star</code></a></span> <span style="font-style: italic; font-size:80%;"> - Throw some glitter, add some glamour</span></li>
        </div>
    </div>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DendroPy 5.0.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.datamodel.basemodel</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2009-2025, Jeet Sukumaran and Mark T. Holder.
    </div>
  </body>
</html>