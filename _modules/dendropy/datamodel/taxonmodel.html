<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dendropy.datamodel.taxonmodel &#8212; DendroPy 5.0.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/rtd.css?v=cedc6a2f" />
    
    <script src="../../../_static/documentation_options.js?v=5df4c8d1"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DendroPy 5.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.datamodel.taxonmodel</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for dendropy.datamodel.taxonmodel</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1">##############################################################################</span>
<span class="c1">##  DendroPy Phylogenetic Computing Library.</span>
<span class="c1">##</span>
<span class="c1">##  Copyright 2010-2015 Jeet Sukumaran and Mark T. Holder.</span>
<span class="c1">##  All rights reserved.</span>
<span class="c1">##</span>
<span class="c1">##  See &quot;LICENSE.rst&quot; for terms and conditions of usage.</span>
<span class="c1">##</span>
<span class="c1">##  If you use this work or any portion thereof in published work,</span>
<span class="c1">##  please cite it as:</span>
<span class="c1">##</span>
<span class="c1">##     Sukumaran, J. and M. T. Holder. 2010. DendroPy: a Python library</span>
<span class="c1">##     for phylogenetic computing. Bioinformatics 26: 1569-1571.</span>
<span class="c1">##</span>
<span class="c1">##############################################################################</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Taxon management.</span>

<span class="sd">Operational taxonomic unit concepts are essentially names for taxa in the &quot;real</span>
<span class="sd">world&quot;. Operational taxonomic unit concepts are organized into taxonomic</span>
<span class="sd">namespaces. A taxonomic namespace is a self-contained and</span>
<span class="sd">functionally-complete collection of mutually-distinct operational taxonomic</span>
<span class="sd">unit concepts, and provide the semantic context in which operational taxonomic</span>
<span class="sd">units from across various data sources of different formats and provenances can</span>
<span class="sd">be related through correct interpretation of their taxon labels.</span>

<span class="sd">    * Operational taxonomic units are modeled by a |Taxon| object.</span>

<span class="sd">    * Taxonomic namespaces, in which operational taxonomic units are organized,</span>
<span class="sd">      are modeled by a |TaxonNamespace| object.</span>

<span class="sd">    * A |TaxonNamespace| manages a collection of |Taxon| objects, where each</span>
<span class="sd">      object represents a distinct operational taxonomic unit concept within</span>
<span class="sd">      the taxonomic namespace represented by that |TaxonNamespace| object.</span>

<span class="sd">    * Each |Taxon| object can belong to one and only one |TaxonNamespace|:</span>
<span class="sd">      |Taxon| objects are not shared across |TaxonNamespace| objects.</span>

<span class="sd">    * Each |Taxon| object has an attribute, ``label``, whose (string) value</span>
<span class="sd">      is the name of the operational taxon unit concept that it represents.</span>

<span class="sd">    * Different |Taxon| objects represent different operational taxonomic</span>
<span class="sd">      unit concepts, even if they have the same label value.</span>

<span class="sd">    * All client objects (`TaxonNamespaceAssociated` objects) that reference</span>
<span class="sd">      the same |TaxonNamespace| reference the same &quot;universe&quot; or domain of</span>
<span class="sd">      operational taxonomic unit concepts.</span>

<span class="sd">    * Operational taxonomic units from across different data sources are mapped</span>
<span class="sd">      to distinct |Taxon| objects within a particular |TaxonNamespace| based on</span>
<span class="sd">      matching the string values of labels of the |Taxon| object.</span>

<span class="sd">    * A particular taxonomic unit concept in one data source will only be</span>
<span class="sd">      correctly related to the same taxonomic unit concept (i.e, the same</span>
<span class="sd">      |Taxon| object) in another data source only if they have both</span>
<span class="sd">      been parsed with reference to the same taxonomic namespace (i.e., the</span>
<span class="sd">      same |TaxonNamespace| has been used).</span>

<span class="sd">    * A |TaxonNamespace| assigned an &quot;accession index&quot; to every |Taxon| object</span>
<span class="sd">      added to it. This is a stable and unique number within the context of any</span>
<span class="sd">      given |TaxonNamespace| object (though a |Taxon| object may have different</span>
<span class="sd">      accession indexes in different |TaxonNamespace| objects if it</span>
<span class="sd">      belongs to multiple namespaces). This number is will be used to</span>
<span class="sd">      calculate the &quot;split bitmask&quot; hash of the trivial split or external edge</span>
<span class="sd">      subtending the node to which this |Taxon| object is assigned on a tree.</span>
<span class="sd">      The concept of a &quot;split bitmask&quot; hash is fundamental to DendroPy&#39;s tree</span>
<span class="sd">      operations. The split bitmask is a hash that uniquely identifies every</span>
<span class="sd">      split on a tree.  It is calculated by OR&#39;ing the split bitmask of all the</span>
<span class="sd">      child splits of the given split. Terminal edges, of course, do not have</span>
<span class="sd">      child edges, and their split bitmask is given by the accession index of</span>
<span class="sd">      the |Taxon| object at their head or target nodes.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">dendropy.datamodel</span> <span class="kn">import</span> <span class="n">basemodel</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">bitprocessing</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">container</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">error</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">deprecate</span>

<span class="c1">##############################################################################</span>
<span class="c1">## Helper functions</span>

<span class="k">def</span> <span class="nf">taxon_set_deprecation_warning</span><span class="p">(</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Deprecated since DendroPy 4: &#39;taxon_set&#39; will no longer be supported in future releases; use &#39;taxon_namespace&#39; instead&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="n">stacklevel</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">process_kwargs_dict_for_taxon_namespace</span><span class="p">(</span><span class="n">kwargs_dict</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;taxon_set&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;taxon_namespace&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both &#39;taxon_namespace&#39; and &#39;taxon_set&#39; (legacy support) simultaneously&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">taxon_set_deprecation_warning</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;taxon_set&quot;</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">process_attached_taxon_namespace_directives</span><span class="p">(</span><span class="n">kwargs_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The following idioms are supported:</span>

<span class="sd">        `taxon_namespace=tns`</span>
<span class="sd">            Attach ``tns`` as the bound (single, unified) taxonomic namespace</span>
<span class="sd">            reference for all objects.</span>
<span class="sd">        `attached_taxon_namespace=tns`</span>
<span class="sd">            Attach ``tns`` as the bound (single, unified) taxonomic namespace</span>
<span class="sd">            reference for all objects.</span>
<span class="sd">        `attach_taxon_namespace=True, attached_taxon_namespace=tns`</span>
<span class="sd">            Attach ``tns`` as the bound (single, unified) taxonomic namespace</span>
<span class="sd">            reference for all objects.</span>
<span class="sd">        `attach_taxon_namespace=True`</span>
<span class="sd">            Create a *new* |TaxonNamespace| and set it as the bound</span>
<span class="sd">            (single, unified) taxonomic namespace reference for all</span>
<span class="sd">            objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">deprecated_kw</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;taxon_namespace&quot;</span><span class="p">,</span>
            <span class="s2">&quot;attach_taxon_namespace&quot;</span><span class="p">,</span>
            <span class="s2">&quot;attached_taxon_namespace&quot;</span><span class="p">,</span>
            <span class="s2">&quot;taxon_set&quot;</span><span class="p">,</span>
            <span class="s2">&quot;attach_taxon_set&quot;</span><span class="p">,</span>
            <span class="s2">&quot;attached_taxon_set&quot;</span><span class="p">,</span>
            <span class="p">]</span>
    <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">deprecated_kw</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; is no longer supported as a keyword argument. Use the instance method &#39;attach_taxon_namespace()&#39; of the data object instead to bind the object to a single TaxonNamespace&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kw</span><span class="p">))</span>
    <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">attach_taxon_namespace</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="s2">&quot;taxon_set&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span> <span class="ow">or</span> <span class="s2">&quot;taxon_namespace&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;attached_taxon_set&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span> <span class="ow">or</span> <span class="s2">&quot;attached_taxon_namespace&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="p">)</span>
            <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both &#39;taxon_namespace&#39;/&#39;taxon_set&#39; and &#39;attached_taxon_namespace&#39;/&#39;attached_taxon_set&#39; together&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;taxon_set&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;taxon_namespace&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Both &#39;taxon_namespace&#39; and &#39;taxon_set&#39; cannot be specified simultaneously: use &#39;taxon_namespace&#39; (&#39;taxon_set&#39; is only supported for legacy reasons)&quot;</span><span class="p">)</span>
        <span class="n">kwargs_dict</span><span class="p">[</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs_dict</span><span class="p">[</span><span class="s2">&quot;taxon_set&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs_dict</span><span class="p">[</span><span class="s2">&quot;taxon_set&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;attached_taxon_set&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;attached_taxon_namespace&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Both &#39;attached_taxon_namespace&#39; and &#39;attached_taxon_set&#39; cannot be specified simultaneously: use &#39;attached_taxon_namespace&#39; (&#39;attached_taxon_set&#39; is only supported for legacy reasons)&quot;</span><span class="p">)</span>
        <span class="n">kwargs_dict</span><span class="p">[</span><span class="s2">&quot;attached_taxon_namespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs_dict</span><span class="p">[</span><span class="s2">&quot;attached_taxon_set&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs_dict</span><span class="p">[</span><span class="s2">&quot;attached_taxon_set&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s2">&quot;taxon_namespace&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="p">:</span>
        <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">attach_taxon_namespace</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="s2">&quot;attached_taxon_namespace&quot;</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="p">:</span>
        <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">kwargs_dict</span><span class="p">[</span><span class="s2">&quot;attached_taxon_namespace&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="p">,</span> <span class="n">TaxonNamespace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;attached_taxon_namespace&#39; argument must be an instance of TaxonNamespace&quot;</span><span class="p">)</span>
        <span class="n">attach_taxon_namespace</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">attach_taxon_namespace</span> <span class="o">=</span> <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;attach_taxon_namespace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;taxon_namespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;attach_taxon_namespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;attached_taxon_namespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">attach_taxon_namespace</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="p">)</span>

<span class="c1">##############################################################################</span>
<span class="c1">## TaxonNamespaceAssociated</span>

<div class="viewcode-block" id="TaxonNamespaceAssociated">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespaceAssociated">[docs]</a>
<span class="k">class</span> <span class="nc">TaxonNamespaceAssociated</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides infrastructure for the maintenance of references to taxa.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># def initialize_taxon_namespace_from_kwargs_dict(self, kwargs_dict):</span>
    <span class="c1">#     tns = process_kwargs_dict_for_taxon_namespace(kwargs_dict)</span>
    <span class="c1">#     if tns is None:</span>
    <span class="c1">#         self.taxon_namespace = TaxonNamespace()</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         self.taxon_namespace = tns</span>
    <span class="c1">#     return self.taxon_namespace</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_namespace</span> <span class="o">=</span> <span class="n">TaxonNamespace</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_namespace</span> <span class="o">=</span> <span class="n">taxon_namespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">automigrate_taxon_namespace_on_assignment</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_get_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_namespace</span>
    <span class="k">def</span> <span class="nf">_set_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tns</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">automigrate_taxon_namespace_on_assignment</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tns</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">migrate_taxon_namespace</span><span class="p">(</span><span class="n">tns</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_namespace</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_namespace</span> <span class="o">=</span> <span class="n">tns</span>
    <span class="k">def</span> <span class="nf">_del_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot delete &#39;taxon_namespace&#39; attribute&quot;</span><span class="p">)</span>
    <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_taxon_namespace</span><span class="p">,</span> <span class="n">_set_taxon_namespace</span><span class="p">,</span> <span class="n">_del_taxon_namespace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_taxon_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># raise NotImplementedError(&quot;&#39;taxon_set&#39; is no longer supported: use &#39;taxon_namespace&#39; instead&quot;)</span>
        <span class="n">taxon_set_deprecation_warning</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span>
    <span class="k">def</span> <span class="nf">_set_taxon_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># raise NotImplementedError(&quot;&#39;taxon_set&#39; is no longer supported: use &#39;taxon_namespace&#39; instead&quot;)</span>
        <span class="n">taxon_set_deprecation_warning</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">def</span> <span class="nf">_del_taxon_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># raise NotImplementedError(&quot;&#39;taxon_set&#39; is no longer supported: use &#39;taxon_namespace&#39; instead&quot;)</span>
        <span class="n">taxon_set_deprecation_warning</span><span class="p">()</span>
    <span class="n">taxon_set</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_taxon_set</span><span class="p">,</span> <span class="n">_set_taxon_set</span><span class="p">,</span> <span class="n">_del_taxon_set</span><span class="p">)</span>

<div class="viewcode-block" id="TaxonNamespaceAssociated.migrate_taxon_namespace">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespaceAssociated.migrate_taxon_namespace">[docs]</a>
    <span class="k">def</span> <span class="nf">migrate_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">taxon_namespace</span><span class="p">,</span>
            <span class="n">unify_taxa_by_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">taxon_mapping_memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move this object and all members to a new operational taxonomic unit</span>
<span class="sd">        concept namespace scope.</span>

<span class="sd">        Current :attr:`self.taxon_namespace` value will be replaced with value</span>
<span class="sd">        given in ``taxon_namespace`` if this is not |None|, or a new</span>
<span class="sd">        |TaxonNamespace| object. Following this,</span>
<span class="sd">        ``reconstruct_taxon_namespace()`` will be called: each distinct</span>
<span class="sd">        |Taxon| object associated with ``self`` or members of ``self`` that</span>
<span class="sd">        is not alread in ``taxon_namespace`` will be replaced with a new</span>
<span class="sd">        |Taxon| object that will be created with the same label and</span>
<span class="sd">        added to :attr:`self.taxon_namespace`.  Calling this method results in</span>
<span class="sd">        the object (and all its member objects) being associated with a new,</span>
<span class="sd">        independent taxon namespace.</span>

<span class="sd">        Label mapping case sensitivity follows the</span>
<span class="sd">        ``self.taxon_namespace.is_case_sensitive`` setting. If</span>
<span class="sd">        |False| and ``unify_taxa_by_label`` is also |True|, then the</span>
<span class="sd">        establishment of correspondence between |Taxon| objects in the</span>
<span class="sd">        old and new namespaces with be based on case-insensitive matching of</span>
<span class="sd">        labels. E.g., if there are four |Taxon| objects with labels</span>
<span class="sd">        &#39;Foo&#39;, &#39;Foo&#39;, &#39;FOO&#39;, and &#39;FoO&#39; in the old namespace, then all objects</span>
<span class="sd">        that reference these will reference a single new |Taxon| object</span>
<span class="sd">        in the new namespace (with a label some existing casing variant of</span>
<span class="sd">        &#39;foo&#39;). If |True|: if ``unify_taxa_by_label`` is |True|,</span>
<span class="sd">        |Taxon| objects with labels identical except in case will be</span>
<span class="sd">        considered distinct.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxon_namespace : |TaxonNamespace|</span>
<span class="sd">            The |TaxonNamespace| into the scope of which this object</span>
<span class="sd">            will be moved.</span>

<span class="sd">        unify_taxa_by_label : boolean, optional</span>
<span class="sd">            If |True|, then references to distinct |Taxon| objects with</span>
<span class="sd">            identical labels in the current namespace will be replaced with a</span>
<span class="sd">            reference to a single |Taxon| object in the new namespace.</span>
<span class="sd">            If |False|: references to distinct |Taxon| objects will</span>
<span class="sd">            remain distinct, even if the labels are the same.</span>

<span class="sd">        taxon_mapping_memo : dictionary</span>
<span class="sd">            Similar to ``memo`` of deepcopy, this is a dictionary that maps</span>
<span class="sd">            |Taxon| objects in the old namespace to corresponding</span>
<span class="sd">            |Taxon| objects in the new namespace. Mostly for interal</span>
<span class="sd">            use when migrating complex data to a new namespace. Note that</span>
<span class="sd">            any mappings here take precedence over all other options: if a</span>
<span class="sd">            |Taxon| object in the old namespace is found in this</span>
<span class="sd">            dictionary, the counterpart in the new namespace will be whatever</span>
<span class="sd">            value is mapped, regardless of, e.g. label values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Use this method to move an object from one taxon namespace to</span>
<span class="sd">        another.</span>

<span class="sd">        For example, to get a copy of an object associated with another taxon</span>
<span class="sd">        namespace and associate it with a different namespace::</span>

<span class="sd">            # Get handle to the new TaxonNamespace</span>
<span class="sd">            other_taxon_namespace = some_other_data.taxon_namespace</span>

<span class="sd">            # Get a taxon-namespace scoped copy of a tree</span>
<span class="sd">            # in another namespace</span>
<span class="sd">            t2 = Tree(t1)</span>

<span class="sd">            # Replace taxon namespace of copy</span>
<span class="sd">            t2.migrate_taxon_namespace(other_taxon_namespace)</span>

<span class="sd">        You can also use this method to get a copy of a structure and then</span>
<span class="sd">        move it to a new namespace:</span>

<span class="sd">            t2 = Tree(t1)</span>
<span class="sd">            t2.migrate_taxon_namespace(TaxonNamespace())</span>

<span class="sd">            # Note: the same effect can be achived by:</span>
<span class="sd">            t3 = copy.deepcopy(t1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        reconstruct_taxon_namespace</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">TaxonNamespace</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_namespace</span> <span class="o">=</span> <span class="n">taxon_namespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruct_taxon_namespace</span><span class="p">(</span>
                <span class="n">unify_taxa_by_label</span><span class="o">=</span><span class="n">unify_taxa_by_label</span><span class="p">,</span>
                <span class="n">taxon_mapping_memo</span><span class="o">=</span><span class="n">taxon_mapping_memo</span><span class="p">)</span></div>


<div class="viewcode-block" id="TaxonNamespaceAssociated.reconstruct_taxon_namespace">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespaceAssociated.reconstruct_taxon_namespace">[docs]</a>
    <span class="k">def</span> <span class="nf">reconstruct_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">unify_taxa_by_label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">taxon_mapping_memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repopulates the current taxon namespace with new taxon objects,</span>
<span class="sd">        preserving labels. Each distinct |Taxon| object associated with</span>
<span class="sd">        ``self`` or members of ``self`` that is not already in</span>
<span class="sd">        ``self.taxon_namespace`` will be replaced with a new |Taxon|</span>
<span class="sd">        object that will be created with the same label and added to</span>
<span class="sd">        :attr:`self.taxon_namespace`.</span>

<span class="sd">        Label mapping case sensitivity follows the</span>
<span class="sd">        ``self.taxon_namespace.is_case_sensitive`` setting. If</span>
<span class="sd">        |False| and ``unify_taxa_by_label`` is also |True|, then the</span>
<span class="sd">        establishment of correspondence between |Taxon| objects in the</span>
<span class="sd">        old and new namespaces with be based on case-insensitive matching of</span>
<span class="sd">        labels. E.g., if there are four |Taxon| objects with labels</span>
<span class="sd">        &#39;Foo&#39;, &#39;Foo&#39;, &#39;FOO&#39;, and &#39;FoO&#39; in the old namespace, then all objects</span>
<span class="sd">        that reference these will reference a single new |Taxon| object</span>
<span class="sd">        in the new namespace (with a label some existing casing variant of</span>
<span class="sd">        &#39;foo&#39;). If |True|: if ``unify_taxa_by_label`` is |True|,</span>
<span class="sd">        |Taxon| objects with labels identical except in case will be</span>
<span class="sd">        considered distinct.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Existing |Taxon| objects in ``self.taxon_namespace`` are *not*</span>
<span class="sd">        removed. This method should thus only be called *only* when</span>
<span class="sd">        ``self.taxon_namespace`` has been changed. In fact, typical usage would</span>
<span class="sd">        not involve calling this method directly, but rather through</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unify_taxa_by_label : boolean, optional</span>
<span class="sd">            If |True|, then references to distinct |Taxon| objects with</span>
<span class="sd">            identical labels in the current namespace will be replaced with a</span>
<span class="sd">            reference to a single |Taxon| object in the new namespace.</span>
<span class="sd">            If |False|: references to distinct |Taxon| objects will</span>
<span class="sd">            remain distinct, even if the labels are the same.</span>

<span class="sd">        taxon_mapping_memo : dictionary</span>
<span class="sd">            Similar to ``memo`` of deepcopy, this is a dictionary that maps</span>
<span class="sd">            |Taxon| objects in the old namespace to corresponding</span>
<span class="sd">            |Taxon| objects in the new namespace. Mostly for interal</span>
<span class="sd">            use when migrating complex data to a new namespace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="TaxonNamespaceAssociated.update_taxon_namespace">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespaceAssociated.update_taxon_namespace">[docs]</a>
    <span class="k">def</span> <span class="nf">update_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All |Taxon| objects associated with ``self`` or members of ``self``</span>
<span class="sd">        that are not in ``self.taxon_namespace`` will be added. Note that, unlike</span>
<span class="sd">        ``reconstruct_taxon_namespace``, no new |Taxon| objects</span>
<span class="sd">        will be created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="TaxonNamespaceAssociated.purge_taxon_namespace">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespaceAssociated.purge_taxon_namespace">[docs]</a>
    <span class="k">def</span> <span class="nf">purge_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all |Taxon| instances in ``self.taxon_namespace`` that are</span>
<span class="sd">        not associated with ``self`` or any item in ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poll_taxa</span><span class="p">()</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">taxa</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">remove_taxon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></div>


<div class="viewcode-block" id="TaxonNamespaceAssociated.poll_taxa">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespaceAssociated.poll_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">poll_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxa</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a set populated with all of |Taxon| instances associated</span>
<span class="sd">        with ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxa : set()</span>
<span class="sd">            Set to populate. If not specified, a new one will be created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taxa : set[|Taxon|]</span>
<span class="sd">            Set of taxa associated with ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="TaxonNamespaceAssociated.reindex_taxa">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespaceAssociated.reindex_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">reindex_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: Use `migrate_taxon_namespace()` instead.</span>
<span class="sd">        Rebuilds ``taxon_namespace`` from scratch, or assigns |Taxon| objects from</span>
<span class="sd">        given |TaxonNamespace| object ``taxon_namespace`` based on label values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Deprecated since DendroPy 4: &#39;</span><span class="si">{class_name}</span><span class="s2">.reindex_taxa()&#39; will no longer be supported in future releases; use &#39;</span><span class="si">{class_name}</span><span class="s2">.migrate_taxon_namespace()&#39; instead&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">taxon_namespace</span>
        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reindex_subcomponent_taxa</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span></div>


<div class="viewcode-block" id="TaxonNamespaceAssociated.reindex_subcomponent_taxa">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespaceAssociated.reindex_subcomponent_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">reindex_subcomponent_taxa</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: Use :meth:`reconstruct_taxon_namespace()` instead.</span>
<span class="sd">        Derived classes should override this to ensure that their various</span>
<span class="sd">        components, attributes and members all refer to the same |TaxonNamespace|</span>
<span class="sd">        object as ``self.taxon_namespace``, and that ``self.taxon_namespace`` has all</span>
<span class="sd">        the |Taxon| objects in the various members.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>
</div>



<span class="c1">##############################################################################</span>
<span class="c1">## TaxonNamespace</span>

<div class="viewcode-block" id="TaxonNamespace">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace">[docs]</a>
<span class="k">class</span> <span class="nc">TaxonNamespace</span><span class="p">(</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">Deserializable</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">MultiReadable</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">Serializable</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">Annotable</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A collection of |Taxon| objects representing a self-contained and complete</span>
<span class="sd">    domain of distinct operational taxonomic unit definitions.</span>
<span class="sd">    Provides the common semantic context in which operational taxonomic units</span>
<span class="sd">    referenced by various phylogenetic data objects (e.g., trees or alignments)</span>
<span class="sd">    can be related.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">### Life-cycle</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        \*args : positional arguments, optional</span>
<span class="sd">            Accepts a single iterable as an optional positional argument.  If a</span>
<span class="sd">            |TaxonNamespace| object is passed as the positional argument, then</span>
<span class="sd">            clones or deep-copies of its member |Taxon| objects will be added</span>
<span class="sd">            to this one.  If any other iterable is passed as the positional</span>
<span class="sd">            argument, then each string in the iterable will result in a new</span>
<span class="sd">            |Taxon| object being constructed and added to the namespace with</span>
<span class="sd">            the string as its label (name), while each Taxon object in the</span>
<span class="sd">            iterable will be added to the namespace directly.</span>

<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            label : string</span>
<span class="sd">                The label or name for this namespace.</span>
<span class="sd">            is_mutable : boolean, optional (default = |True|)</span>
<span class="sd">                If |True| (default), then |Taxon| objects can be added to this</span>
<span class="sd">                namespace. If |False|, then adding |Taxon| objects will result</span>
<span class="sd">                in an error.</span>
<span class="sd">            is_case_sensitive : boolean, optional (default = |False|)</span>
<span class="sd">                Whether or not taxon names are considered case sensitive or</span>
<span class="sd">                insensitive.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        An empty |TaxonNamespace| can be created (with optional) label and |Taxon|</span>
<span class="sd">        objects added later:</span>

<span class="sd">        &gt;&gt;&gt; tns = dendropy.TaxonNamespace(label=&quot;taxa&quot;)</span>
<span class="sd">        &gt;&gt;&gt; t1 = Taxon(&quot;a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tns.add_taxon(t1)</span>
<span class="sd">        &gt;&gt;&gt; t2 = Taxon(&quot;b&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tns.add_taxon(t2)</span>
<span class="sd">        &gt;&gt;&gt; tns.add_taxon(&quot;c&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tns</span>
<span class="sd">        &lt;TaxonNamespace 0x106509090 &#39;taxa&#39;: [&lt;Taxon 0x10661f050 &#39;a&#39;&gt;, &lt;Taxon 0x10651c590 &#39;b&#39;&gt;, &lt;Taxon 0x106642a90 &#39;c&#39;&gt;]&gt;</span>

<span class="sd">        Alternatively, an iterable can be passed in as an initializer, and all</span>
<span class="sd">        |Taxon| objects will be added directly while, for each string, a new</span>
<span class="sd">        |Taxon| object will be created and added. So, the below are all equivalent</span>
<span class="sd">        to the above:</span>

<span class="sd">        &gt;&gt;&gt; tns = dendropy.TaxonNamespace([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], label=&quot;taxa&quot;)</span>

<span class="sd">        &gt;&gt;&gt; taxa = [Taxon(n) for n in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]]</span>
<span class="sd">        &gt;&gt;&gt; tns = dendropy.taxonnamespace(taxa, label=&quot;taxa&quot;)</span>

<span class="sd">        &gt;&gt;&gt; t1 = Taxon(&quot;a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; t2 = Taxon(&quot;b&quot;)</span>
<span class="sd">        &gt;&gt;&gt; taxa = [t1, t2, &quot;c&quot;]</span>
<span class="sd">        &gt;&gt;&gt; tns = dendropy.TaxonNamespace(taxa, label=&quot;taxa&quot;)</span>

<span class="sd">        If a |TaxonNamespace| object is passed as the</span>
<span class="sd">        initializer argument, a *shallow* copy of the object is constructed:</span>

<span class="sd">        &gt;&gt;&gt; tns1 = dendropy.TaxonNamespace([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], label=&quot;taxa1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tns1</span>
<span class="sd">        &lt;TaxonNamespace 0x1097275d0 &#39;taxa1&#39;: [&lt;Taxon 0x109727610 &#39;a&#39;&gt;, &lt;Taxon 0x109727e10 &#39;b&#39;&gt;, &lt;Taxon 0x109727e90 &#39;c&#39;&gt;]&gt;</span>
<span class="sd">        &gt;&gt;&gt; tns2 = dendropy.TaxonNamespace(tns1, label=&quot;2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tns2</span>
<span class="sd">        &lt;TaxonNamespace 0x109727d50 &#39;taxa1&#39;: [&lt;Taxon 0x109727610 &#39;a&#39;&gt;, &lt;Taxon 0x109727e10 &#39;b&#39;&gt;, &lt;Taxon 0x109727e90 &#39;c&#39;&gt;]&gt;</span>

<span class="sd">        Thus, while &quot;``tns1``&quot; and &quot;``tns2``&quot; are independent collections, and</span>
<span class="sd">        addition/deletion of |Taxon| instances to one will not effect</span>
<span class="sd">        the other, the label of a |Taxon| instance that is an element in</span>
<span class="sd">        one will of course effect the same instance if it is in the other:</span>

<span class="sd">        &gt;&gt;&gt; print(tns1[0].label)</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        &gt;&gt;&gt; print(tns2[0].label)</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        &gt;&gt;&gt; tns1[0].label = &quot;Z&quot;</span>
<span class="sd">        &gt;&gt;&gt; print(tns1[0].label)</span>
<span class="sd">        &gt;&gt;&gt; Z</span>
<span class="sd">        &gt;&gt;&gt; print(tns2[0].label)</span>
<span class="sd">        &gt;&gt;&gt; Z</span>

<span class="sd">        In contrast to actual data (i.e., the |Taxon| objects), alll</span>
<span class="sd">        metadata associated with &quot;``tns2``&quot; (i.e., the |AnnotationSet| object,</span>
<span class="sd">        in the :attr:`TaxonNamespace.annotations` attribute), will be a full,</span>
<span class="sd">        independent deep-copy.</span>

<span class="sd">        If what is needed is a true deep-copy of the data of a particular</span>
<span class="sd">        |TaxonNamespace| object, including copies of the member</span>
<span class="sd">        |Taxon| instances, then this can be achieved using</span>
<span class="sd">        :func:`copy.deepcopy()`.</span>

<span class="sd">        &gt;&gt;&gt; import copy</span>
<span class="sd">        &gt;&gt;&gt; tns1 = dendropy.TaxonNamespace([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], label=&quot;taxa1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tns2 = copy.deepcopy(tns1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs_set_label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;is_mutable&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_case_sensitive</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;is_case_sensitive&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accession_index_taxon_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_accession_index_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_bitmask_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># self._split_bitmask_taxon_map = {}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_accession_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;TaxonNamespace() takes at most 1 non-keyword argument (</span><span class="si">{}</span><span class="s2"> given)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># special case: construct from argument</span>
            <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">kwargs_set_label</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Taxon</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_taxon</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">new_taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TaxonNamespace</span><span class="p">):</span>
                <span class="n">memo</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">):</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_taxa</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span> <span class="p">}</span>
                <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_taxa</span><span class="p">):</span>
                    <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">t2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">t1</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_annotations&quot;</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_taxa&quot;</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">memo</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy_annotations_from</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
                <span class="c1"># self.copy_annotations_from(other, attribute_object_mapper=memo)</span>
            <span class="c1"># override with label with value passed as argument</span>
            <span class="k">if</span> <span class="n">kwargs_set_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">kwargs_set_label</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">kwargs_set_label</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unrecognized or unsupported arguments: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TaxonNamespace</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="TaxonNamespace.taxon_namespace_scoped_copy">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.taxon_namespace_scoped_copy">[docs]</a>
    <span class="k">def</span> <span class="nf">taxon_namespace_scoped_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">populate_memo_for_taxon_namespace_scoped_copy</span><span class="p">(</span><span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">o</span>
        <span class="n">o</span><span class="o">.</span><span class="n">_taxa</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">)]</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">_taxa</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">:</span>
            <span class="n">o</span><span class="o">.</span><span class="n">_taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_annotations&quot;</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_taxa&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">o</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">o</span><span class="o">.</span><span class="n">deep_copy_annotations_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
        <span class="c1"># o.copy_annotations_from(self, attribute_object_mapper=memo)</span>
        <span class="k">return</span> <span class="n">o</span>

    <span class="k">def</span> <span class="nf">populate_memo_for_taxon_namespace_scoped_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">:</span>
                <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">taxon</span><span class="p">)]</span> <span class="o">=</span> <span class="n">taxon</span>
        <span class="k">return</span> <span class="n">memo</span>

    <span class="c1">### Identity and Comparison</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;[</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">]))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> &#39;</span><span class="si">{}</span><span class="s2">&#39;: [</span><span class="si">{}</span><span class="s2">]&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_taxa</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># enforce non-equivalence of non-identical namespaces</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span>
        <span class="c1"># if not isinstance(other, self.__class__):</span>
        <span class="c1">#     return False</span>
        <span class="c1"># return (self.label == other.label</span>
        <span class="c1">#         and self._taxa == other._taxa</span>
        <span class="c1">#         and basemodel.Annotable.__eq__(self, other))</span>

    <span class="c1">### Collection Iteration</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">)</span>

    <span class="c1">### Collection Data</span>

<div class="viewcode-block" id="TaxonNamespace.__len__">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.__len__">[docs]</a>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns number of |Taxon| objects in this |TaxonNamespace|.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">)</span></div>


    <span class="c1">### Collection Access and Management</span>

<div class="viewcode-block" id="TaxonNamespace.__getitem__">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns |Taxon| object with index or slice given by ``key``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;TaxonNamespace[]&#39; now only accepts indexes or slices. To access Taxon objects by label, use &#39;TaxonNamespace.get_taxon()&#39; or &#39;TaxonNamespace.findall()&#39;&quot;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Item assignment not supported&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_taxon</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

<div class="viewcode-block" id="TaxonNamespace.__contains__">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.__contains__">[docs]</a>
    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns |True| if Taxon object ``taxon`` is in self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># look-up in dictionary for O(1) instead of O(n) in list</span>
        <span class="k">return</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_accession_index_map</span></div>


    <span class="k">def</span> <span class="nf">_lookup_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">label</span><span class="p">,</span>
            <span class="n">is_case_sensitive</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">first_match_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">error_if_not_found</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return |Taxon| object(s) with label matching ``label``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : str</span>
<span class="sd">            The label for which to search.</span>
<span class="sd">        is_case_sensitive : |None| or bool</span>
<span class="sd">            By default, label lookup will use the</span>
<span class="sd">            ``is_case_sensitive`` attribute of ``self`` to decide</span>
<span class="sd">            whether or not to respect case when trying to match labels to</span>
<span class="sd">            operational taxonomic unit names represented by |Taxon|</span>
<span class="sd">            instances. This can be over-ridden by specifying</span>
<span class="sd">            ``is_case_sensitive`` to |True| (forcing case-sensitivity) or |False|</span>
<span class="sd">            (forcing case-insensitivity).</span>
<span class="sd">        first_match_only : bool</span>
<span class="sd">            If |False|, then the entire namespace will be searched and *all*</span>
<span class="sd">            |Taxon| objects with the matching labels will be returned</span>
<span class="sd">            as a list. If |True| then the function will return after</span>
<span class="sd">            processing the first |Taxon| object with a matching label</span>
<span class="sd">            (i.e., the entire namespace is not searched). Setting this</span>
<span class="sd">            argument to |True| will be more efficient and should be preferred</span>
<span class="sd">            if there are no redundant or duplicate labels.</span>
<span class="sd">        error_if_not_found : bool</span>
<span class="sd">            If |True|, then a LookupError is raised if there are no matches.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : |None| or |Taxon| instance or list[|Taxon|]</span>
<span class="sd">            If no |Taxon| instances have ``label`` attributes that match</span>
<span class="sd">            the ``label`` argument, then |None|. Otherise, if</span>
<span class="sd">            `first_match_only==True`, then a |Taxon| instance with</span>
<span class="sd">            ``label`` attribute matching the value of the ``label`` argument; if</span>
<span class="sd">            `first_match_only==False`, a list of one or more |Taxon|</span>
<span class="sd">            instances with a ``label`` attribute matching the ``label`` argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxa</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">is_case_sensitive</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_case_sensitive</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_case_sensitive</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="n">taxon</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">first_match_only</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">taxon</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="n">taxon</span><span class="o">.</span><span class="n">lower_cased_label</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">first_match_only</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">taxon</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">error_if_not_found</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">taxa</span>

    <span class="c1">### Adding Taxa</span>

<div class="viewcode-block" id="TaxonNamespace.add_taxon">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.add_taxon">[docs]</a>
    <span class="k">def</span> <span class="nf">add_taxon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new |Taxon| object to ``self``.</span>

<span class="sd">        If ``taxon`` is not already in the collection of |Taxon| objects in this</span>
<span class="sd">        namespace, and this namespace is mutable, it is added to the</span>
<span class="sd">        collection. If it is already in the collection, then nothing happens.</span>
<span class="sd">        If it is not already in the collection, but the namespace is not</span>
<span class="sd">        mutable, then TypeError is raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxon : |Taxon|</span>
<span class="sd">            The |Taxon| object to be accessioned or registered in this</span>
<span class="sd">            collection.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If this namespace is immutable (i.e.</span>
<span class="sd">            :attr:`TaxonNamespace.is_mutable` is |False|).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE</span>
        <span class="c1"># Previously, this was:</span>
        <span class="c1">#</span>
        <span class="c1">#     if taxon in self._taxa:</span>
        <span class="c1">#</span>
        <span class="c1"># Changing the membership lookup to dictionaries resulted in 10x</span>
        <span class="c1"># increase in speed!!!!</span>
        <span class="k">if</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_accession_index_map</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">ImmutableTaxonNamespaceError</span><span class="p">(</span><span class="s2">&quot;Taxon &#39;</span><span class="si">{}</span><span class="s2">&#39; cannot be added to an immutable TaxonNamespace&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accession_index_taxon_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_accession_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">taxon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_accession_index_map</span><span class="p">[</span><span class="n">taxon</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_accession_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_accession_count</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="TaxonNamespace.append">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.append">[docs]</a>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LEGACY. Use &#39;add_taxon()&#39; instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_taxon</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span></div>


<div class="viewcode-block" id="TaxonNamespace.add_taxa">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.add_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">add_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxa</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds multiple |Taxon| objects to self.</span>

<span class="sd">        Each |Taxon| object in ``taxa`` that is not already in the collection of</span>
<span class="sd">        |Taxon| objects in this namespace is added to it. If any of the |Taxon|</span>
<span class="sd">        objects are already in the collection, then nothing happens. If the</span>
<span class="sd">        namespace is immutable, then TypeError is raised when trying</span>
<span class="sd">        to add |Taxon| objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxa : collections.Iterable [|Taxon|]</span>
<span class="sd">            A list of |Taxon| objects to be accessioned or registered in this</span>
<span class="sd">            collection.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If this namespace is immutable (i.e. :attr:`TaxonNamespace.is_mutable` is</span>
<span class="sd">            |False|).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">taxa</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_taxon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></div>


<div class="viewcode-block" id="TaxonNamespace.new_taxon">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.new_taxon">[docs]</a>
    <span class="k">def</span> <span class="nf">new_taxon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates, adds, and returns a new |Taxon| object with corresponding</span>
<span class="sd">        label.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : string or string-like</span>
<span class="sd">            The name or label of the new operational taxonomic unit concept.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taxon: |Taxon|</span>
<span class="sd">            The new |Taxon| object,</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">ImmutableTaxonNamespaceError</span><span class="p">(</span><span class="s2">&quot;Taxon &#39;</span><span class="si">{}</span><span class="s2">&#39; cannot be added to an immutable TaxonNamespace&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
        <span class="n">taxon</span> <span class="o">=</span> <span class="n">Taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_taxon</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">taxon</span></div>


<div class="viewcode-block" id="TaxonNamespace.new_taxa">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.new_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">new_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and add a new |Taxon| with corresponding label for each label</span>
<span class="sd">        in ``labels``. Returns list of |Taxon| objects created.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : ``collections.Iterable`` [string]</span>
<span class="sd">            The values of the ``label`` attributes of the new |Taxon| objects to</span>
<span class="sd">            be created, added to this namespace collection, and returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taxa : ``collections.Iterable`` [|Taxon|]</span>
<span class="sd">            A list of |Taxon| objects created and added.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If this namespace is immutable (i.e.</span>
<span class="sd">            :attr:`TaxonNamespace.is_mutable` is |False|).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">ImmutableTaxonNamespaceError</span><span class="p">(</span><span class="s2">&quot;Taxon objects cannot be added to an immutable TaxonNamespace&quot;</span><span class="p">)</span>
        <span class="n">taxa</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">new_taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">taxa</span></div>


    <span class="c1">### Removing Taxa</span>

<div class="viewcode-block" id="TaxonNamespace.remove_taxon">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.remove_taxon">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_taxon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes specified |Taxon| object from the collection in this namespace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxon : a |Taxon| object</span>
<span class="sd">            The |Taxon| object to be removed.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``taxon`` is not in the collection of this namespace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">taxon</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
        <span class="c1"># assert taxon not in self._taxa</span>
        <span class="k">while</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_accession_index_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">taxon</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_accession_index_taxon_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_accession_index_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">taxon</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">bm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_bitmask_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">taxon</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># self._split_bitmask_taxon_map.pop(bm, None)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_accession_index_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">taxon</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon</span><span class="p">):</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Deprecated since DendroPy 4: &#39;TaxonNamespace.remove()&#39;; use &#39;TaxonNamespace.remove_taxon()&#39; instead&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_taxon</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>

<div class="viewcode-block" id="TaxonNamespace.remove_taxon_label">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.remove_taxon_label">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_taxon_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">label</span><span class="p">,</span>
            <span class="n">is_case_sensitive</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">first_match_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes *all* |Taxon| objects with label matching ``label`` from the</span>
<span class="sd">        collection in this namespace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : string or string-like</span>
<span class="sd">            The value of the |Taxon| object label to remove.</span>
<span class="sd">        is_case_sensitive : |None| or bool</span>
<span class="sd">            By default, label lookup will use the</span>
<span class="sd">            ``is_case_sensitive`` attribute of ``self`` to decide</span>
<span class="sd">            whether or not to respect case when trying to match labels to</span>
<span class="sd">            operational taxonomic unit names represented by |Taxon|</span>
<span class="sd">            instances. This can be over-ridden by specifying</span>
<span class="sd">            ``is_case_sensitive`` to |True| (forcing case-sensitivity) or |False|</span>
<span class="sd">            (forcing case-insensitivity).</span>
<span class="sd">        first_match_only : bool</span>
<span class="sd">            If |False|, then the entire namespace will be searched and *all*</span>
<span class="sd">            |Taxon| objects with the matching labels will be remove. If</span>
<span class="sd">            |True| then only the first |Taxon| object with a matching</span>
<span class="sd">            label will be removed (i.e., the entire namespace is not searched).</span>
<span class="sd">            Setting this argument to |True| will be more efficient and should</span>
<span class="sd">            be preferred if there are no redundant or duplicate labels.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        LookupError</span>
<span class="sd">            If no |Taxon| objects are found with matching label(s).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`TaxonNamespace.discard_taxon_labels`</span>
<span class="sd">            Similar, but does not raise an error if no matching |Taxon|</span>
<span class="sd">            objects are found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_label</span><span class="p">(</span><span class="n">label</span><span class="p">,</span>
                <span class="n">is_case_sensitive</span><span class="o">=</span><span class="n">is_case_sensitive</span><span class="p">,</span>
                <span class="n">first_match_only</span><span class="o">=</span><span class="n">first_match_only</span><span class="p">,</span>
                <span class="n">error_if_not_found</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="n">taxa</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_taxon</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span></div>


<div class="viewcode-block" id="TaxonNamespace.discard_taxon_label">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.discard_taxon_label">[docs]</a>
    <span class="k">def</span> <span class="nf">discard_taxon_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">label</span><span class="p">,</span>
            <span class="n">is_case_sensitive</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">first_match_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes *all* |Taxon| objects with label matching ``label`` from the</span>
<span class="sd">        collection in this namespace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : string or string-like</span>
<span class="sd">            The value of the |Taxon| object label to remove.</span>
<span class="sd">        is_case_sensitive : |None| or bool</span>
<span class="sd">            By default, label lookup will use the</span>
<span class="sd">            ``is_case_sensitive`` attribute of ``self`` to decide</span>
<span class="sd">            whether or not to respect case when trying to match labels to</span>
<span class="sd">            operational taxonomic unit names represented by |Taxon|</span>
<span class="sd">            instances. This can be over-ridden by specifying</span>
<span class="sd">            ``is_case_sensitive`` to |True| (forcing case-sensitivity) or |False|</span>
<span class="sd">            (forcing case-insensitivity).</span>
<span class="sd">        first_match_only : bool</span>
<span class="sd">            If |False|, then the entire namespace will be searched and *all*</span>
<span class="sd">            |Taxon| objects with the matching labels will be remove. If</span>
<span class="sd">            |True| then only the first |Taxon| object with a matching</span>
<span class="sd">            label will be removed (i.e., the entire namespace is not searched).</span>
<span class="sd">            Setting this argument to |True| will be more efficient and should</span>
<span class="sd">            be preferred if there are no redundant or duplicate labels.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`TaxonNamespace.remove_taxon_label` : Similar, but</span>
<span class="sd">            raises an error if no matching |Taxon| objects are found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_label</span><span class="p">(</span><span class="n">label</span><span class="p">,</span>
                <span class="n">is_case_sensitive</span><span class="o">=</span><span class="n">is_case_sensitive</span><span class="p">,</span>
                <span class="n">first_match_only</span><span class="o">=</span><span class="n">first_match_only</span><span class="p">,</span>
                <span class="n">error_if_not_found</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">taxa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="n">taxa</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_taxon</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span></div>


<div class="viewcode-block" id="TaxonNamespace.clear">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.clear">[docs]</a>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all |Taxon| objects from this namespace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accession_index_taxon_map</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_accession_index_map</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_bitmask_map</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

        <span class="c1"># self._split_bitmask_taxon_map.clear()</span>

    <span class="c1">### Look-up and Retrieval of Taxa</span>

<div class="viewcode-block" id="TaxonNamespace.findall">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.findall">[docs]</a>
    <span class="k">def</span> <span class="nf">findall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">is_case_sensitive</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return list of |Taxon| object(s) with label matching ``label``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : string or string-like</span>
<span class="sd">            The value which the ``label`` attribute of the |Taxon| object(s)</span>
<span class="sd">            to be returned must match.</span>
<span class="sd">        is_case_sensitive : |None| or bool</span>
<span class="sd">            By default, label lookup will use the</span>
<span class="sd">            ``is_case_sensitive`` attribute of ``self`` to decide</span>
<span class="sd">            whether or not to respect case when trying to match labels to</span>
<span class="sd">            operational taxonomic unit names represented by |Taxon|</span>
<span class="sd">            instances. This can be over-ridden by specifying</span>
<span class="sd">            ``is_case_sensitive`` to |True| (forcing case-sensitivity) or |False|</span>
<span class="sd">            (forcing case-insensitivity).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taxa : ``list`` [|Taxon|]</span>
<span class="sd">            A list containing zero or more |Taxon| objects with labels</span>
<span class="sd">            matching ``label``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_label</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                <span class="n">is_case_sensitive</span><span class="o">=</span><span class="n">is_case_sensitive</span><span class="p">,</span>
                <span class="n">first_match_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">error_if_not_found</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">taxa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">taxa</span></div>


<div class="viewcode-block" id="TaxonNamespace.has_taxon_label">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.has_taxon_label">[docs]</a>
    <span class="k">def</span> <span class="nf">has_taxon_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">is_case_sensitive</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks for presence of a |Taxon| object with the given label.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : string or string-like</span>
<span class="sd">            The value of the |Taxon| object label to match.</span>
<span class="sd">        is_case_sensitive : |None| or bool</span>
<span class="sd">            By default, label lookup will use the</span>
<span class="sd">            ``is_case_sensitive`` attribute of ``self`` to decide</span>
<span class="sd">            whether or not to respect case when trying to match labels to</span>
<span class="sd">            operational taxonomic unit names represented by |Taxon|</span>
<span class="sd">            instances. This can be over-ridden by specifying</span>
<span class="sd">            ``is_case_sensitive`` to |True| (forcing case-sensitivity) or |False|</span>
<span class="sd">            (forcing case-insensitivity).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b : boolean</span>
<span class="sd">            |True| if there is at least one |Taxon| object in this namespace</span>
<span class="sd">            with a label matching the value of ``label``. Otherwise, |False|.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_label</span><span class="p">(</span>
                <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                <span class="n">is_case_sensitive</span><span class="o">=</span><span class="n">is_case_sensitive</span><span class="p">,</span>
                <span class="n">first_match_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">error_if_not_found</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="TaxonNamespace.has_taxa_labels">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.has_taxa_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">has_taxa_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">is_case_sensitive</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks for presence of |Taxon| objects with the given labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : ``collections.Iterable`` [string]</span>
<span class="sd">            The values of the |Taxon| object labels to match.</span>
<span class="sd">        is_case_sensitive : |None| or bool</span>
<span class="sd">            By default, label lookup will use the</span>
<span class="sd">            ``is_case_sensitive`` attribute of ``self`` to decide</span>
<span class="sd">            whether or not to respect case when trying to match labels to</span>
<span class="sd">            operational taxonomic unit names represented by |Taxon|</span>
<span class="sd">            instances. This can be over-ridden by specifying</span>
<span class="sd">            ``is_case_sensitive`` to |True| (forcing case-sensitivity) or |False|</span>
<span class="sd">            (forcing case-insensitivity).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b : boolean</span>
<span class="sd">            Returns |True| if, for every element in the iterable ``labels``,</span>
<span class="sd">            there is at least one |Taxon| object that has a label attribute</span>
<span class="sd">            that matches this. |False| otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_label</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                    <span class="n">is_case_sensitive</span><span class="o">=</span><span class="n">is_case_sensitive</span><span class="p">,</span>
                    <span class="n">first_match_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">error_if_not_found</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="TaxonNamespace.get_taxon">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.get_taxon">[docs]</a>
    <span class="k">def</span> <span class="nf">get_taxon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">is_case_sensitive</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a |Taxon| object with the given label.</span>

<span class="sd">        If multiple |Taxon| objects exist with labels that match</span>
<span class="sd">        ``label``, then only the first one is returned.  If no |Taxon|</span>
<span class="sd">        object is found in this namespace with the specified critieria,</span>
<span class="sd">        |None| is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : string or string-like</span>
<span class="sd">            The value which the ``label`` attribute of the |Taxon| object</span>
<span class="sd">            to be returned must match.</span>
<span class="sd">        is_case_sensitive : |None| or bool</span>
<span class="sd">            By default, label lookup will use the</span>
<span class="sd">            ``is_case_sensitive`` attribute of ``self`` to decide</span>
<span class="sd">            whether or not to respect case when trying to match labels to</span>
<span class="sd">            operational taxonomic unit names represented by |Taxon|</span>
<span class="sd">            instances. This can be over-ridden by specifying</span>
<span class="sd">            ``is_case_sensitive`` to |True| (forcing case-sensitivity) or |False|</span>
<span class="sd">            (forcing case-insensitivity).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taxon : |Taxon| object or |None|</span>
<span class="sd">            The first |Taxon| object in this namespace collection with a label</span>
<span class="sd">            matching ``label``, or |None| if no such |Taxon| object exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_label</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                <span class="n">is_case_sensitive</span><span class="o">=</span><span class="n">is_case_sensitive</span><span class="p">,</span>
                <span class="n">first_match_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">error_if_not_found</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="TaxonNamespace.get_taxa">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.get_taxa">[docs]</a>
    <span class="k">def</span> <span class="nf">get_taxa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">is_case_sensitive</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">first_match_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves list of |Taxon| objects with given labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : ``collections.Iterable`` [string]</span>
<span class="sd">            Any |Taxon| object in this namespace collection that has a label</span>
<span class="sd">            attribute that matches any value in ``labels`` will be included in</span>
<span class="sd">            the list returned.</span>
<span class="sd">        is_case_sensitive : |None| or bool</span>
<span class="sd">            By default, label lookup will use the</span>
<span class="sd">            ``is_case_sensitive`` attribute of ``self`` to decide</span>
<span class="sd">            whether or not to respect case when trying to match labels to</span>
<span class="sd">            operational taxonomic unit names represented by |Taxon|</span>
<span class="sd">            instances. This can be over-ridden by specifying</span>
<span class="sd">            ``is_case_sensitive`` to |True| (forcing case-sensitivity) or |False|</span>
<span class="sd">            (forcing case-insensitivity).</span>
<span class="sd">        first_match_only : bool</span>
<span class="sd">            If |False|, then for *each* label in ``labels``, the entire namespace</span>
<span class="sd">            will be searched and *all* |Taxon| objects with the matches</span>
<span class="sd">            will be added to the lest. If |True| then, for each label in</span>
<span class="sd">            ``labels``, only the first |Taxon| object with a matching</span>
<span class="sd">            label will be added to the list (i.e., the entire namespace is not</span>
<span class="sd">            searched). Setting this argument to |True| will be more</span>
<span class="sd">            efficient and should be preferred if there are no redundant or</span>
<span class="sd">            duplicate labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taxa : ``list`` [|Taxon|]</span>
<span class="sd">            A list containing zero or more |Taxon| objects with labels</span>
<span class="sd">            matching ``label``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxa</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_label</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                    <span class="n">is_case_sensitive</span><span class="o">=</span><span class="n">is_case_sensitive</span><span class="p">,</span>
                    <span class="n">first_match_only</span><span class="o">=</span><span class="n">first_match_only</span><span class="p">,</span>
                    <span class="n">error_if_not_found</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">tt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">first_match_only</span><span class="p">:</span>
                <span class="n">taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tt</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">taxa</span><span class="p">:</span>
                        <span class="n">taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">taxa</span></div>


<div class="viewcode-block" id="TaxonNamespace.require_taxon">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.require_taxon">[docs]</a>
    <span class="k">def</span> <span class="nf">require_taxon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">is_case_sensitive</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a |Taxon| object with the given label, creating it if</span>
<span class="sd">        necessary.</span>

<span class="sd">        Retrieves a Taxon object with the label, ``label``.</span>
<span class="sd">        If multiple |Taxon| objects exist with labels that match</span>
<span class="sd">        ``label``, then only the first one is returned.  If no such</span>
<span class="sd">        |Taxon| object exists in the current namespace and the</span>
<span class="sd">        |TaxonNamespace| is NOT mutable, an exception is raised.  If no</span>
<span class="sd">        such |Taxon| object exists in the current namespace and</span>
<span class="sd">        |TaxonNamespace| is mutable, then a new |Taxon| is</span>
<span class="sd">        created, added, and returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : string or string-like</span>
<span class="sd">            The value which the ``label`` attribute of the |Taxon| object</span>
<span class="sd">            to be returned must match.</span>
<span class="sd">        is_case_sensitive : |None| or bool</span>
<span class="sd">            By default, label lookup will use the</span>
<span class="sd">            ``is_case_sensitive`` attribute of ``self`` to decide</span>
<span class="sd">            whether or not to respect case when trying to match labels to</span>
<span class="sd">            operational taxonomic unit names represented by |Taxon|</span>
<span class="sd">            instances. This can be over-ridden by specifying</span>
<span class="sd">            ``is_case_sensitive`` to |True| (forcing case-sensitivity) or |False|</span>
<span class="sd">            (forcing case-insensitivity).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taxon : |Taxon| object or |None|</span>
<span class="sd">            A |Taxon| object in this namespace collection with a label</span>
<span class="sd">            matching ``label``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If no |Taxon| object is currently in the collection with a label</span>
<span class="sd">            matching the input ``label`` and the ``is_mutable`` attribute of self</span>
<span class="sd">            is |False|.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_label</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                <span class="n">is_case_sensitive</span><span class="o">=</span><span class="n">is_case_sensitive</span><span class="p">,</span>
                <span class="n">first_match_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">error_if_not_found</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">taxon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">taxon</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mutable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">ImmutableTaxonNamespaceError</span><span class="p">(</span><span class="s2">&quot;Taxon &#39;</span><span class="si">{}</span><span class="s2">&#39; not in TaxonNamespace, and cannot be created because TaxonNamespace is immutable&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
        <span class="n">taxon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">taxon</span></div>


    <span class="c1">### Taxon Ordering</span>

<div class="viewcode-block" id="TaxonNamespace.sort">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.sort">[docs]</a>
    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts |Taxon| objects in collection. If ``key`` is not given, defaults</span>
<span class="sd">        to sorting by label (i.e., ``key = lambda x: x.label``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : key function object, optional</span>
<span class="sd">            Function that takes a |Taxon| object as an argument and</span>
<span class="sd">            returns the value that determines its sort order. Defaults to</span>
<span class="sd">            sorting by label.</span>
<span class="sd">        reverse : boolean, optional</span>
<span class="sd">            If |True|, sort will be in reverse order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span></div>


<div class="viewcode-block" id="TaxonNamespace.reverse">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.reverse">[docs]</a>
    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverses order of |Taxon| objects in collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span></div>


    <span class="c1">### Summarization of Collection</span>

<div class="viewcode-block" id="TaxonNamespace.labels">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.labels">[docs]</a>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of labels of all |Taxon| objects in ``self``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels : ``list`` [string]</span>
<span class="sd">            List of :attr:`Taxon.label` values of |Taxon| objects in</span>
<span class="sd">            ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">]</span></div>


<div class="viewcode-block" id="TaxonNamespace.label_taxon_map">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.label_taxon_map">[docs]</a>
    <span class="k">def</span> <span class="nf">label_taxon_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_case_sensitive</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns dictionary with taxon labels as keys and corresponding |Taxon|</span>
<span class="sd">        objects as values.</span>

<span class="sd">        If the |TaxonNamespace| is currently case-insensitive, then the</span>
<span class="sd">        dictionary returned will have case-insensitive keys, other the</span>
<span class="sd">        dictionary will be case-sensitive. You can override this by explicitly</span>
<span class="sd">        specifying ``is_case_sensitive`` to |False| or |True|.</span>

<span class="sd">        No attempt is made to handle collisions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        d : dictonary-like</span>
<span class="sd">            Dictionary with :attr:`Taxon.label` values of |Taxon| objects in</span>
<span class="sd">            ``self`` as keys and corresponding |Taxon| objects as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_case_sensitive</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_case_sensitive</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_case_sensitive</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">CaseInsensitiveDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxa</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">d</span></div>


    <span class="c1">### Split Management</span>

    <span class="c1"># def complement_bitmask(self, bitmask):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Returns complement of the given split or clade bitmask.</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     bitmask : integer</span>
    <span class="c1">#         Bitmask to be complemented.</span>

    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     h : integer</span>
    <span class="c1">#         Complement of ``bitmask``.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     return (~bitmask) &amp; self.all_taxa_bitmask()</span>

    <span class="c1"># def normalize_bitmask(self, bitmask):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     &quot;Normalizes&quot; split, by ensuring that the least-significant bit is</span>
    <span class="c1">#     always 1 (used on unrooted trees to establish split identity</span>
    <span class="c1">#     independent of rotation).</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     bitmask : integer</span>
    <span class="c1">#         Split bitmask hash to be normalized.</span>

    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     h : integer</span>
    <span class="c1">#         Normalized split bitmask.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     return container.NormalizedBitmaskDict.normalize(bitmask, self.all_taxa_bitmask(), 1)</span>

<div class="viewcode-block" id="TaxonNamespace.all_taxa_bitmask">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.all_taxa_bitmask">[docs]</a>
    <span class="k">def</span> <span class="nf">all_taxa_bitmask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns mask of all taxa.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : integer</span>
<span class="sd">            Bitmask spanning all |Taxon| objects in self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#return pow(2, len(self)) - 1</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_accession_count</span>
        <span class="k">return</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="TaxonNamespace.taxon_bitmask">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.taxon_bitmask">[docs]</a>
    <span class="k">def</span> <span class="nf">taxon_bitmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns bitmask value of split hash for split subtending node with</span>
<span class="sd">        ``taxon``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxon : |Taxon|</span>
<span class="sd">            |Taxon| object for which to calculate split hash bitmask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : integer</span>
<span class="sd">            Split hash bitmask value for node associated with |Taxon| object ``taxon``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># i = self._taxa.index(taxon)</span>
        <span class="c1"># m = 1 &lt;&lt; i</span>
        <span class="c1"># return m</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_bitmask_map</span><span class="p">[</span><span class="n">taxon</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_accession_index_map</span><span class="p">[</span><span class="n">taxon</span><span class="p">]</span>
            <span class="c1"># i = self._taxa.index(taxon)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_bitmask_map</span><span class="p">[</span><span class="n">taxon</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
            <span class="c1"># self._split_bitmask_taxon_map[m] = taxon</span>
            <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="TaxonNamespace.accession_index">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.accession_index">[docs]</a>
    <span class="k">def</span> <span class="nf">accession_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the accession index of ``taxon``. Note that this may not be the</span>
<span class="sd">        same as the list index of the taxon if taxa have been deleted from the</span>
<span class="sd">        namespace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taxon : |Taxon|</span>
<span class="sd">            |Taxon| object for which to return the accession index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : integer</span>
<span class="sd">            The accession index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taxon_accession_index_map</span><span class="p">[</span><span class="n">taxon</span><span class="p">]</span></div>


<div class="viewcode-block" id="TaxonNamespace.taxa_bitmask">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.taxa_bitmask">[docs]</a>
    <span class="k">def</span> <span class="nf">taxa_bitmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the list of split hash bitmask values representing all taxa</span>
<span class="sd">        specified by keyword-specified list of taxon objects (``taxa=``) or</span>
<span class="sd">        labels (``labels=``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            Requires one of:</span>

<span class="sd">                taxa : ``collections.Iterable`` [|Taxon|]</span>
<span class="sd">                    Iterable of |Taxon| objects.</span>
<span class="sd">                labels : ``collections.Iterable`` [string]</span>
<span class="sd">                    Iterable of |Taxon| label values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b : ``list`` [integer]</span>
<span class="sd">            List of split hash bitmask values for specified |Taxon|</span>
<span class="sd">            objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;taxa&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">taxa</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;taxa&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">taxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_taxa</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">bitmask</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="n">taxa</span><span class="p">:</span>
            <span class="n">bitmask</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_bitmask</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bitmask</span></div>


<div class="viewcode-block" id="TaxonNamespace.taxa_bipartition">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.taxa_bipartition">[docs]</a>
    <span class="k">def</span> <span class="nf">taxa_bipartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a bipartition that represents all taxa specified by</span>
<span class="sd">        keyword-specified list of taxon objects (``taxa=``) or labels</span>
<span class="sd">        (``labels=``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        \*\*kwargs : keyword arguments</span>
<span class="sd">            Requires one of:</span>

<span class="sd">                taxa : ``collections.Iterable`` [|Taxon|]</span>
<span class="sd">                    Iterable of |Taxon| objects.</span>
<span class="sd">                labels : ``collections.Iterable`` [string]</span>
<span class="sd">                    Iterable of |Taxon| label values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b : ``list`` [integer]</span>
<span class="sd">            List of split hash bitmask values for specified |Taxon|</span>
<span class="sd">            objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree_leafset_bitmask</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tree_leafset_bitmask&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tree_leafset_bitmask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tree_leafset_bitmask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_taxa_bitmask</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">dendropy.datamodel.treemodel</span> <span class="kn">import</span> <span class="n">Bipartition</span>
        <span class="n">bitmask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxa_bitmask</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Bipartition</span><span class="p">(</span>
                <span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">,</span>
                <span class="n">tree_leafset_bitmask</span><span class="o">=</span><span class="n">tree_leafset_bitmask</span><span class="p">,</span>
                <span class="n">compile_bipartition</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">is_rooted</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;is_rooted&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div>


<div class="viewcode-block" id="TaxonNamespace.get_taxa_bitmask">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.get_taxa_bitmask">[docs]</a>
    <span class="k">def</span> <span class="nf">get_taxa_bitmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LEGACY. Use &#39;taxa_bitmask&#39; instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxa_bitmask</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TaxonNamespace.bitmask_taxa_list">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.bitmask_taxa_list">[docs]</a>
    <span class="k">def</span> <span class="nf">bitmask_taxa_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bitmask</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of |Taxon| objects represented by split</span>
<span class="sd">        ``bitmask``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bitmask : integer</span>
<span class="sd">            Split hash bitmask value.</span>
<span class="sd">        index : integer, optional</span>
<span class="sd">            Start from this |Taxon| object instead of the first</span>
<span class="sd">            |Taxon| object in the collection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taxa : ``list`` [|Taxon|]</span>
<span class="sd">            List of |Taxon| objects specified or spanned by</span>
<span class="sd">            ``bitmask``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taxa</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">bitmask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bitmask</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_accession_index_taxon_map</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">bitmask</span> <span class="o">=</span> <span class="n">bitmask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">taxa</span></div>


<div class="viewcode-block" id="TaxonNamespace.bitmask_as_newick_string">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.bitmask_as_newick_string">[docs]</a>
    <span class="k">def</span> <span class="nf">bitmask_as_newick_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">bitmask</span><span class="p">,</span>
            <span class="n">preserve_spaces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">quote_underscores</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Represents a split as a newick string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bitmask : integer</span>
<span class="sd">            Split hash bitmask value.</span>
<span class="sd">        preserve_spaces : boolean, optional</span>
<span class="sd">            If |False| (default), then spaces in taxon labels will be replaced</span>
<span class="sd">            by underscores. If |True|, then taxon labels with spaces will be</span>
<span class="sd">            wrapped in quotes.</span>
<span class="sd">        quote_underscores : boolean, optional</span>
<span class="sd">            If |True| (default), then taxon labels with underscores will be</span>
<span class="sd">            wrapped in quotes. If |False|, then the labels will not be wrapped</span>
<span class="sd">            in quotes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : string</span>
<span class="sd">            NEWICK representation of split specified by ``bitmask``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">dendropy.dataio</span> <span class="kn">import</span> <span class="n">nexusprocessing</span>
        <span class="k">return</span> <span class="n">nexusprocessing</span><span class="o">.</span><span class="n">bitmask_as_newick_string</span><span class="p">(</span>
                <span class="n">bitmask</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">preserve_spaces</span><span class="o">=</span><span class="n">preserve_spaces</span><span class="p">,</span>
                <span class="n">quote_underscores</span><span class="o">=</span><span class="n">quote_underscores</span><span class="p">)</span></div>


<div class="viewcode-block" id="TaxonNamespace.split_as_newick_string">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.split_as_newick_string">[docs]</a>
    <span class="k">def</span> <span class="nf">split_as_newick_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">split</span><span class="p">,</span>
            <span class="n">preserve_spaces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">quote_underscores</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Represents a split as a newick string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bitmask : integer</span>
<span class="sd">            Split hash bitmask value.</span>
<span class="sd">        preserve_spaces : boolean, optional</span>
<span class="sd">            If |False| (default), then spaces in taxon labels will be replaced</span>
<span class="sd">            by underscores. If |True|, then taxon labels with spaces will be</span>
<span class="sd">            wrapped in quotes.</span>
<span class="sd">        quote_underscores : boolean, optional</span>
<span class="sd">            If |True| (default), then taxon labels with underscores will be</span>
<span class="sd">            wrapped in quotes. If |False|, then the labels will not be wrapped</span>
<span class="sd">            in quotes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : string</span>
<span class="sd">            NEWICK representation of split specified by ``bitmask``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask_as_newick_string</span><span class="p">(</span>
                <span class="n">bitmask</span><span class="o">=</span><span class="n">split</span><span class="p">,</span>
                <span class="n">preserve_spaces</span><span class="o">=</span><span class="n">preserve_spaces</span><span class="p">,</span>
                <span class="n">quote_underscores</span><span class="o">=</span><span class="n">quote_underscores</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">bitmask_as_bitstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bitprocessing</span><span class="o">.</span><span class="n">int_as_bitstring</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_accession_count</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">split_as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Deprecated since DendroPy 4: &#39;TaxonNamespace.split_as_string()&#39;; use &#39;TaxonNamespace.bitmask_as_bitstring()&#39; instead&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask_as_bitstring</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<div class="viewcode-block" id="TaxonNamespace.description">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.TaxonNamespace.description">[docs]</a>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">itemize</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns description of object, up to level ``depth``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="n">output_strio</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>
        <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">TaxonNamespace object at </span><span class="si">%s%s</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="o">*</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
                   <span class="n">itemize</span><span class="p">,</span>
                   <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span>
                   <span class="n">label</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;: </span><span class="si">%d</span><span class="s1"> Taxa&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">description</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="n">itemize</span><span class="o">=</span><span class="s2">&quot;[</span><span class="si">%d</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">output</span><span class="o">=</span><span class="n">output_strio</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">output_strio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>


    <span class="c1">### Partitioning</span>

    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TaxonNamespacePartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1">### I/O</span>

    <span class="k">def</span> <span class="nf">_format_and_write_to_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes out ``self`` in ``schema`` format to a destination given by</span>
<span class="sd">        file-like object ``stream``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : file or file-like object</span>
<span class="sd">            Destination for data.</span>
<span class="sd">        schema : string</span>
<span class="sd">            Must be a recognized and tree file schema, such as &quot;nexus&quot;,</span>
<span class="sd">            &quot;newick&quot;, etc, for which a specialized tree list writer is</span>
<span class="sd">            available. If this is not implemented for the schema specified, then</span>
<span class="sd">            a UnsupportedSchemaError is raised.</span>

<span class="sd">        \*\*kwargs : keyword arguments, optional</span>
<span class="sd">            Keyword arguments will be passed directly to the writer for the</span>
<span class="sd">            specified schema. See documentation for details on keyword</span>
<span class="sd">            arguments supported by writers of various schemas.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">dendropy</span> <span class="kn">import</span> <span class="n">dataio</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">dataio</span><span class="o">.</span><span class="n">get_writer</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">_write</span><span class="p">(</span>
                <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span>
                <span class="n">taxon_namespaces</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">],)</span></div>


<span class="c1">##############################################################################</span>
<span class="c1">## TaxonSet</span>

<span class="k">class</span> <span class="nc">TaxonSet</span><span class="p">(</span><span class="n">TaxonNamespace</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is present for (temporary!) legacy support of code written under</span>
<span class="sd">    DendroPy 3.x.  It will be removed in future versions. All new code should</span>
<span class="sd">    be written using |TaxonNamespace|. Old code needs to be updated to use</span>
<span class="sd">    |TaxonNamespace|.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">deprecate</span><span class="o">.</span><span class="n">dendropy_deprecation_warning</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Deprecated since DendroPy 4: &#39;TaxonSet&#39; will no longer be supported in future releases; use &#39;TaxonNamespace&#39; instead&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">TaxonNamespace</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="c1">##############################################################################</span>
<span class="c1">## Taxon</span>

<div class="viewcode-block" id="Taxon">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.Taxon">[docs]</a>
<span class="k">class</span> <span class="nc">Taxon</span><span class="p">(</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">Annotable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A taxon associated with a sequence or a node on a tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : string or |Taxon| object</span>
<span class="sd">            Label or name of this operational taxonomic unit concept. If a</span>
<span class="sd">            string, then the ``label`` attribute of ``self`` is set to this value.</span>
<span class="sd">            If a |Taxon| object, then the ``label`` attribute of ``self`` is</span>
<span class="sd">            set to the same value as the ``label`` attribute the other</span>
<span class="sd">            |Taxon| object and all annotations/metadata are copied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">Taxon</span><span class="p">):</span>
            <span class="n">other_taxon</span> <span class="o">=</span> <span class="n">label</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">other_taxon</span><span class="o">.</span><span class="n">label</span>
            <span class="n">memo</span><span class="o">=</span><span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">other_taxon</span><span class="p">):</span><span class="bp">self</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other_taxon</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">other_taxon</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deep_copy_annotations_from</span><span class="p">(</span><span class="n">other_taxon</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
            <span class="c1"># self.copy_annotations_from(other_taxon, attribute_object_mapper=memo)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lower_cased_label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_get_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>
    <span class="k">def</span> <span class="nf">_set_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lower_cased_label</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">label</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_label</span><span class="p">,</span> <span class="n">_set_label</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_lower_cased_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lower_cased_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lower_cased_label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lower_cased_label</span>
    <span class="n">lower_cased_label</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_lower_cased_label</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot shallow-copy Taxon&quot;</span><span class="p">)</span>
        <span class="c1"># return self</span>

<div class="viewcode-block" id="Taxon.taxon_namespace_scoped_copy">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.Taxon.taxon_namespace_scoped_copy">[docs]</a>
    <span class="k">def</span> <span class="nf">taxon_namespace_scoped_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># o = type(self).__new__(self.__class__)</span>
            <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">o</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;_annotations&quot;</span><span class="p">:</span>
                <span class="n">o</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">o</span><span class="o">.</span><span class="n">deep_copy_annotations_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="c1"># o.copy_annotations_from(self, attribute_object_mapper=memo)</span>
        <span class="k">return</span> <span class="n">o</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span>

<div class="viewcode-block" id="Taxon.__str__">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.Taxon.__str__">[docs]</a>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;String representation of self = taxon name.&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> &#39;</span><span class="si">{}</span><span class="s2">&#39;&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span>

<div class="viewcode-block" id="Taxon.description">
<a class="viewcode-back" href="../../../library/taxonmodel.html#dendropy.datamodel.taxonmodel.Taxon.description">[docs]</a>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">itemize</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns description of object, up to level ``depth``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="n">output_strio</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&lt;Unnamed Taxon&gt;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span>
        <span class="n">output_strio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1"> Taxon object at </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indent</span><span class="o">*</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">itemize</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="n">label</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">output_strio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>
</div>


<span class="c1">##############################################################################</span>
<span class="c1">## TaxonNamespacePartition</span>

<span class="k">class</span> <span class="nc">TaxonNamespacePartition</span><span class="p">(</span><span class="n">TaxonNamespaceAssociated</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manages a partition of a TaxonNamespace (i.e., a set of mutually-exclusive</span>
<span class="sd">    and exhaustive subsets of a TaxonNamespace).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon_namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __init__ uses one of the following keyword arguments:</span>

<span class="sd">            - ``membership_fn``</span>
<span class="sd">                A function that takes a |Taxon| object as an argument and</span>
<span class="sd">                returns a a population membership identifier or flag</span>
<span class="sd">                (e.g., a string, an integer) .</span>
<span class="sd">            - ``membership_attr_name``</span>
<span class="sd">                Name of an attribute of |Taxon| objects that serves as an</span>
<span class="sd">                identifier for subset membership.</span>
<span class="sd">            - ``membership_dict``</span>
<span class="sd">                A dictionary with |Taxon| objects as keys and population</span>
<span class="sd">                membership identifier or flag as values (e.g., a string,</span>
<span class="sd">                an integer).</span>
<span class="sd">            - ``membership_lists``</span>
<span class="sd">                A container of containers of |Taxon| objects, with every</span>
<span class="sd">                |Taxon| object in ``taxon_namespace`` represented once and only</span>
<span class="sd">                once in the sub-containers.</span>

<span class="sd">        If none of these are specified, defaults to a partition consisting of</span>
<span class="sd">        a single subset with all the objects in ``taxon_namespace``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">TaxonNamespaceAssociated</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">taxon_namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ss</span> <span class="o">=</span> <span class="n">TaxonNamespace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span> <span class="o">=</span> <span class="p">{</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="o">.</span><span class="n">label</span> <span class="p">:</span> <span class="n">ss</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">subsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return subsets of partition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of subsets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over subsets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">v</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get subset with specified label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds the subsets of the linked TaxonNamespace resulting from the</span>
<span class="sd">        partitioning scheme specified by one of the following keyword arguments:</span>

<span class="sd">            ``membership_fn``</span>
<span class="sd">                A function that takes a |Taxon| object as an argument and</span>
<span class="sd">                returns a a population membership identifier or flag</span>
<span class="sd">                (e.g., a string, an integer).</span>

<span class="sd">            ``membership_attr_name``</span>
<span class="sd">                Name of an attribute of |Taxon| objects that serves as an</span>
<span class="sd">                identifier for subset membership.</span>

<span class="sd">            ``membership_dict``</span>
<span class="sd">                A dictionary with |Taxon| objects as keys and population</span>
<span class="sd">                membership identifier or flag as values (e.g., a string,</span>
<span class="sd">                an integer).</span>

<span class="sd">            ``membership_lists``</span>
<span class="sd">                A container of containers of |Taxon| objects, with every</span>
<span class="sd">                |Taxon| object in ``taxon_namespace`` represented once and only</span>
<span class="sd">                once in the sub-containers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;membership_fn&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s2">&quot;membership_func&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;membership_fn&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;membership_func&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;membership_func&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;membership_fn&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_membership_fn</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;membership_fn&quot;</span><span class="p">])</span>
        <span class="k">elif</span>  <span class="s2">&quot;membership_attr_name&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_membership_attr_name</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;membership_attr_name&quot;</span><span class="p">])</span>
        <span class="k">elif</span>  <span class="s2">&quot;membership_dict&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_membership_dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;membership_dict&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="s2">&quot;membership_lists&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_membership_lists</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;membership_lists&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must specify partitioning scheme using one of: &quot;</span> \
                <span class="o">+</span> <span class="s2">&quot;&#39;membership_fn&#39;, &#39;membership_dict&#39;, or &#39;membership_lists&#39;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_membership_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mfunc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs subsets based on function ``mfunc``, which should take a</span>
<span class="sd">        |Taxon| object as an argument and return a population membership</span>
<span class="sd">        identifier or flag (e.g., a string, an integer).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">:</span>
            <span class="n">subset_id</span> <span class="o">=</span> <span class="n">mfunc</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subset_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span><span class="p">[</span><span class="n">subset_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">TaxonNamespace</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">subset_id</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span><span class="p">[</span><span class="n">subset_id</span><span class="p">]</span><span class="o">.</span><span class="n">add_taxon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsets</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">apply_membership_attr_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs subsets based on attribute ``attr_name`` of each</span>
<span class="sd">        |Taxon| object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_membership_fn</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">apply_membership_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mdict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs subsets based on dictionary ``mdict``, which should be</span>
<span class="sd">        dictionary with |Taxon| objects as keys and population membership</span>
<span class="sd">        identifier or flag as values (e.g., a string, an integer).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_membership_fn</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">mdict</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">apply_membership_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mlists</span><span class="p">,</span> <span class="n">subset_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs subsets based on list ``mlists``, which should be an interable</span>
<span class="sd">        of iterables of |Taxon| objects, with every |Taxon| object in</span>
<span class="sd">        ``taxon_namespace`` represented once and only once in the sub-containers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subset_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mlists</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of subset label list must equal to number of subsets&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subset_labels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mlists</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">mlist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mlists</span><span class="p">):</span>
            <span class="n">subset_id</span> <span class="o">=</span> <span class="n">subset_labels</span><span class="p">[</span><span class="n">lidx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span><span class="p">[</span><span class="n">subset_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">TaxonNamespace</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">subset_id</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mlist</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subset_map</span><span class="p">[</span><span class="n">subset_id</span><span class="p">]</span><span class="o">.</span><span class="n">add_taxon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsets</span><span class="p">()</span>

<span class="c1">##############################################################################</span>
<span class="c1">## TaxonNamespaceMapping</span>

<span class="k">class</span> <span class="nc">TaxonNamespaceMapping</span><span class="p">(</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="p">,</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">Annotable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A many-to-one mapping of |Taxon| objects (e.g., gene taxa to population/species taxa).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_contained_taxon_mapping</span><span class="p">(</span><span class="n">containing_taxon_namespace</span><span class="p">,</span>
            <span class="n">num_contained</span><span class="p">,</span>
            <span class="n">contained_taxon_label_prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">contained_taxon_label_separator</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
            <span class="n">contained_taxon_label_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns a TaxonNamespaceMapping object that maps multiple</span>
<span class="sd">        &quot;contained&quot; Taxon objects (e.g., genes) to Taxon objects in</span>
<span class="sd">        ``containing_taxon_namespace`` (e.g., populations or species).</span>

<span class="sd">            ``containing_taxon_namespace``</span>
<span class="sd">                A TaxonNamespace object that defines a Taxon for each population or</span>
<span class="sd">                species.</span>

<span class="sd">            ``num_contained``</span>
<span class="sd">                The number of genes per population of species. The value of</span>
<span class="sd">                this attribute can be a scalar integer, in which case each</span>
<span class="sd">                species or population taxon will get the same fixed number</span>
<span class="sd">                of genes. Or it can be a list, in which case the list has</span>
<span class="sd">                to have as many elements as there are members in</span>
<span class="sd">                ``containing_taxon_namespace``, and each element will specify the</span>
<span class="sd">                number of genes that the corresponding species or population</span>
<span class="sd">                Taxon will get.</span>

<span class="sd">            ``contained_taxon_label_prefix``</span>
<span class="sd">                If specified, then each gene Taxon label will begin with this.</span>
<span class="sd">                Otherwise, each gene Taxon label will begin with the same label</span>
<span class="sd">                as its corresponding species/population taxon label.</span>

<span class="sd">            ``contained_taxon_label_separator``</span>
<span class="sd">                String used to separate gene Taxon label prefix from its index.</span>

<span class="sd">            ``contained_taxon_label_fn``</span>
<span class="sd">                If specified, should be a function that takes two arguments: a</span>
<span class="sd">                Taxon object from ``containing_taxon_namespace`` and an integer</span>
<span class="sd">                specifying the contained gene index. It should return a string</span>
<span class="sd">                which will be used as the label for the corresponding gene</span>
<span class="sd">                taxon. If not None, this will bypass the</span>
<span class="sd">                ``contained_taxon_label_prefix`` and</span>
<span class="sd">                ``contained_taxon_label_separator`` arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_contained</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">_num_contained</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_contained</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">containing_taxon_namespace</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_num_contained</span> <span class="o">=</span> <span class="n">num_contained</span>
        <span class="n">contained_to_containing</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">contained_taxa</span> <span class="o">=</span> <span class="n">TaxonNamespace</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cidx</span><span class="p">,</span> <span class="n">containing_taxon</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">containing_taxon_namespace</span><span class="p">):</span>
            <span class="n">num_new</span> <span class="o">=</span> <span class="n">_num_contained</span><span class="p">[</span><span class="n">cidx</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">new_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_new</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">contained_taxon_label_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">contained_taxon_label_fn</span><span class="p">(</span><span class="n">containing_taxon</span><span class="p">,</span>
                            <span class="n">new_idx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s%s%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">containing_taxon</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                            <span class="n">contained_taxon_label_separator</span><span class="p">,</span>
                            <span class="n">new_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">contained_taxon</span> <span class="o">=</span> <span class="n">Taxon</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
                <span class="n">contained_to_containing</span><span class="p">[</span><span class="n">contained_taxon</span><span class="p">]</span> <span class="o">=</span> <span class="n">containing_taxon</span>
                <span class="n">contained_taxa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contained_taxon</span><span class="p">)</span>
        <span class="n">contained_to_containing_map</span> <span class="o">=</span> <span class="n">TaxonNamespaceMapping</span><span class="p">(</span><span class="n">domain_taxon_namespace</span><span class="o">=</span><span class="n">contained_taxa</span><span class="p">,</span>
                <span class="n">range_taxon_namespace</span><span class="o">=</span><span class="n">containing_taxon_namespace</span><span class="p">,</span>
                <span class="n">mapping_dict</span><span class="o">=</span><span class="n">contained_to_containing</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">contained_to_containing_map</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __init__ uses one of the following keyword arguments:</span>

<span class="sd">            - ``mapping_fn``</span>
<span class="sd">                A function that takes a |Taxon| object from the domain taxa</span>
<span class="sd">                as an argument and returns the corresponding |Taxon| object</span>
<span class="sd">                from the range taxa. If this argument is given, then a</span>
<span class="sd">                |TaxonNamespace| or some other container of |Taxon| objects needs</span>
<span class="sd">                to be passed using the ``taxon_namespace`` argument.</span>
<span class="sd">            - ``mapping_attr_name``</span>
<span class="sd">                Name of an attribute of |Taxon| object of the domain taxa</span>
<span class="sd">                that references the corresponding |Taxon| object from the</span>
<span class="sd">                range taxa. If this argument is given, then a |TaxonNamespace| or</span>
<span class="sd">                some other container of |Taxon| objects needs to be passed</span>
<span class="sd">                using the ``taxon_namespace`` argument.</span>
<span class="sd">            - ``mapping_dict``</span>
<span class="sd">                A dictionary with |Taxon| objects from the domain taxa as</span>
<span class="sd">                keys, and the corresponding |Taxon| object from the range</span>
<span class="sd">                taxa as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basemodel</span><span class="o">.</span><span class="n">DataObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forward</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s2">&quot;mapping_fn&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;domain_taxon_namespace&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must specify &#39;domain_taxon_namespace&#39;&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_mapping_fn</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;mapping_fn&quot;</span><span class="p">],</span>
                    <span class="n">domain_taxon_namespace</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;domain_taxon_namespace&quot;</span><span class="p">],</span>
                    <span class="n">range_taxon_namespace</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;range_taxon_namespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">elif</span> <span class="s2">&quot;mapping_attr_name&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;domain_taxon_namespace&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must specify &#39;domain_taxon_namespace&#39;&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_mapping_attr_name</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;mapping_attr_name&quot;</span><span class="p">],</span>
                    <span class="n">domain_taxon_namespace</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;domain_taxon_namespace&quot;</span><span class="p">],</span>
                    <span class="n">range_taxon_namespace</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;range_taxon_namespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">elif</span> <span class="s2">&quot;mapping_dict&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_mapping_dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;mapping_dict&quot;</span><span class="p">],</span>
                    <span class="n">domain_taxon_namespace</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;domain_taxon_namespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="n">range_taxon_namespace</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;range_taxon_namespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must specify at least one of: &#39;mapping_fn&#39;, &#39;mapping_attr_name&#39;, or &#39;mapping_dict&#39;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of subsets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over subsets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">k</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get mapping for specified taxon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">[</span><span class="n">taxon</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_domain_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain_taxon_namespace</span>

    <span class="k">def</span> <span class="nf">_set_domain_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxa</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">taxa</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">taxa</span><span class="p">,</span> <span class="n">TaxonNamespace</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_domain_taxon_namespace</span> <span class="o">=</span> <span class="n">TaxonNamespace</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_domain_taxon_namespace</span> <span class="o">=</span> <span class="n">taxa</span>

    <span class="n">domain_taxon_namespace</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_domain_taxon_namespace</span><span class="p">,</span> <span class="n">_set_domain_taxon_namespace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_range_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_taxon_namespace</span>

    <span class="k">def</span> <span class="nf">_set_range_taxon_namespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taxa</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">taxa</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">taxa</span><span class="p">,</span> <span class="n">TaxonNamespace</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_range_taxon_namespace</span> <span class="o">=</span> <span class="n">TaxonNamespace</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_range_taxon_namespace</span> <span class="o">=</span> <span class="n">taxa</span>

    <span class="n">range_taxon_namespace</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_range_taxon_namespace</span><span class="p">,</span> <span class="n">_set_range_taxon_namespace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_mapping_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mfunc</span><span class="p">,</span> <span class="n">domain_taxon_namespace</span><span class="p">,</span> <span class="n">range_taxon_namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs forward and reverse mapping dictionaries based on ``mfunc``,</span>
<span class="sd">        which should take a |Taxon| object in ``domain_taxon_namespace`` as an argument</span>
<span class="sd">        and return another |Taxon| object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forward</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain_taxon_namespace</span> <span class="o">=</span> <span class="n">domain_taxon_namespace</span>
        <span class="k">if</span> <span class="n">range_taxon_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">range_taxon_namespace</span> <span class="o">=</span> <span class="n">TaxonNamespace</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">range_taxon_namespace</span> <span class="o">=</span> <span class="n">range_taxon_namespace</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_taxon_namespace</span><span class="p">:</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">mfunc</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_taxon_namespace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">range_taxon_namespace</span><span class="o">.</span><span class="n">add_taxon</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">[</span><span class="n">dt</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">dt</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">apply_mapping_attr_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">domain_taxon_namespace</span><span class="p">,</span> <span class="n">range_taxon_namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs mapping based on attribute ``attr_name`` of each</span>
<span class="sd">        |Taxon| object in ``domain_taxon_namespace``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mapping_fn</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">),</span> <span class="n">domain_taxon_namespace</span><span class="o">=</span><span class="n">domain_taxon_namespace</span><span class="p">,</span> <span class="n">range_taxon_namespace</span><span class="o">=</span><span class="n">range_taxon_namespace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_mapping_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mdict</span><span class="p">,</span> <span class="n">domain_taxon_namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">range_taxon_namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs mapping based on dictionary ``mdict``, which should have</span>
<span class="sd">        domain taxa as keys and range taxa as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">domain_taxon_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domain_taxon_namespace</span> <span class="o">=</span> <span class="n">TaxonNamespace</span><span class="p">(</span><span class="n">mdict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mapping_fn</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">mdict</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">domain_taxon_namespace</span><span class="o">=</span><span class="n">domain_taxon_namespace</span><span class="p">,</span> <span class="n">range_taxon_namespace</span><span class="o">=</span><span class="n">range_taxon_namespace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mesquite_association_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">dendropy.dataio</span> <span class="kn">import</span> <span class="n">nexusprocessing</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">nexusprocessing</span><span class="o">.</span><span class="n">escape_nexus_token</span><span class="p">(</span><span class="n">rt</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="n">dt_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">dt</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">[</span><span class="n">rt</span><span class="p">]]</span>
            <span class="n">dt_labels</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">nexusprocessing</span><span class="o">.</span><span class="n">escape_nexus_token</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dt_labels</span><span class="p">])</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;        </span><span class="si">%s</span><span class="s2"> / </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_mesquite_association_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">domain_taxon_namespace_title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">range_taxon_namespace_title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For debugging purposes ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_compose_title</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">label</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;d</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="kn">from</span> <span class="nn">dendropy.dataio</span> <span class="kn">import</span> <span class="n">nexusprocessing</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;BEGIN TaxaAssociation;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_compose_title</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;    TITLE </span><span class="si">%s</span><span class="s2">;</span><span class="se">\n</span><span class="s2">&quot;</span>  <span class="o">%</span> <span class="n">nexusprocessing</span><span class="o">.</span><span class="n">escape_nexus_token</span><span class="p">(</span><span class="n">title</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">domain_taxon_namespace_title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domain_taxon_namespace_title</span> <span class="o">=</span> <span class="n">_compose_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_taxon_namespace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">range_taxon_namespace_title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">range_taxon_namespace_title</span> <span class="o">=</span> <span class="n">_compose_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_taxon_namespace</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;    TAXA </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">nexusprocessing</span><span class="o">.</span><span class="n">escape_nexus_token</span><span class="p">(</span><span class="n">range_taxon_namespace_title</span><span class="p">),</span>
            <span class="n">nexusprocessing</span><span class="o">.</span><span class="n">escape_nexus_token</span><span class="p">(</span><span class="n">domain_taxon_namespace_title</span><span class="p">)</span>
            <span class="p">))</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;    ASSOCIATES</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesquite_association_rows</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;    ;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;END;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div style="text-align: center; padding-top: 20px; padding-bottom: 5px; width: 100%;">
    <a href="../../../index.html"><img src="../../../_static/dendropy_logo.png" /></a>
</div><div style="clear:both; width: 100%; height:1px;"></div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div>
    <!-- Documentation -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Documentation</h3>
        <ul>
            <li><a href="../../../primer/downloading.html">Downloading and Installing DendroPy</a></li>
            <li><a href="../../../primer/index.html">The DendroPy Primer</a></li>
            <li><a href="../../../library/index.html">Library API Reference</a></li>
            <li>
                <a href="../../../schemas/index.html">Schemas</a>
                <ul>
                    <li><a href="../../../schemas/fasta.html">FASTA</a></li>
                    <li><a href="../../../schemas/newick.html">Newick</a></li>
                    <li><a href="../../../schemas/nexml.html">NeXML</a></li>
                    <li><a href="../../../schemas/nexus.html">Nexus</a></li>
                    <li><a href="../../../schemas/phylip.html">PHYLIP</a></li>
                </ul>
            </li>
            <li>
                <a href="../../../programs/index.html">Programs</a>
                <ul>
                    <li><a href="../../../programs/sumtrees.html">SumTrees</a></li>
                </ul>
            </li>
            <li><a href="../../../glossary.html">Glossary and Terminological Reference</a></li>
            <li><a href="../../../developer.html">Developer Guide</a></li>
            <li><a href="../../../planning.html">Ongoing Development</a></li>
            <li><a href="../../../changes.html">Change History</a></li>
        </ul>
    </div>

    <!-- Downloads -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Obtaining</h3>
        <ul>
            <li><a target="_blank" href="http://pypi.python.org/pypi/DendroPy">Install from the Python Package Index</a></li>
            <li><a target="_blank" href="http://pypi.python.org/packages/source/D/DendroPy/DendroPy-5.0.2.tar.gz">Download the Source Code Archive</a></li>
            <li><a target="_blank" href="http://github.com/jeetsukumaran/DendroPy">Clone the Source Code Repository</a></li>
        </ul>
    </div>

    <!-- Discussions -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Discussion</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot; DendroPy Users&quot; </a>group to follow and participate in discussion, troubleshooting, help, information, suggestions, etc. on the usage and development of the DendroPy phylogenetic computing library.</p>
            <form action="http://groups.google.com/group/dendropy-users/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot;dendropy-users&quot;</a> group, or click <a href="http://groups.google.com/group/dendropy-users?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Announcements -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Announcements</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; DendroPy Announcements&quot; </a>group to receive announcements of new releases, updates, changes and other news of interest to DendroPy users and developers.</p>
            <form action="http://groups.google.com/group/dendropy-announce/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; dendropy-announce&quot; </a>group, or click <a href="http://groups.google.com/group/dendropy-announce?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Development -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative; padding-bottom: 15px; margin-bottom:5px;">
        <h3><span style="text-align: left"><a href="https://github.com/jeetsukumaran/DendroPy/">Development</a></span><a href="https://github.com/jeetsukumaran/DendroPy/"><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/Octocat.png" height="30px" alt="GitHub" /></span></a></h3>
        <div style="margin-top: 15px;">
            <!-- <a href="https://github.com/jeetsukumaran/DendroPy/issues">Issues</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/subscription">Watch</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/fork">Fork</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/stargazers">Star</a> &bull; <a href="https://github.com/jeetsukumaran/">Follow</a> -->
            <ul>
                <li>                <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/issues"><code>Issues</code></a></span> <span style="font-style: italic; font-size:80%;"> - Report bugs or request features</span></li>
                <li>     <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/subscription"><code>&nbsp;Watch</code></a></span> <span style="font-style: italic; font-size:80%;"> - Follow development activity</span></li>
                <li>        <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/fork"><code>&nbsp;&nbsp;Fork</code></a></span> <span style="font-style: italic; font-size:80%;"> - Contribute and collaborate</span></li>
                <li>  <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/stargazers"><code>&nbsp;&nbsp;Star</code></a></span> <span style="font-style: italic; font-size:80%;"> - Throw some glitter, add some glamour</span></li>
        </div>
    </div>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DendroPy 5.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.datamodel.taxonmodel</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2009-2025, Jeet Sukumaran and Mark T. Holder.
    </div>
  </body>
</html>