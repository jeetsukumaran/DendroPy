<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dendropy.model.coalescent &#8212; DendroPy 5.0.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/rtd.css?v=cedc6a2f" />
    
    <script src="../../../_static/documentation_options.js?v=f98c4cc8"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DendroPy 5.0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.model.coalescent</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for dendropy.model.coalescent</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1">##############################################################################</span>
<span class="c1">##  DendroPy Phylogenetic Computing Library.</span>
<span class="c1">##</span>
<span class="c1">##  Copyright 2010-2015 Jeet Sukumaran and Mark T. Holder.</span>
<span class="c1">##  All rights reserved.</span>
<span class="c1">##</span>
<span class="c1">##  See &quot;LICENSE.rst&quot; for terms and conditions of usage.</span>
<span class="c1">##</span>
<span class="c1">##  If you use this work or any portion thereof in published work,</span>
<span class="c1">##  please cite it as:</span>
<span class="c1">##</span>
<span class="c1">##     Sukumaran, J. and M. T. Holder. 2010. DendroPy: a Python library</span>
<span class="c1">##     for phylogenetic computing. Bioinformatics 26: 1569-1571.</span>
<span class="c1">##</span>
<span class="c1">##############################################################################</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions, classes, and methods for working with Kingman&#39;s n-coalescent</span>
<span class="sd">framework.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">dendropy</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">GLOBAL_RNG</span>
<span class="kn">from</span> <span class="nn">dendropy.utility</span> <span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">probability</span>
<span class="kn">from</span> <span class="nn">dendropy.calculate</span> <span class="kn">import</span> <span class="n">combinatorics</span>
<span class="kn">from</span> <span class="nn">dendropy.utility.error</span> <span class="kn">import</span> <span class="n">ProcessFailedException</span>

<span class="c1">###############################################################################</span>
<span class="c1">## Calculations and statistics</span>


<div class="viewcode-block" id="discrete_time_to_coalescence">
<a class="viewcode-back" href="../../../library/coalescent.html#dendropy.model.coalescent.discrete_time_to_coalescence">[docs]</a>
<span class="k">def</span> <span class="nf">discrete_time_to_coalescence</span><span class="p">(</span><span class="n">n_genes</span><span class="p">,</span> <span class="n">pop_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_to_coalesce</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A random draw from the &quot;Kingman distribution&quot; (discrete time version): Time</span>
<span class="sd">    to go from ``n_genes`` genes to ``n_genes``-1 genes in a discrete-time</span>
<span class="sd">    Wright-Fisher population of ``pop_size`` genes; i.e. waiting time until</span>
<span class="sd">    ``n-genes`` lineages coalesce in a population of ``pop_size`` genes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    n_genes : integer</span>
<span class="sd">        The number of genes in the sample. Must be greater than or equal to n_to_coalesce.</span>
<span class="sd">    pop_size : integer</span>
<span class="sd">        The effective *haploid* population size; i.e., number of genes in the</span>
<span class="sd">        population: 2 * N in a diploid population of N individuals, or N in a</span>
<span class="sd">        haploid population of N individuals.</span>
<span class="sd">    n_to_coalesce : integer</span>
<span class="sd">        The waiting time that will be returned will be the waiting time for</span>
<span class="sd">        this number of genes in the sample to coalesce.</span>
<span class="sd">    rng : ``Random`` object</span>
<span class="sd">        The random number generator instance.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    k : integer</span>
<span class="sd">        A randomly-generated waiting time (in discrete generations) for</span>
<span class="sd">        ``n_to_coalesce`` genes to coalesce out of a sample of ``n_genes`` in a</span>
<span class="sd">        population of ``pop_size`` genes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pop_size</span><span class="p">:</span>
        <span class="n">time_units</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">time_units</span> <span class="o">=</span> <span class="n">pop_size</span>
    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">pop_size</span> <span class="o">/</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">n_genes</span><span class="p">,</span> <span class="n">n_to_coalesce</span><span class="p">)</span>
    <span class="n">tmrca</span> <span class="o">=</span> <span class="n">probability</span><span class="o">.</span><span class="n">geometric_rv</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tmrca</span> <span class="o">*</span> <span class="n">time_units</span></div>



<div class="viewcode-block" id="time_to_coalescence">
<a class="viewcode-back" href="../../../library/coalescent.html#dendropy.model.coalescent.time_to_coalescence">[docs]</a>
<span class="k">def</span> <span class="nf">time_to_coalescence</span><span class="p">(</span><span class="n">n_genes</span><span class="p">,</span> <span class="n">pop_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_to_coalesce</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A random draw from the &quot;Kingman distribution&quot; (discrete time version): Time</span>
<span class="sd">    to go from ``n_genes`` genes to ``n_genes``-1 genes in a continuous-time</span>
<span class="sd">    Wright-Fisher population of ``pop_size`` genes; i.e. waiting time until</span>
<span class="sd">    ``n-genes`` lineages coalesce in a population of ``pop_size`` genes.</span>

<span class="sd">    Given the number of gene lineages in a sample, ``n_genes``, and a</span>
<span class="sd">    population size, ``pop_size``, this function returns a random number from</span>
<span class="sd">    an exponential distribution with rate :math:`\choose(``pop_size``, 2)`.</span>
<span class="sd">    ``pop_size`` is the effective *haploid* population size; i.e., number of gene</span>
<span class="sd">    in the population: 2 * N in a diploid population of N individuals,</span>
<span class="sd">    or N in a haploid population of N individuals. If ``pop_size`` is 1 or 0 or</span>
<span class="sd">    None, then time is in haploid population units; i.e. where 1 unit of time</span>
<span class="sd">    equals 2N generations for a diploid population of size N, or N generations</span>
<span class="sd">    for a haploid population of size N. Otherwise time is in generations.</span>

<span class="sd">    The coalescence time, or the waiting time for the coalescence, of two</span>
<span class="sd">    gene lineages evolving in a population with haploid size :math:`N` is an</span>
<span class="sd">    exponentially-distributed random variable with rate of :math:`N` an</span>
<span class="sd">    expectation of :math:`\frac{1}{N}`).</span>
<span class="sd">    The waiting time for coalescence of *any* two gene lineages in a sample of</span>
<span class="sd">    :math:`n` gene lineages evolving in a population with haploid size :math:`N` is an</span>
<span class="sd">    exponentially-distributed random variable with rate of :math:`\choose{N, 2} and</span>
<span class="sd">    an expectation of :math:`\frac{1}{\choose{N, 2}}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_genes : integer</span>
<span class="sd">        The number of genes in the sample.</span>
<span class="sd">    pop_size : integer</span>
<span class="sd">        The effective *haploid* population size; i.e., number of genes in the</span>
<span class="sd">        population: 2 * N in a diploid population of N individuals, or N in a</span>
<span class="sd">        haploid population of N individuals.</span>
<span class="sd">    n_to_coalesce : integer</span>
<span class="sd">        The waiting time that will be returned will be the waiting time for</span>
<span class="sd">        this number of genes in the sample to coalesce.</span>
<span class="sd">    rng : ``Random`` object</span>
<span class="sd">        The random number generator instance to use.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    k : float</span>
<span class="sd">        A randomly-generated waiting time (in continuous time) for</span>
<span class="sd">        ``n_to_coalesce`` genes to coalesce out of a sample of ``n_genes`` in a</span>
<span class="sd">        population of ``pop_size`` genes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pop_size</span><span class="p">:</span>
        <span class="n">time_units</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">time_units</span> <span class="o">=</span> <span class="n">pop_size</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">n_genes</span><span class="p">,</span> <span class="n">n_to_coalesce</span><span class="p">)</span>
    <span class="n">tmrca</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tmrca</span> <span class="o">*</span> <span class="n">time_units</span></div>



<div class="viewcode-block" id="expected_tmrca">
<a class="viewcode-back" href="../../../library/coalescent.html#dendropy.model.coalescent.expected_tmrca">[docs]</a>
<span class="k">def</span> <span class="nf">expected_tmrca</span><span class="p">(</span><span class="n">n_genes</span><span class="p">,</span> <span class="n">pop_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_to_coalesce</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expected (mean) value for the Time to the Most Recent Common Ancestor of</span>
<span class="sd">    ``n_to_coalesce`` genes in a sample of ``n_genes`` drawn from a population of</span>
<span class="sd">    ``pop_size`` genes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_genes : integer</span>
<span class="sd">        The number of genes in the sample.</span>
<span class="sd">    pop_size : integer</span>
<span class="sd">        The effective *haploid* population size; i.e., number of genes in the</span>
<span class="sd">        population: 2 * N in a diploid population of N individuals, or N in a</span>
<span class="sd">        haploid population of N individuals.</span>
<span class="sd">    n_to_coalesce : integer</span>
<span class="sd">        The waiting time that will be returned will be the waiting time for</span>
<span class="sd">        this number of genes in the sample to coalesce.</span>
<span class="sd">    rng : ``Random`` object</span>
<span class="sd">        The random number generator instance.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    k : float</span>
<span class="sd">        The expected waiting time (in continuous time) for ``n_to_coalesce``</span>
<span class="sd">        genes to coalesce out of a sample of ``n_genes`` in a population of</span>
<span class="sd">        ``pop_size`` genes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nc2</span> <span class="o">=</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">n_genes</span><span class="p">,</span> <span class="n">n_to_coalesce</span><span class="p">)</span>
    <span class="n">tmrca</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nc2</span>
    <span class="k">if</span> <span class="n">pop_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tmrca</span> <span class="o">*</span> <span class="n">pop_size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tmrca</span></div>



<div class="viewcode-block" id="coalesce_nodes">
<a class="viewcode-back" href="../../../library/coalescent.html#dendropy.model.coalescent.coalesce_nodes">[docs]</a>
<span class="k">def</span> <span class="nf">coalesce_nodes</span><span class="p">(</span>
    <span class="n">nodes</span><span class="p">,</span> <span class="n">pop_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_expected_tmrca</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of nodes that have not yet coalesced once ``period`` is</span>
<span class="sd">    exhausted.</span>

<span class="sd">    This function will a draw a coalescence time, ``t``, from an exponential</span>
<span class="sd">    distribution with a rate of ``choose(k, 2)``, where ``k`` is the number of</span>
<span class="sd">    nodes. If ``period`` is given and if this time is less than ``period``, or if</span>
<span class="sd">    ``period`` is not given, then two nodes are selected at random from ``nodes``,</span>
<span class="sd">    and coalesced: a new node is created, and the two nodes are added as</span>
<span class="sd">    child_nodes to this node with an edge length such the the total length from</span>
<span class="sd">    tip to the ancestral node is equal to the depth of the deepest child + ``t``.</span>
<span class="sd">    The two nodes are removed from the list of nodes, and the new node is added</span>
<span class="sd">    to it. ``t`` is then deducted from ``period``, and the process repeats.</span>

<span class="sd">    The function ends and returns the list of nodes once ``period`` is</span>
<span class="sd">    exhausted or if any draw of ``t`` exceeds ``period``, if ``period`` is</span>
<span class="sd">    given or when there is only one node left.</span>

<span class="sd">    As each coalescent event occurs, *all* nodes have their edges</span>
<span class="sd">    extended to the point of the coalescent event. In the case of</span>
<span class="sd">    constrained coalescence, all uncoalesced nodes have their edges</span>
<span class="sd">    extended to the end of the period (coalesced nodes have the edges</span>
<span class="sd">    fixed by the coalescent event in their ancestor).  Thus multiple</span>
<span class="sd">    calls to this method with the same set of nodes will gradually</span>
<span class="sd">    &#39;grow&#39; the edges, until all the the nodes coalesce. The edge</span>
<span class="sd">    lengths of the nodes passed to this method thus should not be</span>
<span class="sd">    modified or reset until the process is complete.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nodes : iterable[|Node|]</span>
<span class="sd">        An interable of |Node| objects representing a sample of neutral</span>
<span class="sd">        genes (some, all, or none of these nodes may have descendent nodes).</span>
<span class="sd">    pop_size : integer</span>
<span class="sd">        The effective *haploid* population size; i.e., number of genes in the</span>
<span class="sd">        population: 2 * N in a diploid population of N individuals, or N in a</span>
<span class="sd">        haploid population of N individuals.</span>
<span class="sd">    period : numeric</span>
<span class="sd">        The time that the genes have to coalesce. If ``pop_size`` is 1 or 0 or</span>
<span class="sd">        None, then time is in haploid population units; i.e. where 1 unit of</span>
<span class="sd">        time equals 2N generations for a diploid population of size N, or N</span>
<span class="sd">        generations for a haploid population of size N. Otherwise time is in</span>
<span class="sd">        generations.</span>
<span class="sd">    rng : ``Random`` object</span>
<span class="sd">        The random number generator instance to use. If not specified, the</span>
<span class="sd">        default RNG will be used.</span>
<span class="sd">    use_expected_tmrca : bool</span>
<span class="sd">        If |True|, then instead of random times, the *expected* times will be</span>
<span class="sd">        used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nodes : iterable[|Node|]</span>
<span class="sd">        A list of nodes once ``period`` is exhausted or if any draw of ``t``</span>
<span class="sd">        exceeds ``period``, if ``period`` is given or when there is only one node</span>
<span class="sd">        left.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># idiot-check, because I can be an idiot</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># set the random number generator</span>
    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>

    <span class="c1"># define the function needed to create new coalescence nodes</span>
    <span class="n">new_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span>

    <span class="c1"># make a shallow copy of the node list</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

    <span class="c1"># start tracking the time remaining</span>
    <span class="n">time_remaining</span> <span class="o">=</span> <span class="n">period</span>

    <span class="c1"># If there is no time constraint, we want to continue coalescing</span>
    <span class="c1"># until there is only one gene left in the pool. If there is a</span>
    <span class="c1"># time constraint, we continue as long as there is time remaining,</span>
    <span class="c1"># but we do not control for that here: it is automatically taken</span>
    <span class="c1"># care of when the time drawn for the next coalescent event</span>
    <span class="c1"># exceeds the time remaining, and triggers a break from the loop</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">use_expected_tmrca</span><span class="p">:</span>
            <span class="n">tmrca</span> <span class="o">=</span> <span class="n">expected_tmrca</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">pop_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># draw a time to coalesce: this will be an exponential random</span>
            <span class="c1"># variable with parameter (rate) of BINOMIAL[n_genes 2]</span>
            <span class="c1"># multiplied pop_size</span>
            <span class="n">tmrca</span> <span class="o">=</span> <span class="n">time_to_coalescence</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">pop_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>

        <span class="c1"># if no time_remaining is given (i.e, we want to coalesce till</span>
        <span class="c1"># there is only one gene left) or, if we are working under the</span>
        <span class="c1"># constrained coalescent, if the time to the next coalescence</span>
        <span class="c1"># event is not longer than the time_remaining</span>
        <span class="k">if</span> <span class="n">time_remaining</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">tmrca</span> <span class="o">&lt;=</span> <span class="n">time_remaining</span><span class="p">:</span>

            <span class="c1"># stretch out the edges of all the nodes to this time</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">tmrca</span>

            <span class="c1"># pick two nodes to coalesce at random</span>
            <span class="n">to_coalesce</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># create the new ancestor of these nodes</span>
            <span class="n">new_ancestor</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">()</span>

            <span class="c1"># add the nodes as child nodes of the new node, their</span>
            <span class="c1"># common ancestor, and set the ancestor&#39;s edge length</span>
            <span class="n">new_ancestor</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">to_coalesce</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">new_ancestor</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">to_coalesce</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">new_ancestor</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># remove the nodes that have coalesced from the pool of</span>
            <span class="c1"># nodes</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">to_coalesce</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">to_coalesce</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># add the ancestor to the pool of nodes</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_ancestor</span><span class="p">)</span>

            <span class="c1"># adjust the time_remaining left to coalesce</span>
            <span class="k">if</span> <span class="n">time_remaining</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">time_remaining</span> <span class="o">=</span> <span class="n">time_remaining</span> <span class="o">-</span> <span class="n">tmrca</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the next coalescent event takes place after the period constraint</span>
            <span class="k">break</span>

    <span class="c1"># adjust the edge lengths of all the nodes, so they are at the</span>
    <span class="c1"># correct height, with the edges &#39;lining up&#39; at the end of</span>
    <span class="c1"># coalescent period</span>
    <span class="k">if</span> <span class="n">time_remaining</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">time_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">time_remaining</span>

    <span class="c1"># return the list of nodes that have not coalesced</span>
    <span class="k">return</span> <span class="n">nodes</span></div>



<div class="viewcode-block" id="node_waiting_time_pairs">
<a class="viewcode-back" href="../../../library/coalescent.html#dendropy.model.coalescent.node_waiting_time_pairs">[docs]</a>
<span class="k">def</span> <span class="nf">node_waiting_time_pairs</span><span class="p">(</span>
    <span class="n">tree</span><span class="p">,</span> <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">DEFAULT_ULTRAMETRICITY_PRECISION</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of tuples of (nodes, coalescent interval time) on the tree.</span>
<span class="sd">    That is, each element in the list is tuple pair consisting of where: the</span>
<span class="sd">    first element of the pair is an internal node representing a coalescent</span>
<span class="sd">    event on the tree, and the second element of the pair is the time between</span>
<span class="sd">    this coalescence event and the earlier (more recent) one.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tree : |Tree|</span>
<span class="sd">        A tree instance.</span>
<span class="sd">    ultrametricity_precision : float</span>
<span class="sd">        When calculating the node ages, an error will be raised if the tree is</span>
<span class="sd">        not ultrametric. This error may be due to floating-point or numerical</span>
<span class="sd">        imprecision. You can set the precision of the ultrametricity validation</span>
<span class="sd">        by setting the ``ultrametricity_precision`` parameter. E.g., use</span>
<span class="sd">        ``ultrametricity_precision=0.01`` for a more relaxed precision, down to</span>
<span class="sd">        2 decimal places. Use ``ultrametricity_precision=False`` to disable</span>
<span class="sd">        checking of ultrametricity.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : list of tuples (node, coalescent interval)</span>
<span class="sd">        Returns list of tuples of (node, coalescent interval [= time between</span>
<span class="sd">        last coalescent event and current node age])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tree</span><span class="o">.</span><span class="n">calc_node_ages</span><span class="p">(</span><span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">ultrametricity_precision</span><span class="p">)</span>
    <span class="n">ages</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">age</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">internal_nodes</span><span class="p">()]</span>
    <span class="n">ages</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ages</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ages</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">nd</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">prev_nd</span> <span class="o">=</span> <span class="n">ages</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nd</span><span class="p">,</span> <span class="n">nd</span><span class="o">.</span><span class="n">age</span> <span class="o">-</span> <span class="n">prev_nd</span><span class="o">.</span><span class="n">age</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">intervals</span></div>



<div class="viewcode-block" id="extract_coalescent_frames">
<a class="viewcode-back" href="../../../library/coalescent.html#dendropy.model.coalescent.extract_coalescent_frames">[docs]</a>
<span class="k">def</span> <span class="nf">extract_coalescent_frames</span><span class="p">(</span>
    <span class="n">tree</span><span class="p">,</span> <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">DEFAULT_ULTRAMETRICITY_PRECISION</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of tuples describing the coalescent frames on the tree. That</span>
<span class="sd">    is, each element in the list is tuple pair consisting of where: the first</span>
<span class="sd">    element of the pair is the number of separate lineages remaining on the</span>
<span class="sd">    tree at coalescence event, and the second element of the pair is the time</span>
<span class="sd">    between this coalescence event and the earlier (more recent) one.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tree : |Tree|</span>
<span class="sd">        A tree instance.</span>
<span class="sd">    ultrametricity_precision : float</span>
<span class="sd">        When calculating the node ages, an error will be raised if the tree is</span>
<span class="sd">        not ultrametric. This error may be due to floating-point or numerical</span>
<span class="sd">        imprecision. You can set the precision of the ultrametricity validation</span>
<span class="sd">        by setting the ``ultrametricity_precision`` parameter. E.g., use</span>
<span class="sd">        ``ultrametricity_precision=0.01`` for a more relaxed precision, down to</span>
<span class="sd">        2 decimal places. Use ``ultrametricity_precision=False`` to disable</span>
<span class="sd">        checking of ultrametricity.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : dict</span>
<span class="sd">        Returns dictionary, with key = number of alleles, and values = waiting</span>
<span class="sd">        time for coalescent for the given tree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nwti</span> <span class="o">=</span> <span class="n">node_waiting_time_pairs</span><span class="p">(</span>
        <span class="n">tree</span><span class="p">,</span> <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">ultrametricity_precision</span>
    <span class="p">)</span>
    <span class="c1">#     num_genes = len(tree.taxon_namespace)</span>
    <span class="n">num_genes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">())</span>
    <span class="n">num_genes_wt</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nwti</span><span class="p">:</span>
        <span class="n">num_genes_wt</span><span class="p">[</span><span class="n">num_genes</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">num_genes</span> <span class="o">=</span> <span class="n">num_genes</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># num_alleles_list = sorted(num_genes_wt.keys(), reverse=True)</span>
    <span class="k">return</span> <span class="n">num_genes_wt</span></div>



<div class="viewcode-block" id="log_probability_of_coalescent_frames">
<a class="viewcode-back" href="../../../library/coalescent.html#dendropy.model.coalescent.log_probability_of_coalescent_frames">[docs]</a>
<span class="k">def</span> <span class="nf">log_probability_of_coalescent_frames</span><span class="p">(</span><span class="n">coalescent_frames</span><span class="p">,</span> <span class="n">haploid_pop_size</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Under the classical neutral coalescent :math:`\citep{Kingman1982,</span>
<span class="sd">    Kingman1982b}`, the waiting times between coalescent events in a</span>
<span class="sd">    sample of :math:`k` alleles segregating in a  population of (haploid) size</span>
<span class="sd">    :math:`N_e` is distributed exponentially with a rate parameter of</span>
<span class="sd">    :math:`\frac{{k \choose 2}}{N_e}`:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \Pr(T) =  \frac{{k \choose 2}}{N_e} e^{-  \frac{{k \choose 2}}{N_e} T},</span>

<span class="sd">    where :math:`T` is the length of  (chronological) time in which there are</span>
<span class="sd">    :math:`k` alleles in the sample (i.e., for :math:`k` alleles to coalesce into</span>
<span class="sd">    :math:`k-1` alleles).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">coalescent_frames</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">k2N</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">haploid_pop_size</span>
        <span class="c1">#         k2N = float(combinatorics.choose(k, 2)) / haploid_pop_size</span>
        <span class="n">lp</span> <span class="o">=</span> <span class="n">lp</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">k2N</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">k2N</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lp</span></div>



<div class="viewcode-block" id="log_probability_of_coalescent_tree">
<a class="viewcode-back" href="../../../library/coalescent.html#dendropy.model.coalescent.log_probability_of_coalescent_tree">[docs]</a>
<span class="k">def</span> <span class="nf">log_probability_of_coalescent_tree</span><span class="p">(</span>
    <span class="n">tree</span><span class="p">,</span>
    <span class="n">haploid_pop_size</span><span class="p">,</span>
    <span class="n">ultrametricity_precision</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">DEFAULT_ULTRAMETRICITY_PRECISION</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wraps up extraction of coalescent frames and reporting of probability.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">log_probability_of_coalescent_frames</span><span class="p">(</span>
        <span class="n">extract_coalescent_frames</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="n">haploid_pop_size</span>
    <span class="p">)</span></div>



<span class="c1">###############################################################################</span>
<span class="c1">## Tree Simulations</span>


<div class="viewcode-block" id="contained_coalescent_tree">
<a class="viewcode-back" href="../../../library/treesim.html#dendropy.model.coalescent.contained_coalescent_tree">[docs]</a>
<span class="k">def</span> <span class="nf">contained_coalescent_tree</span><span class="p">(</span>
    <span class="n">containing_tree</span><span class="p">,</span>
    <span class="n">gene_to_containing_taxon_map</span><span class="p">,</span>
    <span class="n">edge_pop_size_attr</span><span class="o">=</span><span class="s2">&quot;pop_size&quot;</span><span class="p">,</span>
    <span class="n">default_pop_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a gene tree simulated under the coalescent contained within a</span>
<span class="sd">    population or species tree.</span>

<span class="sd">        ``containing_tree``</span>
<span class="sd">            The population or species tree. If ``edge_pop_size_map`` is not None,</span>
<span class="sd">            and population sizes given are non-trivial (i.e., &gt;1), then edge</span>
<span class="sd">            lengths on this tree are in units of generations. Otherwise edge</span>
<span class="sd">            lengths are in population units; i.e. 2N generations for diploid</span>
<span class="sd">            populations of size N, or N generations for diploid populations of</span>
<span class="sd">            size N.</span>

<span class="sd">        ``gene_to_containing_taxon_map``</span>
<span class="sd">            A TaxonNamespaceMapping object mapping Taxon objects in the</span>
<span class="sd">            ``containing_tree`` TaxonNamespace to corresponding Taxon objects in the</span>
<span class="sd">            resulting gene tree.</span>

<span class="sd">        ``edge_pop_size_attr``</span>
<span class="sd">            Name of attribute of edges that specify population size. By default</span>
<span class="sd">            this is &quot;pop_size&quot;. If this attribute does not exist,</span>
<span class="sd">            ``default_pop_size`` will be used.  The value for this attribute</span>
<span class="sd">            should be the haploid population size or the number of genes;</span>
<span class="sd">            i.e.  2N for a diploid population of N individuals, or N for a</span>
<span class="sd">            haploid population of N individuals. This value determines how</span>
<span class="sd">            branch length units are interpreted in the input tree,</span>
<span class="sd">            ``containing_tree``.  If a biologically-meaningful value, then branch</span>
<span class="sd">            lengths on the ``containing_tree`` are properly read as generations.</span>
<span class="sd">            If not (e.g. 1 or 0), then they are in population units, i.e. where</span>
<span class="sd">            1 unit of time equals 2N generations for a diploid population of</span>
<span class="sd">            size N, or N generations for a haploid population of size N.</span>
<span class="sd">            Otherwise time is in generations. If this argument is None, then</span>
<span class="sd">            population sizes default to ``default_pop_size``.</span>

<span class="sd">        ``default_pop_size``</span>
<span class="sd">            Population size to use if ``edge_pop_size_attr`` is None or</span>
<span class="sd">            if an edge does not have the attribute. Defaults to 1.</span>

<span class="sd">    The returned gene tree will have the following extra attributes:</span>

<span class="sd">        ``pop_node_genes``</span>
<span class="sd">            A dictionary with nodes of ``containing_tree`` as keys and a list of gene</span>
<span class="sd">            tree nodes that are uncoalesced as values.</span>

<span class="sd">    Note that this function does very much the same thing as</span>
<span class="sd">    ``constrained_kingman_tree()``, but provides a very different API.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>

    <span class="n">gene_tree_taxon_namespace</span> <span class="o">=</span> <span class="n">gene_to_containing_taxon_map</span><span class="o">.</span><span class="n">domain_taxon_namespace</span>
    <span class="k">if</span> <span class="n">gene_tree_taxon_namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gene_tree_taxon_namespace</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">TaxonNamespace</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">gene_taxa</span> <span class="ow">in</span> <span class="n">gene_to_containing_taxon_map</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="n">gene_taxa</span><span class="p">:</span>
                <span class="n">gene_tree_taxon_namespace</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span>
    <span class="n">gene_tree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="o">=</span><span class="n">gene_tree_taxon_namespace</span><span class="p">)</span>
    <span class="n">gene_tree</span><span class="o">.</span><span class="n">is_rooted</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">pop_node_genes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pop_gene_taxa</span> <span class="o">=</span> <span class="n">gene_to_containing_taxon_map</span><span class="o">.</span><span class="n">reverse</span>
    <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">containing_tree</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">and</span> <span class="n">nd</span><span class="o">.</span><span class="n">taxon</span> <span class="ow">in</span> <span class="n">pop_gene_taxa</span><span class="p">:</span>
            <span class="n">pop_node_genes</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">gene_taxa</span> <span class="o">=</span> <span class="n">pop_gene_taxa</span><span class="p">[</span><span class="n">nd</span><span class="o">.</span><span class="n">taxon</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">gene_taxon</span> <span class="ow">in</span> <span class="n">gene_taxa</span><span class="p">:</span>
                <span class="n">gene_node</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Node</span><span class="p">()</span>
                <span class="n">gene_node</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="n">gene_taxon</span>
                <span class="n">pop_node_genes</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gene_node</span><span class="p">)</span>
            <span class="c1"># gene_nodes = [dendropy.Node() for i in range(len(gene_taxa))]</span>
            <span class="c1"># for gidx, gene_node in enumerate(gene_nodes):</span>
            <span class="c1">#    gene_node.taxon = gene_taxa[gidx]</span>
            <span class="c1">#    pop_node_genes[nd].append(gene_node)</span>

    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">containing_tree</span><span class="o">.</span><span class="n">postorder_edge_iter</span><span class="p">():</span>

        <span class="k">if</span> <span class="n">edge_pop_size_attr</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">edge_pop_size_attr</span><span class="p">):</span>
            <span class="n">pop_size</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">edge_pop_size_attr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pop_size</span> <span class="o">=</span> <span class="n">default_pop_size</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="o">.</span><span class="n">parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop_node_genes</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">final</span> <span class="o">=</span> <span class="n">coalesce_nodes</span><span class="p">(</span>
                    <span class="n">nodes</span><span class="o">=</span><span class="n">pop_node_genes</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="p">],</span>
                    <span class="n">pop_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span>
                    <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">final</span> <span class="o">=</span> <span class="n">pop_node_genes</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="p">]</span>
            <span class="n">gene_tree</span><span class="o">.</span><span class="n">seed_node</span> <span class="o">=</span> <span class="n">final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uncoal</span> <span class="o">=</span> <span class="n">coalesce_nodes</span><span class="p">(</span>
                <span class="n">nodes</span><span class="o">=</span><span class="n">pop_node_genes</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="p">],</span>
                <span class="n">pop_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span>
                <span class="n">period</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pop_node_genes</span><span class="p">:</span>
                <span class="n">pop_node_genes</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">pop_node_genes</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">uncoal</span><span class="p">)</span>

    <span class="n">gene_tree</span><span class="o">.</span><span class="n">pop_node_genes</span> <span class="o">=</span> <span class="n">pop_node_genes</span>
    <span class="k">return</span> <span class="n">gene_tree</span></div>



<div class="viewcode-block" id="pure_kingman_tree">
<a class="viewcode-back" href="../../../library/treesim.html#dendropy.model.coalescent.pure_kingman_tree">[docs]</a>
<span class="k">def</span> <span class="nf">pure_kingman_tree</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="p">,</span> <span class="n">pop_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a tree under the unconstrained Kingman&#39;s coalescent process.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    taxon_namespace: |TaxonNamespace| instance</span>
<span class="sd">        A pre-populated |TaxonNamespace| where the contained |Taxon| instances</span>
<span class="sd">        represent the genes or individuals sampled from the population.</span>
<span class="sd">    pop_size : numeric</span>
<span class="sd">        The size of the population from the which the coalescent process is</span>
<span class="sd">        sampled.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t : |Tree|</span>
<span class="sd">        A tree sampled from the Kingman&#39;s neutral coalescent.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>  <span class="c1"># use the global rng by default</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dendropy</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">taxon</span><span class="o">=</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">taxon_namespace</span><span class="p">]</span>
    <span class="n">seed_node</span> <span class="o">=</span> <span class="n">coalesce_nodes</span><span class="p">(</span>
        <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">pop_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">,</span> <span class="n">use_expected_tmrca</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">,</span> <span class="n">seed_node</span><span class="o">=</span><span class="n">seed_node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree</span></div>



<div class="viewcode-block" id="pure_kingman_tree_shape">
<a class="viewcode-back" href="../../../library/coalescent.html#dendropy.model.coalescent.pure_kingman_tree_shape">[docs]</a>
<span class="k">def</span> <span class="nf">pure_kingman_tree_shape</span><span class="p">(</span><span class="n">num_leaves</span><span class="p">,</span> <span class="n">pop_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like :func:`dendropy.model.pure_kingman_tree`, but does not assign taxa to tips.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_leaves : int</span>
<span class="sd">        Number of individuals/genes sampled.</span>
<span class="sd">    pop_size : numeric</span>
<span class="sd">        The size of the population from the which the coalescent process is</span>
<span class="sd">        sampled.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t : |Tree|</span>
<span class="sd">        A tree sampled from the Kingman&#39;s neutral coalescent.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>  <span class="c1"># use the global rng by default</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dendropy</span><span class="o">.</span><span class="n">Node</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_leaves</span><span class="p">)]</span>
    <span class="n">seed_node</span> <span class="o">=</span> <span class="n">coalesce_nodes</span><span class="p">(</span>
        <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">pop_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">,</span> <span class="n">use_expected_tmrca</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">seed_node</span><span class="o">=</span><span class="n">seed_node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree</span></div>



<div class="viewcode-block" id="mean_kingman_tree">
<a class="viewcode-back" href="../../../library/treesim.html#dendropy.model.coalescent.mean_kingman_tree">[docs]</a>
<span class="k">def</span> <span class="nf">mean_kingman_tree</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="p">,</span> <span class="n">pop_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tree with coalescent intervals given by the expected times under</span>
<span class="sd">    Kingman&#39;s neutral coalescent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>  <span class="c1"># use the global rng by default</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dendropy</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">taxon</span><span class="o">=</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">taxon_namespace</span><span class="p">]</span>
    <span class="n">seed_node</span> <span class="o">=</span> <span class="n">coalesce_nodes</span><span class="p">(</span>
        <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">pop_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">,</span> <span class="n">use_expected_tmrca</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">,</span> <span class="n">seed_node</span><span class="o">=</span><span class="n">seed_node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tree</span></div>



<div class="viewcode-block" id="constrained_kingman_tree">
<a class="viewcode-back" href="../../../library/treesim.html#dendropy.model.coalescent.constrained_kingman_tree">[docs]</a>
<span class="k">def</span> <span class="nf">constrained_kingman_tree</span><span class="p">(</span>
    <span class="n">pop_tree</span><span class="p">,</span>
    <span class="n">gene_tree_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gene_node_label_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gene_sampling_strategy</span><span class="o">=</span><span class="s2">&quot;random_uniform&quot;</span><span class="p">,</span>
    <span class="n">num_genes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_genes_attr</span><span class="o">=</span><span class="s2">&quot;num_genes&quot;</span><span class="p">,</span>
    <span class="n">pop_size_attr</span><span class="o">=</span><span class="s2">&quot;pop_size&quot;</span><span class="p">,</span>
    <span class="n">decorate_original_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a population tree, ``pop_tree`` this will return a *pair of</span>
<span class="sd">    trees*: a gene tree simulated on this population tree based on</span>
<span class="sd">    Kingman&#39;s n-coalescent, and population tree with the additional</span>
<span class="sd">    attribute &#39;gene_nodes&#39; on each node, which is a list of</span>
<span class="sd">    uncoalesced nodes from the gene tree associated with the given</span>
<span class="sd">    node from the population tree.</span>

<span class="sd">    ``pop_tree``: a Tree object.</span>

<span class="sd">    ``gene_sampling_strategy``: string</span>
<span class="sd">        - &quot;node_attribute&quot;: Will expect each leaf of ``pop_tree`` to</span>
<span class="sd">          have an attribute, ``num_genes``, that specifies the number</span>
<span class="sd">          of genes to be sampled from that population.</span>
<span class="sd">        - &quot;fixed_per_population&quot;: Will assign ``num_genes`` to each population.</span>
<span class="sd">        - &quot;random_uniform&quot;: Will assign genes to leaves with</span>
<span class="sd">          uniform probability until ``num_genes`` genes have been</span>
<span class="sd">          assigned.</span>

<span class="sd">    ``pop_size_attr``: string</span>
<span class="sd">        The attribute name of the edges of ``pop_tree`` that</span>
<span class="sd">        specify the population size. By default it is ``pop_size``. The should</span>
<span class="sd">        specify the effective *haploid* population size; i.e., number of gene</span>
<span class="sd">        in the population: 2 * N in a diploid population of N individuals,</span>
<span class="sd">        or N in a haploid population of N individuals.</span>

<span class="sd">    If ``pop_size`` is 1 or 0 or None, then the edge lengths of ``pop_tree`` is</span>
<span class="sd">    taken to be in haploid population units; i.e. where 1 unit equals 2N</span>
<span class="sd">    generations for a diploid population of size N, or N generations for a</span>
<span class="sd">    haploid population of size N. Otherwise the edge lengths of ``pop_tree`` is</span>
<span class="sd">    taken to be in generations.</span>

<span class="sd">    If ``gene_tree_list`` is given, then the gene tree is added to the</span>
<span class="sd">    tree block, and the tree block&#39;s taxa block will be used to manage</span>
<span class="sd">    the gene tree&#39;s ``taxa``.</span>

<span class="sd">    ``gene_node_label_fn`` is a function that takes two arguments (a string</span>
<span class="sd">    and an integer, respectively, where the string is the containing species</span>
<span class="sd">    taxon label and the integer is the gene index) and returns a label for</span>
<span class="sd">    the corresponding the gene node.</span>

<span class="sd">    if ``decorate_original_tree`` is True, then the list of uncoalesced nodes at</span>
<span class="sd">    each node of the population tree is added to the original (input) population</span>
<span class="sd">    tree instead of a copy.</span>

<span class="sd">    If ``num_genes`` is None, then it will be set to 1 under the</span>
<span class="sd">    &quot;node_attribute&quot; strategy (serving as a fallback default for nodes that do</span>
<span class="sd">    not spcify ``num_genes_attr``) or the leaf count of ``pop_tree`` under the</span>
<span class="sd">    ``random_uniform`` strategy.</span>

<span class="sd">    Note that this function does very much the same thing as</span>
<span class="sd">    ``contained_coalescent_tree()``,</span>
<span class="sd">    but provides a very different API.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get our random number generator</span>
    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">GLOBAL_RNG</span>  <span class="c1"># use the global rng by default</span>

    <span class="k">if</span> <span class="n">gene_tree_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gtaxa</span> <span class="o">=</span> <span class="n">gene_tree_list</span><span class="o">.</span><span class="n">taxon_namespace</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gtaxa</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">TaxonNamespace</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">gene_node_label_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gene_node_label_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_</span><span class="si">%02d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># @MAM taking a stab at a reasonable default for num_genes,</span>
    <span class="c1"># it may make sense to do something else entirely here</span>
    <span class="k">if</span> <span class="n">num_genes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gene_sampling_strategy</span> <span class="o">==</span> <span class="s2">&quot;random_uniform&quot;</span><span class="p">:</span>
            <span class="n">num_genes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">__</span> <span class="ow">in</span> <span class="n">pop_tree</span><span class="o">.</span><span class="n">leaf_node_iter</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">gene_sampling_strategy</span> <span class="o">==</span> <span class="s2">&quot;node_attribute&quot;</span><span class="p">:</span>
            <span class="n">num_genes</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_genes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># we create a set of gene nodes for each leaf node on the population</span>
    <span class="c1"># tree, and associate those gene nodes to the leaf by assignment</span>
    <span class="c1"># of &#39;taxon&#39;.</span>
    <span class="k">if</span> <span class="n">gene_sampling_strategy</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;node_attribute&quot;</span><span class="p">,</span> <span class="s2">&quot;fixed_per_population&quot;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">leaf_count</span><span class="p">,</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pop_tree</span><span class="o">.</span><span class="n">leaf_node_iter</span><span class="p">()):</span>
            <span class="n">gene_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">gene_sampling_strategy</span> <span class="o">==</span> <span class="s2">&quot;node_attribute&quot;</span><span class="p">:</span>
                <span class="n">node_ngenes</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">num_genes_attr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_ngenes</span> <span class="o">=</span> <span class="n">num_genes</span>
            <span class="k">for</span> <span class="n">gene_count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node_ngenes</span><span class="p">):</span>
                <span class="n">gene_node</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Node</span><span class="p">()</span>
                <span class="n">gene_node</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="n">gtaxa</span><span class="o">.</span><span class="n">require_taxon</span><span class="p">(</span>
                    <span class="n">label</span><span class="o">=</span><span class="n">gene_node_label_fn</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">gene_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">gene_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gene_node</span><span class="p">)</span>
            <span class="n">leaf</span><span class="o">.</span><span class="n">gene_nodes</span> <span class="o">=</span> <span class="n">gene_nodes</span>
    <span class="k">elif</span> <span class="n">gene_sampling_strategy</span> <span class="o">==</span> <span class="s2">&quot;random_uniform&quot;</span><span class="p">:</span>
        <span class="n">gene_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">leaves</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pop_tree</span><span class="o">.</span><span class="n">leaf_node_iter</span><span class="p">())</span>
        <span class="k">while</span> <span class="n">gene_count</span> <span class="o">&lt;</span> <span class="n">num_genes</span><span class="p">:</span>
            <span class="n">gene_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">leaf</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">leaves</span><span class="p">)</span>
            <span class="n">gene_node</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Node</span><span class="p">()</span>
            <span class="n">gene_node</span><span class="o">.</span><span class="n">taxon</span> <span class="o">=</span> <span class="n">gtaxa</span><span class="o">.</span><span class="n">require_taxon</span><span class="p">(</span>
                <span class="n">label</span><span class="o">=</span><span class="n">gene_node_label_fn</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">gene_count</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">leaf</span><span class="o">.</span><span class="n">gene_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gene_node</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">leaf</span><span class="o">.</span><span class="n">gene_nodes</span> <span class="o">=</span> <span class="p">[</span> <span class="n">gene_node</span> <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized strategy &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">gene_sampling_strategy</span>
        <span class="p">))</span>

    <span class="c1"># We iterate through the edges of the population tree in post-order,</span>
    <span class="c1"># i.e., visiting child edges before we visit parent edges. For</span>
    <span class="c1"># each edge visited, we take the genes found in the child nodes,</span>
    <span class="c1"># and run the coalescent simulation on them attacheded by the length</span>
    <span class="c1"># of the edge. Any genes that have not yet coalesced at the end of</span>
    <span class="c1"># this period are added to the genes of the tail (parent) node of</span>
    <span class="c1"># the edge.</span>

    <span class="k">if</span> <span class="n">decorate_original_tree</span><span class="p">:</span>
        <span class="n">working_poptree</span> <span class="o">=</span> <span class="n">pop_tree</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># start with a new (deep) copy of the population tree so as to not</span>
        <span class="c1"># to change the original tree</span>
        <span class="n">working_poptree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">pop_tree</span><span class="p">)</span>

    <span class="c1"># start with a new tree</span>
    <span class="n">gene_tree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="p">()</span>
    <span class="n">gene_tree</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">gtaxa</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">working_poptree</span><span class="o">.</span><span class="n">postorder_edge_iter</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="p">,</span> <span class="s2">&quot;gene_nodes&quot;</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="c1"># if mrca root, run unconstrained coalescent</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">pop_size_attr</span><span class="p">):</span>
            <span class="n">pop_size</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">pop_size_attr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this means all our time will be in population units</span>
            <span class="n">pop_size</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="o">.</span><span class="n">parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="o">.</span><span class="n">gene_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">final</span> <span class="o">=</span> <span class="n">coalesce_nodes</span><span class="p">(</span>
                    <span class="n">nodes</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="o">.</span><span class="n">gene_nodes</span><span class="p">,</span>
                    <span class="n">pop_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span>
                    <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">final</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="o">.</span><span class="n">gene_nodes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">final</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ProcessFailedException</span><span class="p">()</span>
            <span class="n">gene_tree</span><span class="o">.</span><span class="n">seed_node</span> <span class="o">=</span> <span class="n">final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uncoal</span> <span class="o">=</span> <span class="n">coalesce_nodes</span><span class="p">(</span>
                <span class="n">nodes</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">head_node</span><span class="o">.</span><span class="n">gene_nodes</span><span class="p">,</span>
                <span class="n">pop_size</span><span class="o">=</span><span class="n">pop_size</span><span class="p">,</span>
                <span class="n">period</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span><span class="p">,</span> <span class="s2">&quot;gene_nodes&quot;</span><span class="p">):</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span><span class="o">.</span><span class="n">gene_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">edge</span><span class="o">.</span><span class="n">tail_node</span><span class="o">.</span><span class="n">gene_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">uncoal</span><span class="p">)</span>

    <span class="n">gene_tree</span><span class="o">.</span><span class="n">is_rooted</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">gene_tree_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gene_tree_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gene_tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gene_tree</span><span class="p">,</span> <span class="n">working_poptree</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gene_tree</span><span class="p">,</span> <span class="n">working_poptree</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div style="text-align: center; padding-top: 20px; padding-bottom: 5px; width: 100%;">
    <a href="../../../index.html"><img src="../../../_static/dendropy_logo.png" /></a>
</div><div style="clear:both; width: 100%; height:1px;"></div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div><div style="clear:both; width: 100%; height:1px;"></div>
    <!-- Documentation -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Documentation</h3>
        <ul>
            <li><a href="../../../primer/downloading.html">Downloading and Installing DendroPy</a></li>
            <li><a href="../../../primer/index.html">The DendroPy Primer</a></li>
            <li><a href="../../../library/index.html">Library API Reference</a></li>
            <li>
                <a href="../../../schemas/index.html">Schemas</a>
                <ul>
                    <li><a href="../../../schemas/fasta.html">FASTA</a></li>
                    <li><a href="../../../schemas/newick.html">Newick</a></li>
                    <li><a href="../../../schemas/nexml.html">NeXML</a></li>
                    <li><a href="../../../schemas/nexus.html">Nexus</a></li>
                    <li><a href="../../../schemas/phylip.html">PHYLIP</a></li>
                </ul>
            </li>
            <li>
                <a href="../../../programs/index.html">Programs</a>
                <ul>
                    <li><a href="../../../programs/sumtrees.html">SumTrees</a></li>
                </ul>
            </li>
            <li><a href="../../../glossary.html">Glossary and Terminological Reference</a></li>
            <li><a href="../../../developer.html">Developer Guide</a></li>
            <li><a href="../../../planning.html">Ongoing Development</a></li>
            <li><a href="../../../changes.html">Change History</a></li>
        </ul>
    </div>

    <!-- Downloads -->
    <div style="border-top: double 1px white; padding-top: 10px;">
        <h3>Obtaining</h3>
        <ul>
            <li><a target="_blank" href="http://pypi.python.org/pypi/DendroPy">Install from the Python Package Index</a></li>
            <li><a target="_blank" href="http://pypi.python.org/packages/source/D/DendroPy/DendroPy-5.0.3.tar.gz">Download the Source Code Archive</a></li>
            <li><a target="_blank" href="http://github.com/jeetsukumaran/DendroPy">Clone the Source Code Repository</a></li>
        </ul>
    </div>

    <!-- Discussions -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Discussion</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot; DendroPy Users&quot; </a>group to follow and participate in discussion, troubleshooting, help, information, suggestions, etc. on the usage and development of the DendroPy phylogenetic computing library.</p>
            <form action="http://groups.google.com/group/dendropy-users/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-users?hl=en">&quot;dendropy-users&quot;</a> group, or click <a href="http://groups.google.com/group/dendropy-users?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Announcements -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative;">
        <h3><span style="text-align: left">Announcements</span><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/google-groups-logo1.png" height="20px" alt="Google Groups" /></span></h3>
        <div style="margin-top: 15px;">
            <p style="font-size: 90%; margin-top: 3px; clear: both;">Join the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; DendroPy Announcements&quot; </a>group to receive announcements of new releases, updates, changes and other news of interest to DendroPy users and developers.</p>
            <form action="http://groups.google.com/group/dendropy-announce/boxsubscribe">
                <input type=text name=email>
                <input type=submit name="sub" value="Subscribe">
            </form>
            <p style="font-size: 90%; clear: both; padding-top: 5px; padding-bottom: 10px;">Enter your e-mail address in the box above and click the &quot;subscribe&quot; button to subscribe to the <a href="http://groups.google.com/group/dendropy-announce?hl=en">&quot; dendropy-announce&quot; </a>group, or click <a href="http://groups.google.com/group/dendropy-announce?hl=en">here</a> to visit this group page directly.</p>
        </div>
    </div>

    <!-- Development -->
    <div style="border-top: double 1px white; padding-top: 10px; position: relative; padding-bottom: 15px; margin-bottom:5px;">
        <h3><span style="text-align: left"><a href="https://github.com/jeetsukumaran/DendroPy/">Development</a></span><a href="https://github.com/jeetsukumaran/DendroPy/"><span style="position: absolute; right: 0; top: 10px "><img src="../../../_static/Octocat.png" height="30px" alt="GitHub" /></span></a></h3>
        <div style="margin-top: 15px;">
            <!-- <a href="https://github.com/jeetsukumaran/DendroPy/issues">Issues</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/subscription">Watch</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/fork">Fork</a> &bull; <a href="https://github.com/jeetsukumaran/DendroPy/stargazers">Star</a> &bull; <a href="https://github.com/jeetsukumaran/">Follow</a> -->
            <ul>
                <li>                <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/issues"><code>Issues</code></a></span> <span style="font-style: italic; font-size:80%;"> - Report bugs or request features</span></li>
                <li>     <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/subscription"><code>&nbsp;Watch</code></a></span> <span style="font-style: italic; font-size:80%;"> - Follow development activity</span></li>
                <li>        <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/fork"><code>&nbsp;&nbsp;Fork</code></a></span> <span style="font-style: italic; font-size:80%;"> - Contribute and collaborate</span></li>
                <li>  <span style="font-weight: bold;"><a href="https://github.com/jeetsukumaran/DendroPy/stargazers"><code>&nbsp;&nbsp;Star</code></a></span> <span style="font-style: italic; font-size:80%;"> - Throw some glitter, add some glamour</span></li>
        </div>
    </div>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DendroPy 5.0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">dendropy.model.coalescent</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2009-2025, Jeet Sukumaran and Mark T. Holder.
    </div>
  </body>
</html>